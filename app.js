(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\MTLLoader.js":[function(require,module,exports){
/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

var THREE = require('three');

THREE.MTLLoader = function( baseUrl, options, crossOrigin ) {

	this.baseUrl = baseUrl;
	this.options = options;
	this.crossOrigin = crossOrigin;

};

THREE.MTLLoader.prototype = {

	constructor: THREE.MTLLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( text ) );

		}, onProgress, onError );

	},

	/**
	 * Parses loaded MTL file
	 * @param text - Content of MTL file
	 * @return {THREE.MTLLoader.MaterialCreator}
	 */
	parse: function ( text ) {

		var lines = text.split( "\n" );
		var info = {};
		var delimiter_pattern = /\s+/;
		var materialsInfo = {};

		for ( var i = 0; i < lines.length; i ++ ) {

			var line = lines[ i ];
			line = line.trim();

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				// Blank line or comment ignore
				continue;

			}

			var pos = line.indexOf( ' ' );

			var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
			key = key.toLowerCase();

			var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : "";
			value = value.trim();

			if ( key === "newmtl" ) {

				// New material

				info = { name: value };
				materialsInfo[ value ] = info;

			} else if ( info ) {

				if ( key === "ka" || key === "kd" || key === "ks" ) {

					var ss = value.split( delimiter_pattern, 3 );
					info[ key ] = [ parseFloat( ss[0] ), parseFloat( ss[1] ), parseFloat( ss[2] ) ];

				} else {

					info[ key ] = value;

				}

			}

		}

		var materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.options );
		materialCreator.setMaterials( materialsInfo );
		return materialCreator;

	}

};

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 *                  invertTransparency: If transparency need to be inverted (inversion is needed if d = 0 is fully opaque)
 *                                      Default: false (d = 1 is fully opaque)
 * @constructor
 */

THREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {

	this.baseUrl = baseUrl;
	this.options = options;
	this.materialsInfo = {};
	this.materials = {};
	this.materialsArray = [];
	this.nameLookup = {};

	this.side = ( this.options && this.options.side )? this.options.side: THREE.FrontSide;
	this.wrap = ( this.options && this.options.wrap )? this.options.wrap: THREE.RepeatWrapping;

};

THREE.MTLLoader.MaterialCreator.prototype = {

	constructor: THREE.MTLLoader.MaterialCreator,

	setMaterials: function( materialsInfo ) {

		this.materialsInfo = this.convert( materialsInfo );
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

	},

	convert: function( materialsInfo ) {

		if ( !this.options ) return materialsInfo;

		var converted = {};

		for ( var mn in materialsInfo ) {

			// Convert materials info into normalized form based on options

			var mat = materialsInfo[ mn ];

			var covmat = {};

			converted[ mn ] = covmat;

			for ( var prop in mat ) {

				var save = true;
				var value = mat[ prop ];
				var lprop = prop.toLowerCase();

				switch ( lprop ) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if ( this.options && this.options.normalizeRGB ) {

							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

						}

						if ( this.options && this.options.ignoreZeroRGBs ) {

							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {

								// ignore

								save = false;

							}
						}

						break;

					case 'd':

						// According to MTL format (http://paulbourke.net/dataformats/mtl/):
						//   d is dissolve for current material
						//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)

						if ( this.options && this.options.invertTransparency ) {

							value = 1 - value;

						}

						break;

					default:

						break;
				}

				if ( save ) {

					covmat[ lprop ] = value;

				}

			}

		}

		return converted;

	},

	preload: function () {

		for ( var mn in this.materialsInfo ) {

			this.create( mn );

		}

	},

	getIndex: function( materialName ) {

		return this.nameLookup[ materialName ];

	},

	getAsArray: function() {

		var index = 0;

		for ( var mn in this.materialsInfo ) {

			this.materialsArray[ index ] = this.create( mn );
			this.nameLookup[ mn ] = index;
			index ++;

		}

		return this.materialsArray;

	},

	create: function ( materialName ) {

		if ( this.materials[ materialName ] === undefined ) {

			this.createMaterial_( materialName );

		}

		return this.materials[ materialName ];

	},

	createMaterial_: function ( materialName ) {

		// Create material

		var mat = this.materialsInfo[ materialName ];
		var params = {

			name: materialName,
			side: this.side

		};

		for ( var prop in mat ) {

			var value = mat[ prop ];

			switch ( prop.toLowerCase() ) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params[ 'diffuse' ] = new THREE.Color().fromArray( value );

					break;

				case 'ka':

					// Ambient color (color under shadow) using RGB values

					params[ 'ambient' ] = new THREE.Color().fromArray( value );

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params[ 'specular' ] = new THREE.Color().fromArray( value );

					break;

				case 'map_kd':

					// Diffuse texture map

					params[ 'map' ] = this.loadTexture( this.baseUrl + value );
					params[ 'map' ].wrapS = this.wrap;
					params[ 'map' ].wrapT = this.wrap;

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params['shininess'] = value;

					break;

				case 'd':

					// According to MTL format (http://paulbourke.net/dataformats/mtl/):
					//   d is dissolve for current material
					//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)

					if ( value < 1 ) {

						params['transparent'] = true;
						params['opacity'] = value;

					}

					break;

				default:
					break;

			}

		}

		if ( params[ 'diffuse' ] ) {

			if ( !params[ 'ambient' ]) params[ 'ambient' ] = params[ 'diffuse' ];
			params[ 'color' ] = params[ 'diffuse' ];

		}

		this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
		return this.materials[ materialName ];

	},


	loadTexture: function ( url, mapping, onLoad, onError ) {

		var texture;
		var loader = THREE.Loader.Handlers.get( url );

		if ( loader !== null ) {

			texture = loader.load( url, onLoad );

		} else {

			texture = new THREE.Texture();

			loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;
			loader.load( url, function ( image ) {

				texture.image = THREE.MTLLoader.ensurePowerOfTwo_( image );
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			} );

		}

		texture.mapping = mapping;

		return texture;

	}

};

THREE.MTLLoader.ensurePowerOfTwo_ = function ( image ) {

	if ( ! THREE.Math.isPowerOfTwo( image.width ) || ! THREE.Math.isPowerOfTwo( image.height ) ) {

		var canvas = document.createElement( "canvas" );
		canvas.width = THREE.MTLLoader.nextHighestPowerOfTwo_( image.width );
		canvas.height = THREE.MTLLoader.nextHighestPowerOfTwo_( image.height );

		var ctx = canvas.getContext("2d");
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
		return canvas;

	}

	return image;

};

THREE.MTLLoader.nextHighestPowerOfTwo_ = function( x ) {

	--x;

	for ( var i = 1; i < 32; i <<= 1 ) {

		x = x | x >> i;

	}

	return x + 1;

};

THREE.EventDispatcher.prototype.apply( THREE.MTLLoader.prototype );

module.exports = THREE.MTLLoader;

},{"three":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three\\three.js"}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\OBJMTLLoader.js":[function(require,module,exports){
/**
 * Loads a Wavefront .obj file with materials
 *
 * @author mrdoob / http://mrdoob.com/
 * @author angelxuanchang
 */

var THREE = require('three'),
		MTLLoader = require('./MTLLoader.js');

THREE.OBJMTLLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.OBJMTLLoader.prototype = {

	constructor: THREE.OBJMTLLoader,

	load: function ( url, mtlurl, onLoad, onProgress, onError ) {

		var scope = this;

		var mtlLoader = new MTLLoader( url.substr( 0, url.lastIndexOf( "/" ) + 1 ) );
		mtlLoader.load( mtlurl, function ( materials ) {

			var materialsCreator = materials;
			materialsCreator.preload();

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				var object = scope.parse( text );

				object.traverse( function ( object ) {

					if ( object instanceof THREE.Mesh ) {

						if ( object.material.name ) {

							var material = materialsCreator.create( object.material.name );

							if ( material ) object.material = material;

						}

					}

				} );

				onLoad( object );

			}, onProgress, onError );

		}, onProgress, onError );

	},

	/**
	 * Parses loaded .obj file
	 * @param data - content of .obj file
	 * @param mtllibCallback - callback to handle mtllib declaration (optional)
	 * @return {THREE.Object3D} - Object3D (with default material)
	 */

	parse: function ( data, mtllibCallback ) {

		function vector( x, y, z ) {

			return new THREE.Vector3( x, y, z );

		}

		function uv( u, v ) {

			return new THREE.Vector2( u, v );

		}

		function face3( a, b, c, normals ) {

			return new THREE.Face3( a, b, c, normals );

		}

		var face_offset = 0;

		function meshN( meshName, materialName ) {

			if ( vertices.length > 0 ) {

				geometry.vertices = vertices;

				geometry.mergeVertices();
				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				object.add( mesh );

				geometry = new THREE.Geometry();
				mesh = new THREE.Mesh( geometry, material );

			}

			if ( meshName !== undefined ) mesh.name = meshName;

			if ( materialName !== undefined ) {

				material = new THREE.MeshLambertMaterial();
				material.name = materialName;

				mesh.material = material;

			}

		}

		var group = new THREE.Group();
		var object = group;

		var geometry = new THREE.Geometry();
		var material = new THREE.MeshLambertMaterial();
		var mesh = new THREE.Mesh( geometry, material );

		var vertices = [];
		var normals = [];
		var uvs = [];

		function add_face( a, b, c, normals_inds ) {

			if ( normals_inds === undefined ) {

				geometry.faces.push( face3(
					parseInt( a ) - (face_offset + 1),
					parseInt( b ) - (face_offset + 1),
					parseInt( c ) - (face_offset + 1)
				) );

			} else {

				geometry.faces.push( face3(
					parseInt( a ) - (face_offset + 1),
					parseInt( b ) - (face_offset + 1),
					parseInt( c ) - (face_offset + 1),
					[
						normals[ parseInt( normals_inds[ 0 ] ) - 1 ].clone(),
						normals[ parseInt( normals_inds[ 1 ] ) - 1 ].clone(),
						normals[ parseInt( normals_inds[ 2 ] ) - 1 ].clone()
					]
				) );

			}

		}

		function add_uvs( a, b, c ) {

			geometry.faceVertexUvs[ 0 ].push( [
				uvs[ parseInt( a ) - 1 ].clone(),
				uvs[ parseInt( b ) - 1 ].clone(),
				uvs[ parseInt( c ) - 1 ].clone()
			] );

		}

		function handle_face_line(faces, uvs, normals_inds) {

			if ( faces[ 3 ] === undefined ) {

				add_face( faces[ 0 ], faces[ 1 ], faces[ 2 ], normals_inds );

				if (!(uvs === undefined) && uvs.length > 0) {
					add_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 2 ] );
				}

			} else {

				if (!(normals_inds === undefined) && normals_inds.length > 0) {

					add_face( faces[ 0 ], faces[ 1 ], faces[ 3 ], [ normals_inds[ 0 ], normals_inds[ 1 ], normals_inds[ 3 ] ]);
					add_face( faces[ 1 ], faces[ 2 ], faces[ 3 ], [ normals_inds[ 1 ], normals_inds[ 2 ], normals_inds[ 3 ] ]);

				} else {

					add_face( faces[ 0 ], faces[ 1 ], faces[ 3 ]);
					add_face( faces[ 1 ], faces[ 2 ], faces[ 3 ]);

				}

				if (!(uvs === undefined) && uvs.length > 0) {

					add_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] );
					add_uvs( uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] );

				}

			}

		}


		// v float float float

		var vertex_pattern = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;

		// vn float float float

		var normal_pattern = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;

		// vt float float

		var uv_pattern = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;

		// f vertex vertex vertex ...

		var face_pattern1 = /f( +\d+)( +\d+)( +\d+)( +\d+)?/;

		// f vertex/uv vertex/uv vertex/uv ...

		var face_pattern2 = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/;

		// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...

		var face_pattern3 = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/;

		// f vertex//normal vertex//normal vertex//normal ...

		var face_pattern4 = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/

		//

		var lines = data.split( "\n" );

		for ( var i = 0; i < lines.length; i ++ ) {

			var line = lines[ i ];
			line = line.trim();

			var result;

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				continue;

			} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {

				// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

				vertices.push( vector(
					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] ),
					parseFloat( result[ 3 ] )
				) );

			} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {

				// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

				normals.push( vector(
					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] ),
					parseFloat( result[ 3 ] )
				) );

			} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {

				// ["vt 0.1 0.2", "0.1", "0.2"]

				uvs.push( uv(
					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] )
				) );

			} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {

				// ["f 1 2 3", "1", "2", "3", undefined]

				handle_face_line([ result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ]);

			} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {

				// ["f 1/1 2/2 3/3", " 1/1", "1", "1", " 2/2", "2", "2", " 3/3", "3", "3", undefined, undefined, undefined]

				handle_face_line(
					[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces
					[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //uv
				);

			} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {

				// ["f 1/1/1 2/2/2 3/3/3", " 1/1/1", "1", "1", "1", " 2/2/2", "2", "2", "2", " 3/3/3", "3", "3", "3", undefined, undefined, undefined, undefined]

				handle_face_line(
					[ result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ] ], //faces
					[ result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ] ], //uv
					[ result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ] ] //normal
				);

			} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {

				// ["f 1//1 2//2 3//3", " 1//1", "1", "1", " 2//2", "2", "2", " 3//3", "3", "3", undefined, undefined, undefined]

				handle_face_line(
					[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces
					[ ], //uv
					[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //normal
				);

			} else if ( /^o /.test( line ) ) {

				// object

				meshN();
				face_offset = face_offset + vertices.length;
				vertices = [];
				object = new THREE.Object3D();
				object.name = line.substring( 2 ).trim();
				group.add( object );

			} else if ( /^g /.test( line ) ) {

				// group

				meshN( line.substring( 2 ).trim(), undefined );

			} else if ( /^usemtl /.test( line ) ) {

				// material

				meshN( undefined, line.substring( 7 ).trim() );

			} else if ( /^mtllib /.test( line ) ) {

				// mtl file

				if ( mtllibCallback ) {

					var mtlfile = line.substring( 7 );
					mtlfile = mtlfile.trim();
					mtllibCallback( mtlfile );

				}

			} else if ( /^s /.test( line ) ) {

				// Smooth shading

			} else {

				console.log( "THREE.OBJMTLLoader: Unhandled line " + line );

			}

		}

		//Add last object
		meshN(undefined, undefined);

		return group;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.OBJMTLLoader.prototype );

module.exports = THREE.OBJMTLLoader;

},{"./MTLLoader.js":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\MTLLoader.js","three":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three\\three.js"}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\kinetic-controls.js":[function(require,module,exports){
module.exports = (function() {
  var Hammer = require('hammerjs');

  var instance = {}, hammertime, cam, camAnchor, minZ = 0;
  var swingX = 0, swingY = 0, wasMoved = false;

  instance.init = function(camera, cameraAnchor, minCamZ) {
    var hammertime = new Hammer(document.body, {});

    cam = camera;
    camAnchor = cameraAnchor;
    minZ = minCamZ;

    hammertime.get('pinch').set({ enable: true });

    hammertime.on('pan', function(e) {
      var turnY = Math.PI * 0.02 * (e.deltaX / window.innerWidth),
          turnX = Math.PI * 0.02 * (e.deltaY / window.innerHeight);

      if(camAnchor) {
        camAnchor.rotation.y += turnY;
        camAnchor.rotation.x += turnX;
      } else {
        cam.rotation.y += turnY;
        cam.rotation.x += turnX;
      }
      swingX = turnX;
      swingY = turnY;

      wasMoved = true;
    });

    hammertime.on('pinchmove', function(e) {
      if(e.scale >= 1.0 && camera.position.z <= minZ) return;

      camera.translateZ(1 - e.scale / 2);
      wasMoved = true;
    });

    window.addEventListener('wheel', function(e) {
      if(e.wheelDelta) { // Chrome
        camera.position.z -= e.wheelDelta / 120;
      } else { // IE / Firefox
        camera.position.z -= Math.min(-5, Math.max(e.deltaY, 5));
      }
      wasMoved = true;
    })
  };

  instance.update = function() {
    if(!camAnchor) camAnchor = cam;

    if(swingX != 0) {
      camAnchor.rotation.x += swingX;
      if(swingX < -0.001) {
        swingX += 0.001;
      } else if(swingX > 0.001) {
        swingX -= 0.001;
      } else {
        swingX = 0;
      }
    }

    if(swingY != 0) {
      camAnchor.rotation.y += swingY;
      if(swingY < -0.001) {
        swingY += 0.001;
      } else if(swingY > 0.001) {
        swingY -= 0.001;
      } else {
        swingY = 0;
      }
    }
  };

  instance.wasMoved = function() { return wasMoved; };

  return instance;
})();

},{"hammerjs":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\hammerjs\\hammer.js"}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\loading.js":[function(require,module,exports){
module.exports = (function() {
  var loading = true, container;

  this.start = function(elem, imgUrl) {
    container = elem;

    if(imgUrl) {
      var img = new Image();
      img.src = imgUrl;
      container.appendChild(img);
    }
  }

  this.stop = function() {
    loading = false;
    container.parentNode.removeChild(container);
  }

  return this;
})();

},{}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\main.js":[function(require,module,exports){
var THREE = require('three'),
    World = require('three-world'),
    ObjLoader = require('./OBJMTLLoader'),
    Loading = require('./loading'),
    Controls = require('./kinetic-controls');

Loading.start(document.getElementById("loading"));

World.init({ camDistance: 0, clearColor: 0xffffff });
World.startRenderLoop();
Controls.init(World.getCamera());

var loader = new ObjLoader(), mesh, anchor, cam = World.getCamera();

cam.rotation.order = 'YXZ';

var screen = new THREE.Mesh(
  new THREE.BoxGeometry(0.5, 2.2, 2.2),
  new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("fuckyea.png") })
);
screen.position.set(0.7, 1.2, 0);

anchor = new THREE.Object3D();

loader.load('model/TV2.obj', 'model/TV2.mtl', function(tv) {
  tv.rotation.set(0, -Math.PI/2, 0);
  tv.scale.set(18, 18, 18);
  tv.children[8].material.opacity = 0.25;
  tv.children[8].material.transparent = true;
  tv.children[8].material.needsUpdate = true;
  tv.add(screen);

  for(var side=0; side<4; side++) {
    var sideAnchor = new THREE.Object3D();
    for(var i=0; i<100; i++) {
      var tmp = tv.clone();
      tmp.position.set(-250 + (i % 10) * 50, -250 + Math.floor(i / 10) * 50, -275 );
      sideAnchor.add(tmp);
    }
    sideAnchor.rotation.y = side * (Math.PI/2);
    anchor.add(sideAnchor);
  }
  Loading.stop();

});
World.add(anchor);

/*
setTimeout(function addScan() {
  var service = ['ssh', 'http', 'ftp'][Math.floor(Math.random() * 3)];
  var scanBox = new THREE.Mesh(geometry, SERVICES[service]);
  scanBox.position.set(-50 + 12 * (currentIndex % 10), -50 + 12 * Math.floor(currentIndex / 10), 0);
  anchor.add(scanBox);
  currentIndex = ++currentIndex % 100;
  setTimeout(addScan, Math.random() * 500);
}, 100);
*/

},{"./OBJMTLLoader":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\OBJMTLLoader.js","./kinetic-controls":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\kinetic-controls.js","./loading":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\loading.js","three":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three\\three.js","three-world":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three-world\\world.js"}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\hammerjs\\hammer.js":[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three-world\\world.js":[function(require,module,exports){
var THREE = require('three');

var World = (function() {
  // Internals

  var camera, scene, renderer, frameCallback, self = {};

  function render() {
    if(frameCallback) frameCallback();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

  // Exports

  self.init = function(options) {
    if(!options) options = {};

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, options.farPlane || 2000);
    camera.position.z = options.camDistance || 100;
    frameCallback = options.renderCallback;

    // scene

    scene = new THREE.Scene();

    var ambient = new THREE.AmbientLight(options.ambientLightColor || 0xffffff);
    scene.add(ambient);

    renderer = new THREE.WebGLRenderer(options.rendererOpts);
    renderer.setSize(window.innerWidth, window.innerHeight);
    if(options.clearColor) renderer.setClearColor(options.clearColor);

    var container = options.container || document.body;
    container.appendChild(renderer.domElement);

    window.addEventListener( 'resize', onWindowResize, false );
  }

  self.add = function(object) {
    scene.add(object);
  }

  self.startRenderLoop = function() {
    render();
  }

  self.getCamera = function() { return camera; };

  return self;
})();

module.exports = World;

},{"three":"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three\\three.js"}],"c:\\Users\\Martin\\Documents\\Code\\interface3d\\node_modules\\three\\three.js":[function(require,module,exports){
var self = self || {};// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '69' };

// browserify support

if ( typeof module === 'object' ) {

	module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

	};

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

	}

	return this.set( color )

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		var clamp = THREE.Math.clamp;

		// q is assumed to be normalized

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ), - 1, 1 ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ), - 1, 1 ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ), - 1, 1 ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ), - 1, 1 ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ), - 1, 1 ) );

		} else if ( order === 'XZY' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ), - 1, 1 ) );

		} else {

			console.warn( 'THREE.Euler: .setFromQuaternion() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix3( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		return new THREE.Matrix3().fromArray( this.elements );

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix4( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {
				sx = - sx;
			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0 
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;
		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;
		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;
		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}
			}

			return uuid.join( '' );

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if ( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Sprite: {},
			Mesh: {},
			PointCloud: { threshold: 1 },
			LOD: {},
			Line: {}
		};

	};

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var intersectObject = function ( object, raycaster, intersects, recursive ) {

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	};

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		precision: 0.0001,
		linePrecision: 1,

		set: function ( origin, direction ) {

			this.ray.set( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( objects instanceof Array === false ) {

				console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = undefined;
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var scope = this;

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	var onRotationChange = function () {
		quaternion.setFromEuler( rotation, false );
	};

	var onQuaternionChange = function () {
		rotation.setFromQuaternion( quaternion, undefined, false );
	};

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
	} );

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		};

		if ( object === this ) {

			console.error( "THREE.Object3D.add:", object, "can't be added as a child of itself." );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add:", object, "is not an instance of THREE.Object3D." );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.remove( arguments[ i ] );

			}

		};

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getObjectById: function ( id, recursive ) {

		if ( this.id === id ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectById( id, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		if ( this.name === name ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByName( name, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		}

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		}

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		}

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		}

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverseVisible( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.3,
				type: 'Object',
				generator: 'ObjectExporter'
			}
		};

		//

		var geometries = {};

		var parseGeometry = function ( geometry ) {

			if ( output.geometries === undefined ) {

				output.geometries = [];

			}

			if ( geometries[ geometry.uuid ] === undefined ) {

				var json = geometry.toJSON();

				delete json.metadata;

				geometries[ geometry.uuid ] = json;

				output.geometries.push( json );

			}

			return geometry.uuid;

		};

		//

		var materials = {};

		var parseMaterial = function ( material ) {

			if ( output.materials === undefined ) {

				output.materials = [];

			}

			if ( materials[ material.uuid ] === undefined ) {

				var json = material.toJSON();

				delete json.metadata;

				materials[ material.uuid ] = json;

				output.materials.push( json );

			}

			return material.uuid;

		};

		//

		var parseObject = function ( object ) {

			var data = {};

			data.uuid = object.uuid;
			data.type = object.type;

			if ( object.name !== '' ) data.name = object.name;
			if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
			if ( object.visible !== true ) data.visible = object.visible;

			if ( object instanceof THREE.PerspectiveCamera ) {

				data.fov = object.fov;
				data.aspect = object.aspect;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.OrthographicCamera ) {

				data.left = object.left;
				data.right = object.right;
				data.top = object.top;
				data.bottom = object.bottom;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.AmbientLight ) {

				data.color = object.color.getHex();

			} else if ( object instanceof THREE.DirectionalLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;

			} else if ( object instanceof THREE.PointLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;

			} else if ( object instanceof THREE.SpotLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;
				data.angle = object.angle;
				data.exponent = object.exponent;

			} else if ( object instanceof THREE.HemisphereLight ) {

				data.color = object.color.getHex();
				data.groundColor = object.groundColor.getHex();

			} else if ( object instanceof THREE.Mesh ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Line ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Sprite ) {

				data.material = parseMaterial( object.material );

			}

			data.matrix = object.matrix.toArray();

			if ( object.children.length > 0 ) {

				data.children = [];

				for ( var i = 0; i < object.children.length; i ++ ) {

					data.children.push( parseObject( object.children[ i ] ) );

				}

			}

			return data;

		}

		output.object = parseObject( this );

		return output;

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Projector.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Projector = function () {

	console.warn( 'THREE.Projector has been moved to /examples/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() has been removed.' );

	};

};

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );

		face.materialIndex = this.materialIndex;

		for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

			face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

			face.vertexColors[ i ] = this.vertexColors[ i ].clone();

		}

		for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

			face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		}

		return face;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.array = array;
	this.itemSize = itemSize;

	this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length () {

		return this.array.length;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

	},

	set: function ( value ) {

		this.array.set( value );

		return this;

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

	}

};

//

THREE.Int8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );


};

THREE.Int16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Int32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float64Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.attributes = {};
	this.attributesKeys = [];

	this.drawcalls = [];
	this.offsets = this.drawcalls; // backwards compatibility

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

			return;

		}

		this.attributes[ name ] = attribute;
		this.attributesKeys = Object.keys( this.attributes );

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	addDrawCall: function ( start, count, indexOffset ) {

		this.drawcalls.push( {

			start: start,
			count: count,
			index: indexOffset !== undefined ? indexOffset : 0

		} );

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

	},

	center: function () {

		// TODO

	},

	fromGeometry: function ( geometry, settings ) {

		settings = settings || { 'vertexColors': THREE.NoColors };

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var faceVertexUvs = geometry.faceVertexUvs;
		var vertexColors = settings.vertexColors;
		var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

		var positions = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		var normals = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		if ( vertexColors !== THREE.NoColors ) {

			var colors = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		}

		if ( hasFaceVertexUv === true ) {

			var uvs = new Float32Array( faces.length * 3 * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

			var face = faces[ i ];

			var a = vertices[ face.a ];
			var b = vertices[ face.b ];
			var c = vertices[ face.c ];

			positions[ i3     ] = a.x;
			positions[ i3 + 1 ] = a.y;
			positions[ i3 + 2 ] = a.z;

			positions[ i3 + 3 ] = b.x;
			positions[ i3 + 4 ] = b.y;
			positions[ i3 + 5 ] = b.z;

			positions[ i3 + 6 ] = c.x;
			positions[ i3 + 7 ] = c.y;
			positions[ i3 + 8 ] = c.z;

			if ( hasFaceVertexNormals === true ) {

				var na = face.vertexNormals[ 0 ];
				var nb = face.vertexNormals[ 1 ];
				var nc = face.vertexNormals[ 2 ];

				normals[ i3     ] = na.x;
				normals[ i3 + 1 ] = na.y;
				normals[ i3 + 2 ] = na.z;

				normals[ i3 + 3 ] = nb.x;
				normals[ i3 + 4 ] = nb.y;
				normals[ i3 + 5 ] = nb.z;

				normals[ i3 + 6 ] = nc.x;
				normals[ i3 + 7 ] = nc.y;
				normals[ i3 + 8 ] = nc.z;

			} else {

				var n = face.normal;

				normals[ i3     ] = n.x;
				normals[ i3 + 1 ] = n.y;
				normals[ i3 + 2 ] = n.z;

				normals[ i3 + 3 ] = n.x;
				normals[ i3 + 4 ] = n.y;
				normals[ i3 + 5 ] = n.z;

				normals[ i3 + 6 ] = n.x;
				normals[ i3 + 7 ] = n.y;
				normals[ i3 + 8 ] = n.z;

			}

			if ( vertexColors === THREE.FaceColors ) {

				var fc = face.color;

				colors[ i3     ] = fc.r;
				colors[ i3 + 1 ] = fc.g;
				colors[ i3 + 2 ] = fc.b;

				colors[ i3 + 3 ] = fc.r;
				colors[ i3 + 4 ] = fc.g;
				colors[ i3 + 5 ] = fc.b;

				colors[ i3 + 6 ] = fc.r;
				colors[ i3 + 7 ] = fc.g;
				colors[ i3 + 8 ] = fc.b;

			} else if ( vertexColors === THREE.VertexColors ) {

				var vca = face.vertexColors[ 0 ];
				var vcb = face.vertexColors[ 1 ];
				var vcc = face.vertexColors[ 2 ];

				colors[ i3     ] = vca.r;
				colors[ i3 + 1 ] = vca.g;
				colors[ i3 + 2 ] = vca.b;

				colors[ i3 + 3 ] = vcb.r;
				colors[ i3 + 4 ] = vcb.g;
				colors[ i3 + 5 ] = vcb.b;

				colors[ i3 + 6 ] = vcc.r;
				colors[ i3 + 7 ] = vcc.g;
				colors[ i3 + 8 ] = vcc.b;

			}

			if ( hasFaceVertexUv === true ) {

				var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
				var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
				var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

				uvs[ i2     ] = uva.x;
				uvs[ i2 + 1 ] = uva.y;

				uvs[ i2 + 2 ] = uvb.x;
				uvs[ i2 + 3 ] = uvb.y;

				uvs[ i2 + 4 ] = uvc.x;
				uvs[ i2 + 5 ] = uvc.y;

			}

		}

		this.computeBoundingSphere()

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

			}

		}

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

				}

			}

		}

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( attributes.index ) {

				var indices = attributes.index.array;

				var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

				for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = ( index + indices[ i     ] ) * 3;
						vB = ( index + indices[ i + 1 ] ) * 3;
						vC = ( index + indices[ i + 2 ] ) * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA     ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB     ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC     ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i     ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes.index === undefined ||
			 this.attributes.position === undefined ||
			 this.attributes.normal === undefined ||
			 this.attributes.uv === undefined ) {

			console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
			return;

		}

		var indices = this.attributes.index.array;
		var positions = this.attributes.position.array;
		var normals = this.attributes.normal.array;
		var uvs = this.attributes.uv.array;

		var nVertices = positions.length / 3;

		if ( this.attributes.tangent === undefined ) {

			this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		var tangents = this.attributes.tangent.array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var vA = new THREE.Vector3(),
			vB = new THREE.Vector3(),
			vC = new THREE.Vector3(),

			uvA = new THREE.Vector2(),
			uvB = new THREE.Vector2(),
			uvC = new THREE.Vector2(),

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;

			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;

			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;

			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		if ( this.drawcalls.length === 0 ) {

			this.addDrawCall( 0, indices.length, 0 );

		}

		var drawcalls = this.drawcalls;

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4     ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

	},

	/*
		computeOffsets
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
	*/
	computeOffsets: function ( indexBufferSize ) {

		var size = indexBufferSize;
		if ( indexBufferSize === undefined )
			size = 65535; //WebGL limits type of index buffer values to 16-bit.

		var s = Date.now();

		var indices = this.attributes.index.array;
		var vertices = this.attributes.position.array;

		var verticesCount = ( vertices.length / 3 );
		var facesCount = ( indices.length / 3 );

		/*
		console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
		console.log("Faces to process: "+(indices.length/3));
		console.log("Reordering "+verticesCount+" vertices.");
		*/

		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
		var indexPtr = 0;
		var vertexPtr = 0;

		var offsets = [ { start:0, count:0, index:0 } ];
		var offset = offsets[ 0 ];

		var duplicatedVertices = 0;
		var newVerticeMaps = 0;
		var faceVertices = new Int32Array( 6 );
		var vertexMap = new Int32Array( vertices.length );
		var revVertexMap = new Int32Array( vertices.length );
		for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

		/*
			Traverse every face and reorder vertices in the proper offsets of 65k.
			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
		*/
		for ( var findex = 0; findex < facesCount; findex ++ ) {
			newVerticeMaps = 0;

			for ( var vo = 0; vo < 3; vo ++ ) {
				var vid = indices[ findex * 3 + vo ];
				if ( vertexMap[ vid ] == - 1 ) {
					//Unmapped vertice
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					newVerticeMaps ++;
				} else if ( vertexMap[ vid ] < offset.index ) {
					//Reused vertices from previous block (duplicate)
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					duplicatedVertices ++;
				} else {
					//Reused vertice in the current block
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
				}
			}

			var faceMax = vertexPtr + newVerticeMaps;
			if ( faceMax > ( offset.index + size ) ) {
				var new_offset = { start:indexPtr, count:0, index:vertexPtr };
				offsets.push( new_offset );
				offset = new_offset;

				//Re-evaluate reused vertices in light of new offset.
				for ( var v = 0; v < 6; v += 2 ) {
					var new_vid = faceVertices[ v + 1 ];
					if ( new_vid > - 1 && new_vid < offset.index )
						faceVertices[ v + 1 ] = - 1;
				}
			}

			//Reindex the face.
			for ( var v = 0; v < 6; v += 2 ) {
				var vid = faceVertices[ v ];
				var new_vid = faceVertices[ v + 1 ];

				if ( new_vid === - 1 )
					new_vid = vertexPtr ++;

				vertexMap[ vid ] = new_vid;
				revVertexMap[ new_vid ] = vid;
				sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
				offset.count ++;
			}
		}

		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
		this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
		this.offsets = offsets;

		/*
		var orderTime = Date.now();
		console.log("Reorder time: "+(orderTime-s)+"ms");
		console.log("Duplicated "+duplicatedVertices+" vertices.");
		console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
		console.log("Draw offsets: "+offsets.length);
		*/

		return offsets;
	},

	merge: function () {

		console.log( 'BufferGeometry.merge(): TODO' );

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i     ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	/*
		reoderBuffers:
		Reorder attributes based on a new indexBuffer and indexMap.
		indexBuffer - Uint16Array of the new ordered indices.
		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
	*/
	reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

		/* Create a copy of all attributes for reordering. */
		var sortedAttributes = {};
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			var sourceArray = this.attributes[ attr ].array;
			sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
		}

		/* Move attribute positions based on the new index map */
		for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
			var vid = indexMap[ new_vid ];
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var attrArray = this.attributes[ attr ].array;
				var attrSize = this.attributes[ attr ].itemSize;
				var sortedAttr = sortedAttributes[ attr ];
				for ( var k = 0; k < attrSize; k ++ )
					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
			}
		}

		/* Carry the new sorted buffers locally */
		this.attributes[ 'index' ].array = indexBuffer;
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			this.attributes[ attr ].array = sortedAttributes[ attr ];
			this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
		}
	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type,
			data: {
				attributes: {}
			}
		};

		var attributes = this.attributes;
		var offsets = this.offsets;
		var boundingSphere = this.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = [], typeArray = attribute.array;

			for ( var i = 0, l = typeArray.length; i < l; i ++ ) {

				array[ i ] = typeArray[ i ];

			}

			output.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			}

		}

		if ( offsets.length > 0 ) {

			output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== null ) {

			output.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			}

		}

		return output;

	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			geometry.addAttribute( attr, sourceAttr.clone() );

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in Points and Line

	this.faces = [];

	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var indices = attributes.index !== undefined ? attributes.index.array : undefined;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

		var tempNormals = [];
		var tempUVs = [];

		for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

		}

		var addFace = function ( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );
			scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ], tempUVs[ b ], tempUVs[ c ] ] );

		};

		if ( indices !== undefined ) {

			for ( var i = 0; i < indices.length; i += 3 ) {

				addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}
		
		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = new THREE.Vector3();

		offset.addVectors( this.boundingBox.min, this.boundingBox.max );
		offset.multiplyScalar( - 0.5 );

		this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		this.computeBoundingBox();

		return offset;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

			}

			return output;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );


			/*
			if ( hasMaterial ) {

				faces.push( face.materialIndex );

			}
			*/

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		output.data = {};

		output.data.vertices = vertices;
		output.data.normals = normals;
		if ( colors.length > 0 ) output.data.colors = colors;
		if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
		output.data.faces = faces;

		//

		return output;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	}

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function ( camera ) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';
	
	this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'AreaLight';

	this.normal = new THREE.Vector3( 0, - 1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = - 500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = - 500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;

	light.shadowCameraLeft = this.shadowCameraLeft;
	light.shadowCameraRight = this.shadowCameraRight;
	light.shadowCameraTop = this.shadowCameraTop;
	light.shadowCameraBottom = this.shadowCameraBottom;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	//

	light.shadowCascade = this.shadowCascade;

	light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
	light.shadowCascadeCount = this.shadowCascadeCount;

	light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
	light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
	light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

	light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
	light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

	return light;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;
	light.shadowCameraFov = this.shadowCameraFov;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	return light;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = function () {

	this.files = {};

};

THREE.Cache.prototype = {

	constructor: THREE.Cache,

	add: function ( key, file ) {

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {}

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.imageLoader = new THREE.ImageLoader();

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( 'div' );

		e.style.position = 'absolute';
		e.style.right = '0px';
		e.style.top = '0px';
		e.style.fontSize = '0.8em';
		e.style.textAlign = 'left';
		e.style.background = 'rgba(0,0,0,0.25)';
		e.style.color = '#fff';
		e.style.width = '120px';
		e.style.padding = '0.5em 0.5em 0.5em 0.5em';
		e.style.zIndex = 1000;

		e.innerHTML = 'Loading ...';

		return e;

	},

	updateProgress: function ( progress ) {

		var message = 'Loaded ';

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


		} else {

			message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for ( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var scope = this;

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var fullPath = texturePath + sourceFile;

			var texture;

			var loader = THREE.Loader.Handlers.get( fullPath );

			if ( loader !== null ) {

				texture = loader.load( fullPath );

			} else {

				texture = new THREE.Texture();

				loader = scope.imageLoader;
				loader.crossOrigin = scope.crossOrigin;
				loader.load( fullPath, function ( image ) {

					if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
						 THREE.Math.isPowerOfTwo( image.height ) === false ) {

						var width = nearest_pow2( image.width );
						var height = nearest_pow2( image.height );

						var canvas = document.createElement( 'canvas' );
						canvas.width = width;
						canvas.height = height;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, 0, 0, width, height );

						texture.image = canvas;

					} else {

						texture.image = image;

					}

					texture.needsUpdate = true;

				} );

			}

			texture.sourceFile = sourceFile;

			if ( repeat ) {

				texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				texture.offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					'repeat': THREE.RepeatWrapping,
					'mirror': THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				texture.anisotropy = anisotropy;

			}

			where[ name ] = texture;

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = 'MeshLambertMaterial';
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
			else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === 'face' ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		if ( m.colorEmissive ) {

			mpars.emissive = rgb2hex( m.colorEmissive );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		if ( m.mapAlpha && texturePath ) {

			create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ 'normalmap' ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ 'tNormal' ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ 'uNormalScale' ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ 'tDiffuse' ].value = mpars.map;
				uniforms[ 'enableDiffuse' ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ 'tSpecular' ].value = mpars.specularMap;
				uniforms[ 'enableSpecular' ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ 'tAO' ].value = mpars.lightMap;
				uniforms[ 'enableAO' ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ 'diffuse' ].value.setHex( mpars.color );
			uniforms[ 'specular' ].value.setHex( mpars.specular );
			uniforms[ 'ambient' ].value.setHex( mpars.ambient );

			uniforms[ 'shininess' ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ 'opacity' ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

			var regex = this.handlers[ i ];
			var loader  = this.handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) onLoad( cached );
			return;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			scope.cache.add( url, this.response );

			if ( onLoad ) onLoad( this.response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;

		request.send( null );

		scope.manager.itemStart( url );

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			onLoad( cached );
			return;

		}

		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.cache.add( url, this );

				onLoad( this );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
						return;

					}

					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( 'Content-Length' );

			}

		}

	};

	xhr.open( 'GET', url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i ++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i ++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	     = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i ++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i ++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {
		var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

		if ( json.skinWeights ) {

			for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

				var x =                               json.skinWeights[ i     ];
				var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
				var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
				var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

				var a =                               json.skinIndices[ i     ];
				var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
				var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
				var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;

		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

		}


		// could change this to json.animations[0] or remove completely

		geometry.animation = json.animation;
		geometry.animations = json.animations;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined || json.materials.length === 0 ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var offsets = json.offsets;

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		var boundingSphere = json.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;		
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Line':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Line( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Sprite( material );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader();
		loader.setResponseType( 'arraybuffer' );

		if ( url instanceof Array ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

 						if (texDatas.mipmapCount == 1)
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				} );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			} );

		}

		return texture;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw' ) {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this instanceof THREE.MeshBasicMaterial ) {

			output.color = this.color.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshLambertMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshPhongMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			output.specular = this.specular.getHex();
			output.shininess = this.shininess;
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshNormalMaterial ) {

			if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshDepthMaterial ) {

			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.ShaderMaterial ) {

			output.uniforms = this.uniforms;
			output.vertexShader = this.vertexShader;
			output.fragmentShader = this.fragmentShader;

		} else if ( this instanceof THREE.SpriteMaterial ) {

			output.color = this.color.getHex();

		}

		if ( this.opacity < 1 ) output.opacity = this.opacity;
		if ( this.transparent !== false ) output.transparent = this.transparent;
		if ( this.wireframe !== false ) output.wireframe = this.wireframe;

		return output;

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MeshFaceMaterial';
	
	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype = {

	constructor: THREE.MeshFaceMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		return output;

	},

	clone: function () {

		var material = new THREE.MeshFaceMaterial();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		return material;

	}

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointCloudMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.PointCloudMaterial.prototype.clone = function () {

	var material = new THREE.PointCloudMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};
	this.attributes = null;

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

THREE.RawShaderMaterial.prototype.clone = function () {

	var material = new THREE.RawShaderMaterial();

	THREE.ShaderMaterial.prototype.clone.call( this, material );

	return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping();

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice( 0 );

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CubeTexture.clone = function ( texture ) {

	if ( texture === undefined ) texture = new THREE.CubeTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	texture.images = this.images;

	return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	var update = function () {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	};

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'PointCloud';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );

THREE.PointCloud.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function ( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.PointCloud.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var position = new THREE.Vector3();

		var testPoint = function ( point, index ) {

			var rayPointDistance = ray.distanceToPoint( point );

			if ( rayPointDistance < localThreshold ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				intersects.push( {

					distance: distance,
					distanceToRay: rayPointDistance,
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		};

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					var offset = {
						start: 0,
						count: indices.length,
						index: 0
					};

					offsets = [ offset ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i ++ ) {

						var a = index + indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				}

			} else {

				var pointCount = positions.length / 3;

				for ( var i = 0; i < pointCount; i ++ ) {

					position.set(
						positions[ 3 * i ],
						positions[ 3 * i + 1 ],
						positions[ 3 * i + 2 ]
					);

					testPoint( position, i );

				}

			}

		} else {

			var vertices = this.geometry.vertices;

			for ( var i = 0; i < vertices.length; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
	return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function ( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		/* if ( geometry instanceof THREE.BufferGeometry ) {

		} else */ if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this.mode === THREE.LineStrip ? 1 : 2;

			for ( var i = 0; i < nbVertices - 1; i = i + step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				var distance = ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';
	
	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		var geometry = this.geometry;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		// Check boundingBox before continuing

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {

				return;

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var material = this.material;

			if ( material === undefined ) return;

			var attributes = geometry.attributes;

			var a, b, c;
			var precision = raycaster.precision;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var positions = attributes.position.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					offsets = [ { start: 0, count: indices.length, index: 0 } ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						a = index + indices[ i ];
						b = index + indices[ i + 1 ];
						c = index + indices[ i + 2 ];

						vA.fromArray( positions, a * 3 );
						vB.fromArray( positions, b * 3 );
						vC.fromArray( positions, c * 3 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

					a = i;
					b = i + 1;
					c = i + 2;

					vA.fromArray( positions, j );
					vB.fromArray( positions, j + 3 );
					vC.fromArray( positions, j + 6 );

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
			var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

			var a, b, c, d;
			var precision = raycaster.precision;

			var vertices = geometry.vertices;

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];

				var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

				if ( material === undefined ) continue;

				a = vertices[ face.a ];
				b = vertices[ face.b ];
				c = vertices[ face.c ];

				if ( material.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.x += ( targets[ face.a ].x - a.x ) * influence;
						vA.y += ( targets[ face.a ].y - a.y ) * influence;
						vA.z += ( targets[ face.a ].z - a.z ) * influence;

						vB.x += ( targets[ face.b ].x - b.x ) * influence;
						vB.y += ( targets[ face.b ].y - b.y ) * influence;
						vB.z += ( targets[ face.b ].z - b.z ) * influence;

						vC.x += ( targets[ face.c ].x - c.x ) * influence;
						vC.y += ( targets[ face.c ].y - c.y ) * influence;
						vC.z += ( targets[ face.c ].z - c.z ) * influence;

					}

					vA.add( a );
					vB.add( b );
					vC.add( c );

					a = vA;
					b = vB;
					c = vC;

				}

				if ( material.side === THREE.BackSide ) {

					var intersectionPoint = ray.intersectTriangle( c, b, a, true );

				} else {

					var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

				}

				if ( intersectionPoint === null ) continue;

				intersectionPoint.applyMatrix4( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

				if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					point: intersectionPoint,
					face: face,
					faceIndex: f,
					object: this

				} );

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object, recursive );

	return object;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );


// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
		//       16x16 pixel texture max   64 bones (16 * 16 / 4)
		//       32x32 pixel texture max  256 bones (32 * 32 / 4)
		//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

		var size;

		if ( this.bones.length > 256 )
			size = 64;
		else if ( this.bones.length > 64 )
			size = 32;
		else if ( this.bones.length > 16 )
			size = 16;
		else
			size = 8;

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
		this.boneTexture.minFilter = THREE.NearestFilter;
		this.boneTexture.magFilter = THREE.NearestFilter;
		this.boneTexture.generateMipmaps = false;
		this.boneTexture.flipY = false;

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();
	
	return function () {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}
		
	};

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone, p, q, s;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
			bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

			if ( s !== undefined ) {

				bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};


// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'MorphAnimMesh';

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = - 1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)_?(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( 'animation[' + label + '] undefined' );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= - 1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

	var influences = this.morphTargetInfluences;

	for ( var i = 0, l = influences.length; i < l; i ++ ) {

		influences[ i ] = 0;

	}

	if ( a > -1 ) influences[ a ] = 1 - t;
	if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.LOD();

	THREE.Object3D.prototype.clone.call( this, object );

	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
		var x = this.objects[ i ].object.clone();
		x.visible = i === 0;
		object.addLevel( x, this.objects[ i ].distance );
	}

	return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function ( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.distanceToPoint( matrixPosition );

		if ( distance > this.scale.x ) {

			return;

		}

		intersects.push( {

			distance: distance,
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture, 			// THREE.Texture
		size: size, 				// size in pixels (-1 = use texture.width)
		distance: distance, 		// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		scale: 1, 					// scale
		rotation: 1, 				// rotation
		opacity: opacity,			// opacity
		color: color,				// color
		blending: blending			// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call( this, object );

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

			"		if ( gl_FrontFacing )",
			"			gl_FragColor.xyz *= vLightFront;",
			"		else",
			"			gl_FragColor.xyz *= vLightBack;",

			"	#else",

			"		gl_FragColor.xyz *= vLightFront;",

			"	#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"          : { type: "i", value: 0 },
			"enableDiffuse"     : { type: "i", value: 0 },
			"enableSpecular"    : { type: "i", value: 0 },
			"enableReflection"  : { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"     : { type: "t", value: null },
			"tCube"        : { type: "t", value: null },
			"tNormal"      : { type: "t", value: null },
			"tSpecular"    : { type: "t", value: null },
			"tAO"          : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
			"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
			"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
			"shininess": { type: "f", value: 30 },
			"opacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"refractionRatio": { type: "f", value: 0.98 },
			"reflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB" : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float refractionRatio;",
			"uniform float reflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

			"	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

			"	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

			"	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

			"	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

			"	uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",
				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

			"	vec3 specularTex = vec3( 1.0 );",

			"	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
			"	normalTex.xy *= uNormalScale;",
			"	normalTex = normalize( normalTex );",

			"	if( enableDiffuse ) {",

			"		#ifdef GAMMA_INPUT",

			"			vec4 texelColor = texture2D( tDiffuse, vUv );",
			"			texelColor.xyz *= texelColor.xyz;",

			"			gl_FragColor = gl_FragColor * texelColor;",

			"		#else",

			"			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

			"		#endif",

			"	}",

			"	if( enableAO ) {",

			"		#ifdef GAMMA_INPUT",

			"			vec4 aoColor = texture2D( tAO, vUv );",
			"			aoColor.xyz *= aoColor.xyz;",

			"			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

			"		#else",

			"			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

			"		#endif",

			"	}",
			
			THREE.ShaderChunk[ "alphatest_fragment" ],

			"	if( enableSpecular )",
			"		specularTex = texture2D( tSpecular, vUv ).xyz;",

			"	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
			"	vec3 finalNormal = tsb * normalTex;",

			"	#ifdef FLIP_SIDED",

			"		finalNormal = -finalNormal;",

			"	#endif",

			"	vec3 normal = normalize( finalNormal );",
			"	vec3 viewPosition = normalize( vViewPosition );",

				// point lights

			"	#if MAX_POINT_LIGHTS > 0",

			"		vec3 pointDiffuse = vec3( 0.0 );",
			"		vec3 pointSpecular = vec3( 0.0 );",

			"		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

			"			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
			"			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

			"			float pointDistance = 1.0;",
			"			if ( pointLightDistance[ i ] > 0.0 )",
			"				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

			"			pointVector = normalize( pointVector );",

						// diffuse

			"			#ifdef WRAP_AROUND",

			"				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
			"				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

			"				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

			"			#else",

			"				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

			"			#endif",

			"			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

						// specular

			"			vec3 pointHalfVector = normalize( pointVector + viewPosition );",
			"			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
			"			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );",
			"			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

			"		}",

			"	#endif",

				// spot lights

			"	#if MAX_SPOT_LIGHTS > 0",

			"		vec3 spotDiffuse = vec3( 0.0 );",
			"		vec3 spotSpecular = vec3( 0.0 );",

			"		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

			"			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
			"			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

			"			float spotDistance = 1.0;",
			"			if ( spotLightDistance[ i ] > 0.0 )",
			"				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

			"			spotVector = normalize( spotVector );",

			"			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

			"			if ( spotEffect > spotLightAngleCos[ i ] ) {",

			"				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );",

							// diffuse

			"				#ifdef WRAP_AROUND",

			"					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
			"					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

			"					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

			"				#else",

			"					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

			"				#endif",

			"				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

							// specular

			"				vec3 spotHalfVector = normalize( spotVector + viewPosition );",
			"				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
			"				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

			"				float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );",
			"				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

			"			}",

			"		}",

			"	#endif",

				// directional lights

			"	#if MAX_DIR_LIGHTS > 0",

			"		vec3 dirDiffuse = vec3( 0.0 );",
			"		vec3 dirSpecular = vec3( 0.0 );",

			"		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

			"			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"			vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

			"			#ifdef WRAP_AROUND",

			"				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
			"				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

			"				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

			"			#else",

			"				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

			"			#endif",

			"			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

						// specular

			"			vec3 dirHalfVector = normalize( dirVector + viewPosition );",
			"			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
			"			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
			"			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

			"		}",

			"	#endif",

				// hemisphere lights

			"	#if MAX_HEMI_LIGHTS > 0",

			"		vec3 hemiDiffuse = vec3( 0.0 );",
			"		vec3 hemiSpecular = vec3( 0.0 );" ,

			"		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

			"			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
			"			vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

			"			float dotProduct = dot( normal, lVector );",
			"			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

			"			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

			"			hemiDiffuse += diffuse * hemiColor;",

						// specular (sky light)


			"			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
			"			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
			"			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );",

						// specular (ground light)

			"			vec3 lVectorGround = -lVector;",

			"			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
			"			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
			"			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );",

			"			float dotProductGround = dot( normal, lVectorGround );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
			"			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
			"			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"		}",

			"	#endif",

				// all lights contribution summation

			"	vec3 totalDiffuse = vec3( 0.0 );",
			"	vec3 totalSpecular = vec3( 0.0 );",

			"	#if MAX_DIR_LIGHTS > 0",

			"		totalDiffuse += dirDiffuse;",
			"		totalSpecular += dirSpecular;",

			"	#endif",

			"	#if MAX_HEMI_LIGHTS > 0",

			"		totalDiffuse += hemiDiffuse;",
			"		totalSpecular += hemiSpecular;",

			"	#endif",

			"	#if MAX_POINT_LIGHTS > 0",

			"		totalDiffuse += pointDiffuse;",
			"		totalSpecular += pointSpecular;",

			"	#endif",

			"	#if MAX_SPOT_LIGHTS > 0",

			"		totalDiffuse += spotDiffuse;",
			"		totalSpecular += spotSpecular;",

			"	#endif",

			"	#ifdef METAL",

			"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

			"	#else",

			"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

			"	#endif",

			"	if ( enableReflection ) {",

			"		vec3 vReflect;",
			"		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

			"		if ( useRefract ) {",

			"			vReflect = refract( cameraToVertex, normal, refractionRatio );",

			"		} else {",

			"			vReflect = reflect( cameraToVertex, normal );",

			"		}",

			"		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

			"		#ifdef GAMMA_INPUT",

			"			cubeColor.xyz *= cubeColor.xyz;",

			"		#endif",

			"		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

			"	}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

			"	uniform sampler2D tDisplacement;",
			"	uniform float uDisplacementScale;",
			"	uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

			"	#ifdef USE_SKINNING",

			"		vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

			"		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
			"		vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

			"	#else",

			"		vNormal = normalize( normalMatrix * normal );",
			"		vTangent = normalize( normalMatrix * tangent.xyz );",

			"	#endif",

			"	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

			"	vUv = uv * uRepeat + uOffset;",

				// displacement mapping

			"	vec3 displacedPosition;",

			"	#ifdef VERTEX_TEXTURES",

			"		if ( enableDisplacement ) {",

			"			vec3 dv = texture2D( tDisplacement, uv ).xyz;",
			"			float df = uDisplacementScale * dv.x + uDisplacementBias;",
			"			displacedPosition = position + normalize( normal ) * df;",

			"		} else {",

			"			#ifdef USE_SKINNING",

			"				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

			"				vec4 skinned = vec4( 0.0 );",
			"				skinned += boneMatX * skinVertex * skinWeight.x;",
			"				skinned += boneMatY * skinVertex * skinWeight.y;",
			"				skinned += boneMatZ * skinVertex * skinWeight.z;",
			"				skinned += boneMatW * skinVertex * skinWeight.w;",
			"				skinned  = bindMatrixInverse * skinned;",

			"				displacedPosition = skinned.xyz;",

			"			#else",

			"				displacedPosition = position;",

			"			#endif",

			"		}",

			"	#else",

			"		#ifdef USE_SKINNING",

			"			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

			"			vec4 skinned = vec4( 0.0 );",
			"			skinned += boneMatX * skinVertex * skinWeight.x;",
			"			skinned += boneMatY * skinVertex * skinWeight.y;",
			"			skinned += boneMatZ * skinVertex * skinWeight.z;",
			"			skinned += boneMatW * skinVertex * skinWeight.w;",
			"			skinned  = bindMatrixInverse * skinned;",

			"			displacedPosition = skinned.xyz;",

			"		#else",

			"			displacedPosition = position;",

			"		#endif",

			"	#endif",

				//

			"	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
			"	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				//

			"	vWorldPosition = worldPosition.xyz;",
			"	vViewPosition = -mvPosition.xyz;",

				// shadows

			"	#ifdef USE_SHADOWMAP",

			"		for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

			"			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"		}",

			"	#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			"	vWorldPosition = worldPosition.xyz;",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var _webglObjects = {};
	var _webglObjectsImmediate = [];

	var opaqueObjects = [];
	var transparentObjects = [];

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				 ? parameters.devicePixelRatio
				 : self.devicePixelRatio !== undefined
					 ? self.devicePixelRatio
					 : 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryGroupHash = - 1,
	_currentCamera = null,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = - 1,
	_oldFlipSided = - 1,

	_oldBlending = - 1,

	_oldBlendEquation = - 1,
	_oldBlendSrc = - 1,
	_oldBlendDst = - 1,

	_oldDepthTest = - 1,
	_oldDepthWrite = - 1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_newAttributes = new Uint8Array( 16 ),
	_enabledAttributes = new Uint8Array( 16 ),

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors:[], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	};

	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl') !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

	} catch ( error ) {

		console.error( error );

	}

	if ( _gl.getShaderPrecisionFormat === undefined ) {

		_gl.getShaderPrecisionFormat = function () {

			return {
				'rangeMin': 1,
				'rangeMax': 1,
				'precision': 1
			};

		}

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_standard_derivatives' );

	if ( _logarithmicDepthBuffer ) {

		extensions.get( 'EXT_frag_depth' );

	}

	//

	function setDefaultGLState() {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _supportsVertexTextures = _maxVertexTextures > 0;
	var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var getCompressedTextureFormats = ( function () {

		var array;

		return function () {

			if ( array !== undefined ) {

				return array;

			}

			array = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ){

					array.push( formats[ i ] );

				}

			}
			
			return array;

		};

	} )();

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === 'highp' && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = 'mediump';
			console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

		} else {

			_precision = 'lowp';
			console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

		}

	}

	if ( _precision === 'mediump' && ! mediumpAvailable ) {

		_precision = 'lowp';
		console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

	}

	// Plugins

	var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return extensions.get( 'OES_texture_float' );

	};

	this.supportsStandardDerivatives = function () {

		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		return extensions.get( 'EXT_blend_minmax' );

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function () {

			if ( value !== undefined ) {

				return value;

			}

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

			return value;

		}

	} )();

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * this.devicePixelRatio;
		_viewportY = y * this.devicePixelRatio;

		_viewportWidth = width * this.devicePixelRatio;
		_viewportHeight = height * this.devicePixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * this.devicePixelRatio,
			y * this.devicePixelRatio,
			width * this.devicePixelRatio,
			height * this.devicePixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = function () {

		_currentProgram = null;
		_currentCamera = null;

		_oldBlending = - 1;
		_oldDepthTest = - 1;
		_oldDepthWrite = - 1;
		_oldDoubleSided = - 1;
		_oldFlipSided = - 1;
		_currentGeometryGroupHash = - 1;
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

	};

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onObjectRemoved = function ( event ) {

		var object = event.target;

		object.traverse( function ( child ) {

			child.removeEventListener( 'remove', onObjectRemoved );

			removeObject( child );

		} );

	};

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {
	
		var buffers = [
			'__webglVertexBuffer',
			'__webglNormalBuffer',
			'__webglTangentBuffer',
			'__webglColorBuffer',
			'__webglUVBuffer',
			'__webglUV2Buffer',
			
			'__webglSkinIndicesBuffer',
			'__webglSkinWeightsBuffer',
			
			'__webglFaceBuffer',
			'__webglLineBuffer',
			
			'__webglLineDistanceBuffer'
		];

		for ( var i = 0, l = buffers.length; i < l; i ++ ) {

			var name = buffers[ i ];

			if ( geometry[ name ] !== undefined ) {

				_gl.deleteBuffer( geometry[ name ] );

				delete geometry[ name ];

			}

		}

		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var name in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

			}

			delete geometry.__webglCustomAttributesList;

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		delete geometry.__webglInit;

		if ( geometry instanceof THREE.BufferGeometry ) {

			for ( var name in geometry.attributes ) {
			
				var attribute = geometry.attributes[ name ];

				if ( attribute.buffer !== undefined ) {

					_gl.deleteBuffer( attribute.buffer );

					delete attribute.buffer;

				}

			}

			_this.info.memory.geometries --;

		} else {

			var geometryGroupsList = geometryGroups[ geometry.id ];

			if ( geometryGroupsList !== undefined ) {

				for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphTargetsBuffers;

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphNormalsBuffers;

					}

					deleteBuffers( geometryGroup );

				}

				delete geometryGroups[ geometry.id ];

			} else {

				deleteBuffers( geometry );

			}

		}

		// TOFIX: Workaround for deleted geometry being currently bound

		_currentGeometryGroupHash = - 1;

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

			delete texture.image.__webglTextureCube;

		} else {

			// 2D texture

			if ( texture.__webglInit === undefined ) return;

			_gl.deleteTexture( texture.__webglTexture );

			delete texture.__webglTexture;
			delete texture.__webglInit;

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		delete renderTarget.__webglTexture;

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

		delete renderTarget.__webglFramebuffer;
		delete renderTarget.__webglRenderbuffer;

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( object ) {

		var geometry = object.geometry;
		var material = object.material;

		var nvertices = geometry.vertices.length;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				var attribute = material.attributes[ name ];

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes( object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes( object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
		geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
		geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
		geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

		if ( geometry.faceVertexUvs.length > 1 ) {

			geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

		geometryGroup.__typeArray = UintArray;
		geometryGroup.__faceArray = new UintArray( ntris * 3 );
		geometryGroup.__lineArray = new UintArray( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ name ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			 ? object.material.materials[ geometryGroup.materialIndex ]
			 : object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[ v ][ 1 ] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[ c ][ 1 ] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
							 customAttribute.boundTo === 'vertices' ) ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
						 customAttribute.boundTo === 'vertices' ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]    = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var needsSmoothNormals = materialNeedsSmoothNormals( material );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ]     = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ]     = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ]   = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === 'c' ) {

						pp = [ 'r', 'g', 'b' ];

					} else {

						pp = [ 'x', 'y', 'z' ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	function setDirectBuffers( geometry ) {

		var attributes = geometry.attributes;
		var attributesKeys = geometry.attributesKeys;

		for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

			var key = attributesKeys[ i ];
			var attribute = attributes[ key ];

			if ( attribute.buffer === undefined ) {

				attribute.buffer = _gl.createBuffer();
				attribute.needsUpdate = true;

			}

			if ( attribute.needsUpdate === true ) {

				var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

				_gl.bindBuffer( bufferType, attribute.buffer );
				_gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

				attribute.needsUpdate = false;

			}

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		initAttributes();

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for ( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ]   = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.attributes;
		var programAttributesKeys = program.attributesKeys;

		for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

			var key = programAttributesKeys[ i ];
			var programAttribute = programAttributes[ key ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ key ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

					enableAttribute( programAttribute );

					_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

				} else if ( material.defaultAttributeValues !== undefined ) {

					if ( material.defaultAttributeValues[ key ].length === 2 ) {

						_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

					} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

						_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed triangles

				var type, size;

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 );

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
					_this.info.render.faces += index.array.length / 3;

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed triangles

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
						_this.info.render.faces += offsets[ i ].count / 3;

					}

				}

			} else {

				// non-indexed triangles

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes[ 'position' ];

				// render non-indexed triangles

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.array.length / 3;
				_this.info.render.faces += position.array.length / 9;

			}

		} else if ( object instanceof THREE.PointCloud ) {

			// render particles

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry, 0 );

			}

			var position = geometry.attributes.position;

			// render particles

			_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.array.length / 3;

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed lines

				var type, size;

				if ( index.array instanceof Uint32Array ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					if ( offsets.length > 1 ) updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed lines

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

					}

				}

			} else {

				// non-indexed lines

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes.position;

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.array.length / 3;

			}

		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// vertices

		if ( ! material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					var attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 0 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 1 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		disableUnusedAttributes();

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );
				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.PointCloud ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function initAttributes() {

		for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

			_newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		_newAttributes[ attribute ] = 1;

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

			if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

				_gl.disableVertexAttribArray( i );
				_enabledAttributes[ i ] = 0;

			}

		}

	}

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ 'morphTarget' + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ 'morphTarget' + m ] );
					_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ 'morphNormal' + m ] );
					_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ 'morphTarget' + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ 'morphTarget' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ 'morphNormal' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	}

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.material.id !== b.material.id ) {

			return b.material.id - a.material.id;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryGroupHash = - 1;
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		// update Skeleton objects

		scene.traverse( function ( object ) {

			if ( object instanceof THREE.SkinnedMesh ) {

				object.skeleton.update();

			}

		} );

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;
		opaqueObjects.length = 0;
		transparentObjects.length = 0;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene, scene );

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		// custom render plugins (pre pass)

		shadowMapPlugin.render( scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for immediate objects

		for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

			var webglObject = _webglObjectsImmediate[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( opaqueObjects, camera, lights, fog, true, material );
			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( opaqueObjects, camera, lights, fog, false, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function projectObject( scene, object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

			// skip

		} else {

			initObject( object, scene );

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					updateObject( object, scene );

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[i];

						unrollBufferMaterial( webglObject );

						webglObject.render = true;

						if ( _this.sortObjects === true ) {

							if ( object.renderDepth !== null ) {

								webglObject.z = object.renderDepth;

							} else {

								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );

								webglObject.z = _vector3.z;

							}

						}

					}

				}

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( scene, object.children[ i ] );

		}

	}

	function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = renderList.length - 1; i !== - 1; i -- ) {

			var webglObject = renderList[ i ];

			var object = webglObject.object;
			var buffer = webglObject.buffer;

			setupMatrices( object, camera );

			if ( overrideMaterial ) {

				material = overrideMaterial;

			} else {

				material = webglObject.material;

				if ( ! material ) continue;

				if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

				_this.setDepthTest( material.depthTest );
				_this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			_this.setMaterialFaces( material );

			if ( buffer instanceof THREE.BufferGeometry ) {

				_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

			} else {

				_this.renderBuffer( camera, lights, fog, material, buffer, object );

			}

		}

	}

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			var webglObject = renderList[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = - 1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	}

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		} else if ( material ) {

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		}

	}

	function initObject( object, scene ) {

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;
			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			object.addEventListener( 'removed', onObjectRemoved );

		}

		var geometry = object.geometry;

		if ( geometry === undefined ) {

			// ImmediateRenderObject

		} else if ( geometry.__webglInit === undefined ) {

			geometry.__webglInit = true;
			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry instanceof THREE.BufferGeometry ) {

				//

			} else if ( object instanceof THREE.Mesh ) {

				initGeometryGroups( scene, object, geometry );

			} else if ( object instanceof THREE.Line ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.PointCloud ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined) {

			object.__webglActive = true;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					var geometryGroupsList = geometryGroups[ geometry.id ];

					for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

						addBuffer( _webglObjects, geometryGroupsList[ i ], object );

					}

				}

			} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

				addBuffer( _webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( _webglObjectsImmediate, object );

			}

		}

	}

	// Geometry splitting

	var geometryGroups = {};
	var geometryGroupCounter = 0;

	function makeGroups( geometry, usesFaceMaterial ) {

		var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

		var groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var group;
		var groups = {};
		var groupsList = [];

		for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			var face = geometry.faces[ f ];
			var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( ! ( materialIndex in hash_map ) ) {

				hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( ! ( groupHash in groups ) ) {

				group = {
					id: geometryGroupCounter ++,
					faces3: [],
					materialIndex: materialIndex,
					vertices: 0,
					numMorphTargets: numMorphTargets,
					numMorphNormals: numMorphNormals
				};
				
				groups[ groupHash ] = group;
				groupsList.push( group );

			}

			if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};
					
					groups[ groupHash ] = group;
					groupsList.push( group );

				}

			}

			groups[ groupHash ].faces3.push( f );
			groups[ groupHash ].vertices += 3;

		}

		return groupsList;

	}

	function initGeometryGroups( scene, object, geometry ) {

		var material = object.material, addBuffers = false;

		if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

			delete _webglObjects[ object.id ];

			geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

			geometry.groupsNeedUpdate = false;

		}

		var geometryGroupsList = geometryGroups[ geometry.id ];

		// create separate VBOs per geometry chunk

		for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

			var geometryGroup = geometryGroupsList[ i ];

			// initialise VBO on the first access

			if ( geometryGroup.__webglVertexBuffer === undefined ) {

				createMeshBuffers( geometryGroup );
				initMeshBuffers( geometryGroup, object );

				geometry.verticesNeedUpdate = true;
				geometry.morphTargetsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.tangentsNeedUpdate = true;
				geometry.colorsNeedUpdate = true;

				addBuffers = true;

			} else {

				addBuffers = false;

			}

			if ( addBuffers || object.__webglActive === undefined ) {

				addBuffer( _webglObjects, geometryGroup, object );

			}

		}

		object.__webglActive = true;

	}

	function addBuffer( objlist, buffer, object ) {

		var id = object.id;
		objlist[id] = objlist[id] || [];
		objlist[id].push(
			{
				id: id,
				buffer: buffer,
				object: object,
				material: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object, scene ) {

		var geometry = object.geometry, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			if ( geometry.groupsNeedUpdate === true ) {

				initGeometryGroups( scene, object, geometry );

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.groupsNeedUpdate === true ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.PointCloud ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	}

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var name in material.attributes ) {

			if ( material.attributes[ name ].needsUpdate ) return true;

		}

		return false;

	}

	function clearCustomAttributes( material ) {

		for ( var name in material.attributes ) {

			material.attributes[ name ].needsUpdate = false;

		}

	}

	// Objects removal

	function removeObject( object ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.PointCloud ||
			 object instanceof THREE.Line ) {

			delete _webglObjects[ object.id ];

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( _webglObjectsImmediate, object );

		}

		delete object.__webglInit;
		delete object._modelViewMatrix;
		delete object._normalMatrix;

		delete object.__webglActive;

	}

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	}

	// Materials

	function initMaterial( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.PointCloudMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			var shader = THREE.ShaderLib[ shaderID ];

			material.__webglShader = {
				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			}

		} else {

			material.__webglShader = {
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			}

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var maxShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );

		var parameters = {

			precision: _precision,
			supportsVertexTextures: _supportsVertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			lightMap: !! material.lightMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: _logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: _this.maxMorphTargets,
			maxMorphNormals: _this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
			shadowMapType: _this.shadowMapType,
			shadowMapDebug: _this.shadowMapDebug,
			shadowMapCascade: _this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		// Generate code

		var chunks = [];

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var name in parameters ) {

			chunks.push( name );
			chunks.push( parameters[ name ] );

		}

		var code = chunks.join();

		var program;

		// Check if code has been already compiled

		for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				program.usedTimes ++;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( _this, code, material, parameters );
			_programs.push( program );

			_this.info.memory.programs = _programs.length;

		}

		material.program = program;

		var attributes = program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = 'morphTarget';

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = 'morphNormal';

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( var u in material.__webglShader.uniforms ) {

			var location = material.program.uniforms[ u ];

			if ( location ) {
				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
			}

		}

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === -1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( _logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights );
					_lightsNeedUpdate = false;
				}

				if ( refreshLights ) {
					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );
				} else {
					markUniformsLightsNeedsUpdate( m_uniforms, false );
				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointCloudMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( material.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//  1. color map
		//  2. specular map
		//  3. normal map
		//  4. bump map
		//  5. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

		uniforms.ambientLightColor.needsUpdate = boolean;

		uniforms.directionalLightColor.needsUpdate = boolean;
		uniforms.directionalLightDirection.needsUpdate = boolean;

		uniforms.pointLightColor.needsUpdate = boolean;
		uniforms.pointLightPosition.needsUpdate = boolean;
		uniforms.pointLightDistance.needsUpdate = boolean;

		uniforms.spotLightColor.needsUpdate = boolean;
		uniforms.spotLightPosition.needsUpdate = boolean;
		uniforms.spotLightDistance.needsUpdate = boolean;
		uniforms.spotLightDirection.needsUpdate = boolean;
		uniforms.spotLightAngleCos.needsUpdate = boolean;
		uniforms.spotLightExponent.needsUpdate = boolean;

		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
		uniforms.hemisphereLightDirection.needsUpdate = boolean;

	}

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit, offset;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 2;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 3;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 4;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						_this.setTexture( texture, textureUnit );

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	}

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_direction.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _direction.x;
				spotPositions[ spotOffset + 1 ] = _direction.y;
				spotPositions[ spotOffset + 2 ] = _direction.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	}

	this.uploadTexture = function ( texture ) {

		if ( texture.__webglInit === undefined ) {

			texture.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			texture.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

		}

		_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, _maxTextureSize );

		var image = texture.image,
		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "Attempt to load unsupported compressed texture format" );

					}

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else { // regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		texture.needsUpdate = false;

		if ( texture.onUpdate ) texture.onUpdate();

	};

	this.setTexture = function ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );

		if ( texture.needsUpdate ) {

			_this.uploadTexture( texture );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "Attempt to load unsupported compressed texture format" );

								}

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow || light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}

	// DEPRECATED
	
	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	setSize: function ( width, height ) {

		this.width = width;
		this.height = height;

	},

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/webgl/WebGLExtensions.js

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {
		
			case 'OES_texture_float':
				extension = gl.getExtension( 'OES_texture_float' );
				break;

			case 'OES_texture_float_linear':
				extension = gl.getExtension( 'OES_texture_float_linear' );
				break;

			case 'OES_standard_derivatives':
				extension = gl.getExtension( 'OES_standard_derivatives' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			case 'OES_element_index_uint':
				extension = gl.getExtension( 'OES_element_index_uint' );
				break;

			case 'EXT_blend_minmax':
				extension = gl.getExtension( 'EXT_blend_minmax' );
				break;

			case 'EXT_frag_depth':
				extension = gl.getExtension( 'EXT_frag_depth' );
				break;

		}

		if ( extension === null ) {

			console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	var generateDefines = function ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	var cacheUniformLocations = function ( gl, program, identifiers ) {

		var uniforms = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			uniforms[ id ] = gl.getUniformLocation( program, id );

		}

		return uniforms;

	};

	var cacheAttributeLocations = function ( gl, program, identifiers ) {

		var attributes = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			attributes[ id ] = gl.getAttribLocation( program, id );

		}

		return attributes;

	};

	return function ( renderer, code, material, parameters ) {

		var _this = renderer;
		var _gl = _this.context;

		var defines = material.defines;
		var uniforms = material.__webglShader.uniforms;
		var attributes = material.attributes;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var index0AttributeName = material.index0AttributeName;

		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0

			index0AttributeName = 'position';

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		var program = _gl.createProgram();

		var prefix_vertex, prefix_fragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefix_vertex = '';
			prefix_fragment = '';

		} else {

			prefix_vertex = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				customDefines,

				parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				"#define MAX_BONES " + parameters.maxBones,

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",


				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",

				"attribute vec3 position;",
				"attribute vec3 normal;",
				"attribute vec2 uv;",
				"attribute vec2 uv2;",

				"#ifdef USE_COLOR",

				"	attribute vec3 color;",

				"#endif",

				"#ifdef USE_MORPHTARGETS",

				"	attribute vec3 morphTarget0;",
				"	attribute vec3 morphTarget1;",
				"	attribute vec3 morphTarget2;",
				"	attribute vec3 morphTarget3;",

				"	#ifdef USE_MORPHNORMALS",

				"		attribute vec3 morphNormal0;",
				"		attribute vec3 morphNormal1;",
				"		attribute vec3 morphNormal2;",
				"		attribute vec3 morphNormal3;",

				"	#else",

				"		attribute vec3 morphTarget4;",
				"		attribute vec3 morphTarget5;",
				"		attribute vec3 morphTarget6;",
				"		attribute vec3 morphTarget7;",

				"	#endif",

				"#endif",

				"#ifdef USE_SKINNING",

				"	attribute vec4 skinIndex;",
				"	attribute vec4 skinWeight;",

				"#endif",

				""

			].join( '\n' );

			prefix_fragment = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

				customDefines,

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.metal ? "#define METAL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",

				"uniform mat4 viewMatrix;",
				"uniform vec3 cameraPosition;",
				""

			].join( '\n' );

		}

		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		if ( index0AttributeName !== undefined ) {

			// Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			// And, color, for example is often automatically bound to index 0 so disabling it

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

		}

		// clean up

		_gl.deleteShader( glVertexShader );
		_gl.deleteShader( glFragmentShader );

		// cache uniform locations

		var identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		if ( parameters.logarithmicDepthBuffer ) {

			identifiers.push('logDepthBufFC');

		}


		for ( var u in uniforms ) {

			identifiers.push( u );

		}

		this.uniforms = cacheUniformLocations( _gl, program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( var a in attributes ) {

			identifiers.push( a );

		}

		this.attributes = cacheAttributeLocations( _gl, program, identifiers );
		this.attributesKeys = Object.keys( this.attributes );

		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	var addLineNumbers = function ( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	};

	return function ( gl, type, string ) {

		var shader = gl.createShader( type ); 

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );
			console.warn( addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	var init = function () {

		var vertices = new Float32Array( [
			-1, -1,  0, 0,
			 1, -1,  1, 0,
			 1,  1,  1, 1,
			-1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		gl.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		}

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	};

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.vertex );
		gl.enableVertexAttribArray( attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];
			
			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				gl.disable( gl.BLEND );
				gl.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				gl.activeTexture( gl.TEXTURE0 );
				gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				gl.disable( gl.DEPTH_TEST );

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				gl.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		gl.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

	var _gl = _renderer.context;

	var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3(),
	
	_renderList = [];

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	_depthMaterial = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader
	 } );

	_depthMaterialMorph = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true
	} );

	_depthMaterialSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		skinning: true
	} );

	_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true,
		skinning: true
	} );

	_depthMaterial._shadowPass = true;
	_depthMaterialMorph._shadowPass = true;
	_depthMaterialSkin._shadowPass = true;
	_depthMaterialMorphSkin._shadowPass = true;

	this.render = function ( scene, camera ) {

		if ( _renderer.shadowMapEnabled === false ) return;

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = _lights.length; i < il; i ++ ) {

			light = _lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position.copy( light.shadowCascadeOffset );

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				scene.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			//

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			//

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			_renderList.length = 0;

			projectObject( scene, scene, shadowCamera );


			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

				webglObject = _renderList[ j ];

				object = webglObject.object;
				buffer = webglObject.buffer;

				// culling is overriden globally for all objects
				// while rendering depth map

				// need to deal with MeshFaceMaterial somehow
				// in that case just use the first of material.materials for now
				// (proper solution would require to break objects by materials
				//  similarly to regular rendering and then set corresponding
				//  depth materials per each chunk instead of just once per object)

				objectMaterial = getObjectMaterial( object );

				useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				_renderer.setMaterialFaces( objectMaterial );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

				}

			}

			// set matrices and render immediate objects

			for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

				webglObject = _webglObjectsImmediate[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

	};

	function projectObject( scene, object, shadowCamera ){

		if ( object.visible ) {

			var webglObjects = _webglObjects[ object.id ];

			if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

				for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

					var webglObject = webglObjects[ i ];

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( webglObject );

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( scene, object.children[ i ], shadowCamera );

			}

		}

	}

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
		pointsFrustum[ 1 ].set(  1, - 1, nearZ );
		pointsFrustum[ 2 ].set( - 1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( - 1, - 1, farZ );
		pointsFrustum[ 5 ].set(  1, - 1, farZ );
		pointsFrustum[ 6 ].set( - 1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( - Infinity, - Infinity, - Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			p.unproject( camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;
	
	var init = function () {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	};

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.position );
		gl.enableVertexAttribArray( attributes.uv );

		gl.disable( gl.CULL_FACE );
		gl.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		gl.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );

			if ( sprite.renderDepth === null ) {

				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

			} else {

				sprite.z = sprite.renderDepth;

			}

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			renderer.setDepthTest( material.depthTest );
			renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		
		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}, undefined, function ( event ) {

			if ( onError ) onError( event );

		} );

		texture.sourceFile = url;

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.CubeTexture( images, mapping );

		// no flipping needed for cube textures

		texture.flipY = false;

		var loaded = 0;

		var loadTexture = function ( i ) {

			loader.load( array[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded += 1;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			} );

		}

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	   = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces: {},

	// Just for now. face[weight][style]

	face: 'helvetiker',
	weight: 'normal',
	style: 'normal',
	size: 150,
	divisions: 10,

	getFace: function () {

		try {

			return this.faces[ this.face ][ this.weight ][ this.style ];

		} catch (e) {

			throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

		};

	},

	loadFace: function ( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText: function ( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths: fontPaths, offset: width };

	},




	extractGlyphPoints: function ( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( ! glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch ( action ) {

				case 'm':

					// Move To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;
					path.lineTo( x,y );
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i ++ ] * scaleX + offset;
					cpy  = outline[ i ++ ] * scaleY;
					cpx1 = outline[ i ++ ] * scaleX + offset;
					cpy1 = outline[ i ++ ] * scaleY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i ++ ] *  scaleX + offset;
					cpy  = outline[ i ++ ] *  scaleY;
					cpx1 = outline[ i ++ ] *  scaleX + offset;
					cpy1 = outline[ i ++ ] *  scaleY;
					cpx2 = outline[ i ++ ] *  scaleX + offset;
					cpy2 = outline[ i ++ ] *  scaleY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha * scale, path:path };
	}

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

	var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
	var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
	var style = parameters.style !== undefined ? parameters.style : 'normal';

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function ( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v ++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for ( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count -- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( 'Warning, unable to triangulate polygon!' );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p ++ ) {

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			if ( ( ( px === ax ) && ( py === ay ) ) ||
				 ( ( px === bx ) && ( py === by ) ) ||
				 ( ( px === cx ) && ( py === cy ) ) )	continue;

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX * bpy - aY * bpx;
			cCROSSap = cX * apy - cY * apx;
			bCROSScp = bX * cpy - bY * cpx;

			if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;
			scope.source.connect( scope.panner );
			scope.source.start( 0 );

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();
	var velocity = new THREE.Vector3();

	var positionPrev = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
		velocity.subVectors( position, positionPrev );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );
		listener.setVelocity( velocity.x, velocity.y, velocity.z );

		positionPrev.copy( position );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& ! this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return - 3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (! startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

	var translationObject = new THREE.Vector3();
	var quaternionObject = new THREE.Quaternion();
	var scaleObject = new THREE.Vector3();

	var translationWorld = new THREE.Vector3();
	var quaternionWorld = new THREE.Quaternion();
	var scaleWorld = new THREE.Vector3();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
				this.matrix.decompose( translationObject, quaternionObject, scaleObject );

				this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


			} else {

				this.matrixWorld.copy( this.matrix );

			}


			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	};
	
}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var i, il, item, action, args;

		var subPaths = [], lastPath = new THREE.Path();

		for ( i = 0, il = inActions.length; i < il; i ++ ) {

			item = inActions[ i ];

			args = item.args;
			action = item.action;

			if ( action == THREE.PathActions.MOVE_TO ) {

				if ( lastPath.actions.length != 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length != 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;
	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );
		}

		//console.log("shape", shapes);

		return shapes;
	};

	function isPointInsidePolygon( inPt, inPolygon ) {
		var EPSILON = 0.0000000001;

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
				if ( edgeDy < 0 ) {
					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y == edgeLowPt.y ) {
					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!
				} else {
					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt
				}
			} else {		// parallel or colinear
				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
				// egde lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;
			}
		}

		return	inside;
	}


	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length == 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);
	
	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[mainIdx] = undefined;
	newShapeHoles[mainIdx] = [];

	var i, il;

	for ( i = 0, il = subPaths.length; i < il; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = THREE.Shape.Utils.isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[mainIdx].s.actions = tmpPath.actions;
			newShapes[mainIdx].s.curves = tmpPath.curves;
			
			if ( holesFirst )	mainIdx ++;
			newShapeHoles[mainIdx] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {
		var ambigious = false;
		var toChange = [];

		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			betterShapeHoles[sIdx] = [];
		}
		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			var sh = newShapes[sIdx];
			var sho = newShapeHoles[sIdx];
			for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
				var ho = sho[hIdx];
				var hole_unassigned = true;
				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {
							hole_unassigned = false;
							betterShapeHoles[s2Idx].push( ho );
						} else {
							ambigious = true;
						}
					}
				}
				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
			}
		}
		// console.log("ambigious: ", ambigious);
		if ( toChange.length > 0 ) {
			// console.log("to change: ", toChange);
			if (! ambigious)	newShapeHoles = betterShapeHoles;
		}
	}

	var tmpHoles, j, jl;
	for ( i = 0, il = newShapes.length; i < il; i ++ ) {
		tmpShape = newShapes[i].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[i];
		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
			tmpShape.holes.push( tmpHoles[j].h );
		}
	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			// inOtherPt needs to be colinear to the inSegment
			if ( inSegPt1.x != inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var EPSILON = 0.0000000001;

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs(limit) > EPSILON ) {			// not parallel

				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 == 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt1 ];
				}
				if ( perpSeg2 == limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt2 ];
				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {		// parallel or colinear
				if ( ( perpSeg1 != 0 ) ||
					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {
					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
					return  [ inSeg1Pt1 ];                 					// they are the same point
				}
				// segment#1  is a single point
				if ( seg1Pt ) {
					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return  [ inSeg1Pt1 ];
				}
				// segment#2  is a single point
				if ( seg2Pt ) {
					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return  [ inSeg2Pt1 ];
				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if (seg1dx != 0) {		// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {				// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal == seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal == seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			// The order of legs is important

			var EPSILON = 0.0000000001;

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {				// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {								// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {										// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );
			}
		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;
				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;
				}

				return	true;
			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {
				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
					nextIdx = sIdx+1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
					if ( intersection.length > 0 )		return	true;
				}

				return	false;
			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {
				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
					chkHole = holes[indepHoles[ihIdx]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
						nextIdx = hIdx+1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;
				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[h];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[cutKey] !== undefined )			continue;

						hole = holes[holeIdx];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice(h,1);

							tmpShape1 = shape.slice( 0, shapeIndex+1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex+1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[cutKey] = true;			// remember failure
					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found
				}
			}

			return shape; 			/* shape with no holes */
		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[h] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
	var point1 = points[ intPoint ]
	var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]
	var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
	vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

	return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var vector = new THREE.Vector2();

	vector.x = this.aX + this.xRadius * Math.cos( angle );
	vector.y = this.aY + this.yRadius * Math.sin( angle );

	return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return vector;

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return vector;

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

	LINEAR: 0,
	CATMULLROM: 1,
	CATMULLROM_FORWARD: 2,

	//

	add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
	get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
	remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

	//

	animations: [],

	init: function ( data ) {

		if ( data.initialized === true ) return;

		// loop through all keys

		for ( var h = 0; h < data.hierarchy.length; h ++ ) {

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

					 data.hierarchy[ h ].keys[ k ].time = 0;

				}

				// create quaternions

				if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

				}

			}

			// prepare morph target keys

			if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = - 1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}

		data.initialized = true;

		return data;

	},

	parse: function ( root ) {

		var parseRecurseHierarchy = function ( root, hierarchy ) {

			hierarchy.push( root );

			for ( var c = 0; c < root.children.length; c ++ )
				parseRecurseHierarchy( root.children[ c ], hierarchy );

		};

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

				hierarchy.push( root.skeleton.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	},

	play: function ( animation ) {

		if ( this.animations.indexOf( animation ) === - 1 ) {

			this.animations.push( animation );

		}

	},

	stop: function ( animation ) {

		var index = this.animations.indexOf( animation );

		if ( index !== - 1 ) {

			this.animations.splice( index, 1 );

		}

	},

	update: function ( deltaTimeMS ) {

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].resetBlendWeights( );

		}

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].update( deltaTimeMS );

		}

	}

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

	this.root = root;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.loop = true;
	this.weight = 0;

	this.interpolationType = THREE.AnimationHandler.LINEAR;

};


THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ];


THREE.Animation.prototype.play = function ( startTime, weight ) {

	this.currentTime = startTime !== undefined ? startTime : 0;
	this.weight = weight !== undefined ? weight: 1;

	this.isPlaying = true;

	this.reset();

	THREE.AnimationHandler.play( this );

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;

	THREE.AnimationHandler.stop( this );

};

THREE.Animation.prototype.reset = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		object.matrixAutoUpdate = true;

		if ( object.animationCache === undefined ) {

			object.animationCache = {
				animations: {},
				blending: {
					positionWeight: 0.0,
					quaternionWeight: 0.0,
					scaleWeight: 0.0
				}
			};
		}

		if ( object.animationCache.animations[this.data.name] === undefined ) {

			object.animationCache.animations[this.data.name] = {};
			object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].originalMatrix = object.matrix;

		}

		var animationCache = object.animationCache.animations[this.data.name];

		// Get keys to match our current time

		for ( var t = 0; t < 3; t ++ ) {

			var type = this.keyTypes[ t ];

			var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
			var nextKey = this.getNextKeyWith( type, h, 1 );

			while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

				prevKey = nextKey;
				nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

			}

			animationCache.prevKey[ type ] = prevKey;
			animationCache.nextKey[ type ] = nextKey;

		}

	}

};

THREE.Animation.prototype.resetBlendWeights = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		if ( object.animationCache !== undefined ) {

			object.animationCache.blending.positionWeight = 0.0;
			object.animationCache.blending.quaternionWeight = 0.0;
			object.animationCache.blending.scaleWeight = 0.0;

		}

	}

};

THREE.Animation.prototype.update = (function(){

	var points = [];
	var target = new THREE.Vector3();
	var newVector = new THREE.Vector3();
	var newQuat = new THREE.Quaternion();

	// Catmull-Rom spline

	var interpolateCatmullRom = function ( points, scale ) {

		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

		return v3;

	};

	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

	return function ( delta ) {

		if ( this.isPlaying === false ) return;

		this.currentTime += delta * this.timeScale;

		if ( this.weight === 0 )
			return;

		//

		var duration = this.data.length;

		if ( this.currentTime > duration || this.currentTime < 0 ) {

			if ( this.loop ) {

				this.currentTime %= duration;

				if ( this.currentTime < 0 )
					this.currentTime += duration;

				this.reset();

			} else {

				this.stop();
				return;

			}

		}

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];
			var animationCache = object.animationCache.animations[this.data.name];
			var blending = object.animationCache.blending;

			// loop through pos/rot/scl

			for ( var t = 0; t < 3; t ++ ) {

				// get keys

				var type    = this.keyTypes[ t ];
				var prevKey = animationCache.prevKey[ type ];
				var nextKey = animationCache.nextKey[ type ];

				if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
					( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

					prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;

				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

				var prevXYZ = prevKey[ type ];
				var nextXYZ = nextKey[ type ];

				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;

				// interpolate

				if ( type === "pos" ) {

					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

						// blend
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						object.position.lerp( newVector, proportionalWeight );
						blending.positionWeight += this.weight;

					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
								this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						points[ 1 ] = prevXYZ;
						points[ 2 ] = nextXYZ;
						points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

						scale = scale * 0.33 + 0.33;

						var currentPoint = interpolateCatmullRom( points, scale );
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						blending.positionWeight += this.weight;

						// blend

						var vector = object.position;
						
						vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
						vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
						vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							target.sub( vector );
							target.y = 0;
							target.normalize();

							var angle = Math.atan2( target.x, target.z );
							object.rotation.set( 0, angle, 0 );

						}

					}

				} else if ( type === "rot" ) {

					THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

					// Avoid paying the cost of an additional slerp if we don't have to
					if ( blending.quaternionWeight === 0 ) {

						object.quaternion.copy(newQuat);
						blending.quaternionWeight = this.weight;

					} else {

						var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
						THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
						blending.quaternionWeight += this.weight;

					}

				} else if ( type === "scl" ) {

					newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

					var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
					object.scale.lerp( newVector, proportionalWeight );
					blending.scaleWeight += this.weight;

				}

			}

		}

		return true;

	};

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

	this.root = data.node;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( this.root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s ++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};


THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.play( this );

};


THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;

	THREE.AnimationHandler.stop( this );

	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
		
		var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			original.copy( obj.matrix );
			obj.matrix = original;

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

	if ( this.isPlaying === false ) return;

	this.currentTime += delta * this.timeScale;

	//

	var duration = this.data.length;

	if ( this.loop === true && this.currentTime > duration ) {

		this.currentTime %= duration;

	}

	this.currentTime = Math.min( this.currentTime, duration );

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;


		if ( keys.length ) {

			var prevKey = animationCache.prevKey;
			var nextKey = animationCache.nextKey;

			if ( nextKey.time <= this.currentTime ) {

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = keys[ prevKey.index + 1 ];

				}

				animationCache.prevKey = prevKey;
				animationCache.nextKey = nextKey;

			}

			if ( nextKey.time >= this.currentTime ) {

				prevKey.interpolate( nextKey, this.currentTime );

			} else {

				prevKey.interpolate( nextKey, nextKey.time );

			}

			this.data.hierarchy[ h ].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key -- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 */

THREE.MorphAnimation = function ( mesh ) {

	this.mesh = mesh;
	this.frames = mesh.morphTargetInfluences.length;
	this.currentTime = 0;
	this.duration = 1000;
	this.loop = true;

	this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

	play: function () {

		this.isPlaying = true;

	},

	pause: function () {

		this.isPlaying = false;

	},

	update: ( function () {

		var lastFrame = 0;
		var currentFrame = 0;

		return function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			if ( frame != currentFrame ) {

				this.mesh.morphTargetInfluences[ lastFrame ] = 0;
				this.mesh.morphTargetInfluences[ currentFrame ] = 1;
				this.mesh.morphTargetInfluences[ frame ] = 0;

				lastFrame = currentFrame;
				currentFrame = frame;

			}

			this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

		}

	} )()

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CubeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
	return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

 };

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( inPt, inPrev, inNext ) {

		var EPSILON = 0.0000000001;
		
		// computes for inPt the corresponding point inPt' on a new contour
		//   shiftet by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.
		
		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
		
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		
		// check for colinear edges
		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
			
			// length of vectors for normalizing
	
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			
			// shift adjacent points by unit vectors to the left
	
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
			// scaling factor for v_prev to intersection point
	
			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			// vector from inPt to intersection point
	
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
			if ( v_trans_lensq <= 2 ) {
				return	new THREE.Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
			
		} else {		// handle special case of colinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > EPSILON ) {
				if ( v_next_x > EPSILON ) { direction_eq = true; }
			} else {
				if ( v_prev_x < - EPSILON ) {
					if ( v_next_x < - EPSILON ) { direction_eq = true; }
				} else {
					if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
				}
			}

			if ( direction_eq ) {
				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {
			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];
		} else {
			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];
		}
	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = widthSegments || 1;
	var gridY = heightSegments || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset     ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2     ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset     ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * (thetaSegments + 1);

		for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength 
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < heightSegments; y ++ ) {

		for ( x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

	this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;
	
	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// consruct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? (i + 1) % segments : i + 1;
			jp = (j + 1) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i     ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		-1, -1, -1,    -1, -1,  1,
		-1,  1, -1,    -1,  1,  1,
		 1, -1, -1,     1, -1,  1,
		 1,  1, -1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, -r, -t,     0, -r,  t,
		 0,  r, -t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		-r, -t,  0,    -r,  t,  0,
		 r, -t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		-t,  0, -r,     t,  0, -r,
		-t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	return function ( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );

		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;

	/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/

	var vertices = this.geometry.attributes.position.array;

	vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
	vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

	vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
	vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

	vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
	vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

	vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
	vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

	//

	vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
	vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

	vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
	vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

	vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
	vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

	vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
	vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

	//

	vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
	vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

	vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
	vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

	vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
	vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

	vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
	vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

	this.geometry.attributes.position.needsUpdate = true;

	this.geometry.computeBoundingSphere();

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;
	
	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	var setPoint = function ( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	};

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = new Float32Array( numEdges * 2 * 3 );

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = function () {

	var vertices = this.geometry.vertices;

	var object = this.object;
	var objectVertices = object.geometry.vertices;
	var objectFaces = object.geometry.faces;
	var objectWorldMatrix = object.matrixWorld;

	object.updateMatrixWorld( true );

	this.normalMatrix.getNormalMatrix( objectWorldMatrix );

	for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

		var face = objectFaces[ i ];

		vertices[ i2 ].copy( objectVertices[ face.a ] )
			.add( objectVertices[ face.b ] )
			.add( objectVertices[ face.c ] )
			.divideScalar( 3 )
			.applyMatrix4( objectWorldMatrix );

		vertices[ i2 + 1 ].copy( face.normal )
			.applyMatrix3( this.normalMatrix )
			.normalize()
			.multiplyScalar( this.size )
			.add( vertices[ i2 ] );

	}

	this.geometry.verticesNeedUpdate = true;

	return this;

};


// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( object.geometry instanceof THREE.BufferGeometry ) {

		if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var indices = object.geometry.attributes.index.array;
			var drawcalls = object.geometry.drawcalls;
			var numEdges = 0;

			if ( drawcalls.length === 0 ) {

				drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var start = drawcalls[ o ].start;
				var count = drawcalls[ o ].count;
				var index = drawcalls[ o ].index;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = index + indices[ i + j ];
						edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = 3 * edges[ 2 * i + j];
					coords[ index + 0 ] = vertices[ index2 ];
					coords[ index + 1 ] = vertices[ index2 + 1 ];
					coords[ index + 2 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else { // non-indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};


// Export the THREE object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

},{}]},{},["c:\\Users\\Martin\\Documents\\Code\\interface3d\\js\\main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwianNcXE1UTExvYWRlci5qcyIsImpzXFxPQkpNVExMb2FkZXIuanMiLCJqc1xca2luZXRpYy1jb250cm9scy5qcyIsImpzXFxsb2FkaW5nLmpzIiwianNcXG1haW4uanMiLCJub2RlX21vZHVsZXNcXGhhbW1lcmpzXFxoYW1tZXIuanMiLCJub2RlX21vZHVsZXNcXHRocmVlLXdvcmxkXFx3b3JsZC5qcyIsIm5vZGVfbW9kdWxlc1xcdGhyZWVcXHRocmVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxyXG4gKiBMb2FkcyBhIFdhdmVmcm9udCAubXRsIGZpbGUgc3BlY2lmeWluZyBtYXRlcmlhbHNcclxuICpcclxuICogQGF1dGhvciBhbmdlbHh1YW5jaGFuZ1xyXG4gKi9cclxuXHJcbnZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJyk7XHJcblxyXG5USFJFRS5NVExMb2FkZXIgPSBmdW5jdGlvbiggYmFzZVVybCwgb3B0aW9ucywgY3Jvc3NPcmlnaW4gKSB7XHJcblxyXG5cdHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHR0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTVRMTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1UTExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGxvYWRlZCBNVEwgZmlsZVxyXG5cdCAqIEBwYXJhbSB0ZXh0IC0gQ29udGVudCBvZiBNVEwgZmlsZVxyXG5cdCAqIEByZXR1cm4ge1RIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3J9XHJcblx0ICovXHJcblx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCBcIlxcblwiICk7XHJcblx0XHR2YXIgaW5mbyA9IHt9O1xyXG5cdFx0dmFyIGRlbGltaXRlcl9wYXR0ZXJuID0gL1xccysvO1xyXG5cdFx0dmFyIG1hdGVyaWFsc0luZm8gPSB7fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF07XHJcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcclxuXHJcblx0XHRcdGlmICggbGluZS5sZW5ndGggPT09IDAgfHwgbGluZS5jaGFyQXQoIDAgKSA9PT0gJyMnICkge1xyXG5cclxuXHRcdFx0XHQvLyBCbGFuayBsaW5lIG9yIGNvbW1lbnQgaWdub3JlXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcG9zID0gbGluZS5pbmRleE9mKCAnICcgKTtcclxuXHJcblx0XHRcdHZhciBrZXkgPSAoIHBvcyA+PSAwICkgPyBsaW5lLnN1YnN0cmluZyggMCwgcG9zICkgOiBsaW5lO1xyXG5cdFx0XHRrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcclxuXHJcblx0XHRcdHZhciB2YWx1ZSA9ICggcG9zID49IDAgKSA/IGxpbmUuc3Vic3RyaW5nKCBwb3MgKyAxICkgOiBcIlwiO1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcclxuXHJcblx0XHRcdGlmICgga2V5ID09PSBcIm5ld210bFwiICkge1xyXG5cclxuXHRcdFx0XHQvLyBOZXcgbWF0ZXJpYWxcclxuXHJcblx0XHRcdFx0aW5mbyA9IHsgbmFtZTogdmFsdWUgfTtcclxuXHRcdFx0XHRtYXRlcmlhbHNJbmZvWyB2YWx1ZSBdID0gaW5mbztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGluZm8gKSB7XHJcblxyXG5cdFx0XHRcdGlmICgga2V5ID09PSBcImthXCIgfHwga2V5ID09PSBcImtkXCIgfHwga2V5ID09PSBcImtzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNzID0gdmFsdWUuc3BsaXQoIGRlbGltaXRlcl9wYXR0ZXJuLCAzICk7XHJcblx0XHRcdFx0XHRpbmZvWyBrZXkgXSA9IFsgcGFyc2VGbG9hdCggc3NbMF0gKSwgcGFyc2VGbG9hdCggc3NbMV0gKSwgcGFyc2VGbG9hdCggc3NbMl0gKSBdO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGluZm9bIGtleSBdID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsQ3JlYXRvciA9IG5ldyBUSFJFRS5NVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yKCB0aGlzLmJhc2VVcmwsIHRoaXMub3B0aW9ucyApO1xyXG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldE1hdGVyaWFscyggbWF0ZXJpYWxzSW5mbyApO1xyXG5cdFx0cmV0dXJuIG1hdGVyaWFsQ3JlYXRvcjtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgVEhSRUUtTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvclxyXG4gKiBAcGFyYW0gYmFzZVVybCAtIFVybCByZWxhdGl2ZSB0byB3aGljaCB0ZXh0dXJlcyBhcmUgbG9hZGVkXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gU2V0IG9mIG9wdGlvbnMgb24gaG93IHRvIGNvbnN0cnVjdCB0aGUgbWF0ZXJpYWxzXHJcbiAqICAgICAgICAgICAgICAgICAgc2lkZTogV2hpY2ggc2lkZSB0byBhcHBseSB0aGUgbWF0ZXJpYWxcclxuICogICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5Gcm9udFNpZGUgKGRlZmF1bHQpLCBUSFJFRS5CYWNrU2lkZSwgVEhSRUUuRG91YmxlU2lkZVxyXG4gKiAgICAgICAgICAgICAgICAgIHdyYXA6IFdoYXQgdHlwZSBvZiB3cmFwcGluZyB0byBhcHBseSBmb3IgdGV4dHVyZXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5SZXBlYXRXcmFwcGluZyAoZGVmYXVsdCksIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcclxuICogICAgICAgICAgICAgICAgICBub3JtYWxpemVSR0I6IFJHQnMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIDAtMSBmcm9tIDAtMjU1XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZSwgYXNzdW1lZCB0byBiZSBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICogICAgICAgICAgICAgICAgICBpZ25vcmVaZXJvUkdCczogSWdub3JlIHZhbHVlcyBvZiBSR0JzIChLYSxLZCxLcykgdGhhdCBhcmUgYWxsIDAnc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZVxyXG4gKiAgICAgICAgICAgICAgICAgIGludmVydFRyYW5zcGFyZW5jeTogSWYgdHJhbnNwYXJlbmN5IG5lZWQgdG8gYmUgaW52ZXJ0ZWQgKGludmVyc2lvbiBpcyBuZWVkZWQgaWYgZCA9IDAgaXMgZnVsbHkgb3BhcXVlKVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdDogZmFsc2UgKGQgPSAxIGlzIGZ1bGx5IG9wYXF1ZSlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5cclxuVEhSRUUuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvciA9IGZ1bmN0aW9uKCBiYXNlVXJsLCBvcHRpb25zICkge1xyXG5cclxuXHR0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5tYXRlcmlhbHNJbmZvID0ge307XHJcblx0dGhpcy5tYXRlcmlhbHMgPSB7fTtcclxuXHR0aGlzLm1hdGVyaWFsc0FycmF5ID0gW107XHJcblx0dGhpcy5uYW1lTG9va3VwID0ge307XHJcblxyXG5cdHRoaXMuc2lkZSA9ICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zaWRlICk/IHRoaXMub3B0aW9ucy5zaWRlOiBUSFJFRS5Gcm9udFNpZGU7XHJcblx0dGhpcy53cmFwID0gKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLndyYXAgKT8gdGhpcy5vcHRpb25zLndyYXA6IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvcixcclxuXHJcblx0c2V0TWF0ZXJpYWxzOiBmdW5jdGlvbiggbWF0ZXJpYWxzSW5mbyApIHtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsc0luZm8gPSB0aGlzLmNvbnZlcnQoIG1hdGVyaWFsc0luZm8gKTtcclxuXHRcdHRoaXMubWF0ZXJpYWxzID0ge307XHJcblx0XHR0aGlzLm1hdGVyaWFsc0FycmF5ID0gW107XHJcblx0XHR0aGlzLm5hbWVMb29rdXAgPSB7fTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydDogZnVuY3Rpb24oIG1hdGVyaWFsc0luZm8gKSB7XHJcblxyXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zICkgcmV0dXJuIG1hdGVyaWFsc0luZm87XHJcblxyXG5cdFx0dmFyIGNvbnZlcnRlZCA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtbiBpbiBtYXRlcmlhbHNJbmZvICkge1xyXG5cclxuXHRcdFx0Ly8gQ29udmVydCBtYXRlcmlhbHMgaW5mbyBpbnRvIG5vcm1hbGl6ZWQgZm9ybSBiYXNlZCBvbiBvcHRpb25zXHJcblxyXG5cdFx0XHR2YXIgbWF0ID0gbWF0ZXJpYWxzSW5mb1sgbW4gXTtcclxuXHJcblx0XHRcdHZhciBjb3ZtYXQgPSB7fTtcclxuXHJcblx0XHRcdGNvbnZlcnRlZFsgbW4gXSA9IGNvdm1hdDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwcm9wIGluIG1hdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNhdmUgPSB0cnVlO1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hdFsgcHJvcCBdO1xyXG5cdFx0XHRcdHZhciBscHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggbHByb3AgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAna2QnOlxyXG5cdFx0XHRcdFx0Y2FzZSAna2EnOlxyXG5cdFx0XHRcdFx0Y2FzZSAna3MnOlxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gRGlmZnVzZSBjb2xvciAoY29sb3IgdW5kZXIgd2hpdGUgbGlnaHQpIHVzaW5nIFJHQiB2YWx1ZXNcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5ub3JtYWxpemVSR0IgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gWyB2YWx1ZVsgMCBdIC8gMjU1LCB2YWx1ZVsgMSBdIC8gMjU1LCB2YWx1ZVsgMiBdIC8gMjU1IF07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaWdub3JlWmVyb1JHQnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWVbIDAgXSA9PT0gMCAmJiB2YWx1ZVsgMSBdID09PSAwICYmIHZhbHVlWyAxIF0gPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWdub3JlXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c2F2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ2QnOlxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gQWNjb3JkaW5nIHRvIE1UTCBmb3JtYXQgKGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9tdGwvKTpcclxuXHRcdFx0XHRcdFx0Ly8gICBkIGlzIGRpc3NvbHZlIGZvciBjdXJyZW50IG1hdGVyaWFsXHJcblx0XHRcdFx0XHRcdC8vICAgZmFjdG9yIG9mIDEuMCBpcyBmdWxseSBvcGFxdWUsIGEgZmFjdG9yIG9mIDAgaXMgZnVsbHkgZGlzc29sdmVkIChjb21wbGV0ZWx5IHRyYW5zcGFyZW50KVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmludmVydFRyYW5zcGFyZW5jeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSAxIC0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHNhdmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y292bWF0WyBscHJvcCBdID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcclxuXHJcblx0fSxcclxuXHJcblx0cHJlbG9hZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNyZWF0ZSggbW4gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEluZGV4OiBmdW5jdGlvbiggbWF0ZXJpYWxOYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5hbWVMb29rdXBbIG1hdGVyaWFsTmFtZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRBc0FycmF5OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdGVyaWFsc0FycmF5WyBpbmRleCBdID0gdGhpcy5jcmVhdGUoIG1uICk7XHJcblx0XHRcdHRoaXMubmFtZUxvb2t1cFsgbW4gXSA9IGluZGV4O1xyXG5cdFx0XHRpbmRleCArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzQXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCBtYXRlcmlhbE5hbWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuY3JlYXRlTWF0ZXJpYWxfKCBtYXRlcmlhbE5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWF0ZXJpYWxfOiBmdW5jdGlvbiAoIG1hdGVyaWFsTmFtZSApIHtcclxuXHJcblx0XHQvLyBDcmVhdGUgbWF0ZXJpYWxcclxuXHJcblx0XHR2YXIgbWF0ID0gdGhpcy5tYXRlcmlhbHNJbmZvWyBtYXRlcmlhbE5hbWUgXTtcclxuXHRcdHZhciBwYXJhbXMgPSB7XHJcblxyXG5cdFx0XHRuYW1lOiBtYXRlcmlhbE5hbWUsXHJcblx0XHRcdHNpZGU6IHRoaXMuc2lkZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gbWF0ICkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlID0gbWF0WyBwcm9wIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBwcm9wLnRvTG93ZXJDYXNlKCkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIE5zIGlzIG1hdGVyaWFsIHNwZWN1bGFyIGV4cG9uZW50XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2tkJzpcclxuXHJcblx0XHRcdFx0XHQvLyBEaWZmdXNlIGNvbG9yIChjb2xvciB1bmRlciB3aGl0ZSBsaWdodCkgdXNpbmcgUkdCIHZhbHVlc1xyXG5cclxuXHRcdFx0XHRcdHBhcmFtc1sgJ2RpZmZ1c2UnIF0gPSBuZXcgVEhSRUUuQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2thJzpcclxuXHJcblx0XHRcdFx0XHQvLyBBbWJpZW50IGNvbG9yIChjb2xvciB1bmRlciBzaGFkb3cpIHVzaW5nIFJHQiB2YWx1ZXNcclxuXHJcblx0XHRcdFx0XHRwYXJhbXNbICdhbWJpZW50JyBdID0gbmV3IFRIUkVFLkNvbG9yKCkuZnJvbUFycmF5KCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdrcyc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gU3BlY3VsYXIgY29sb3IgKGNvbG9yIHdoZW4gbGlnaHQgaXMgcmVmbGVjdGVkIGZyb20gc2hpbnkgc3VyZmFjZSkgdXNpbmcgUkdCIHZhbHVlc1xyXG5cdFx0XHRcdFx0cGFyYW1zWyAnc3BlY3VsYXInIF0gPSBuZXcgVEhSRUUuQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ21hcF9rZCc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gRGlmZnVzZSB0ZXh0dXJlIG1hcFxyXG5cclxuXHRcdFx0XHRcdHBhcmFtc1sgJ21hcCcgXSA9IHRoaXMubG9hZFRleHR1cmUoIHRoaXMuYmFzZVVybCArIHZhbHVlICk7XHJcblx0XHRcdFx0XHRwYXJhbXNbICdtYXAnIF0ud3JhcFMgPSB0aGlzLndyYXA7XHJcblx0XHRcdFx0XHRwYXJhbXNbICdtYXAnIF0ud3JhcFQgPSB0aGlzLndyYXA7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ25zJzpcclxuXHJcblx0XHRcdFx0XHQvLyBUaGUgc3BlY3VsYXIgZXhwb25lbnQgKGRlZmluZXMgdGhlIGZvY3VzIG9mIHRoZSBzcGVjdWxhciBoaWdobGlnaHQpXHJcblx0XHRcdFx0XHQvLyBBIGhpZ2ggZXhwb25lbnQgcmVzdWx0cyBpbiBhIHRpZ2h0LCBjb25jZW50cmF0ZWQgaGlnaGxpZ2h0LiBOcyB2YWx1ZXMgbm9ybWFsbHkgcmFuZ2UgZnJvbSAwIHRvIDEwMDAuXHJcblxyXG5cdFx0XHRcdFx0cGFyYW1zWydzaGluaW5lc3MnXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdkJzpcclxuXHJcblx0XHRcdFx0XHQvLyBBY2NvcmRpbmcgdG8gTVRMIGZvcm1hdCAoaHR0cDovL3BhdWxib3Vya2UubmV0L2RhdGFmb3JtYXRzL210bC8pOlxyXG5cdFx0XHRcdFx0Ly8gICBkIGlzIGRpc3NvbHZlIGZvciBjdXJyZW50IG1hdGVyaWFsXHJcblx0XHRcdFx0XHQvLyAgIGZhY3RvciBvZiAxLjAgaXMgZnVsbHkgb3BhcXVlLCBhIGZhY3RvciBvZiAwIGlzIGZ1bGx5IGRpc3NvbHZlZCAoY29tcGxldGVseSB0cmFuc3BhcmVudClcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZhbHVlIDwgMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHBhcmFtc1sndHJhbnNwYXJlbnQnXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHBhcmFtc1snb3BhY2l0eSddID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGFyYW1zWyAnZGlmZnVzZScgXSApIHtcclxuXHJcblx0XHRcdGlmICggIXBhcmFtc1sgJ2FtYmllbnQnIF0pIHBhcmFtc1sgJ2FtYmllbnQnIF0gPSBwYXJhbXNbICdkaWZmdXNlJyBdO1xyXG5cdFx0XHRwYXJhbXNbICdjb2xvcicgXSA9IHBhcmFtc1sgJ2RpZmZ1c2UnIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXSA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCggcGFyYW1zICk7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmU7XHJcblx0XHR2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggdXJsICk7XHJcblxyXG5cdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCwgb25Mb2FkICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0bG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XHJcblx0XHRcdGxvYWRlci5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBUSFJFRS5NVExMb2FkZXIuZW5zdXJlUG93ZXJPZlR3b18oIGltYWdlICk7XHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NVExMb2FkZXIuZW5zdXJlUG93ZXJPZlR3b18gPSBmdW5jdGlvbiAoIGltYWdlICkge1xyXG5cclxuXHRpZiAoICEgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgfHwgISBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICkgKSB7XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiY2FudmFzXCIgKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IFRIUkVFLk1UTExvYWRlci5uZXh0SGlnaGVzdFBvd2VyT2ZUd29fKCBpbWFnZS53aWR0aCApO1xyXG5cdFx0Y2FudmFzLmhlaWdodCA9IFRIUkVFLk1UTExvYWRlci5uZXh0SGlnaGVzdFBvd2VyT2ZUd29fKCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGN0eC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcclxuXHRcdHJldHVybiBjYW52YXM7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGltYWdlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1UTExvYWRlci5uZXh0SGlnaGVzdFBvd2VyT2ZUd29fID0gZnVuY3Rpb24oIHggKSB7XHJcblxyXG5cdC0teDtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxOyBpIDwgMzI7IGkgPDw9IDEgKSB7XHJcblxyXG5cdFx0eCA9IHggfCB4ID4+IGk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHggKyAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1UTExvYWRlci5wcm90b3R5cGUgKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVEhSRUUuTVRMTG9hZGVyO1xyXG4iLCIvKipcclxuICogTG9hZHMgYSBXYXZlZnJvbnQgLm9iaiBmaWxlIHdpdGggbWF0ZXJpYWxzXHJcbiAqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYW5nZWx4dWFuY2hhbmdcclxuICovXHJcblxyXG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpLFxyXG5cdFx0TVRMTG9hZGVyID0gcmVxdWlyZSgnLi9NVExMb2FkZXIuanMnKTtcclxuXHJcblRIUkVFLk9CSk1UTExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT0JKTVRMTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk9CSk1UTExvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG10bHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG10bExvYWRlciA9IG5ldyBNVExMb2FkZXIoIHVybC5zdWJzdHIoIDAsIHVybC5sYXN0SW5kZXhPZiggXCIvXCIgKSArIDEgKSApO1xyXG5cdFx0bXRsTG9hZGVyLmxvYWQoIG10bHVybCwgZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzQ3JlYXRvciA9IG1hdGVyaWFscztcclxuXHRcdFx0bWF0ZXJpYWxzQ3JlYXRvci5wcmVsb2FkKCk7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xyXG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIHRleHQgKTtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5tYXRlcmlhbC5uYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBtYXRlcmlhbHNDcmVhdG9yLmNyZWF0ZSggb2JqZWN0Lm1hdGVyaWFsLm5hbWUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCApIG9iamVjdC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGxvYWRlZCAub2JqIGZpbGVcclxuXHQgKiBAcGFyYW0gZGF0YSAtIGNvbnRlbnQgb2YgLm9iaiBmaWxlXHJcblx0ICogQHBhcmFtIG10bGxpYkNhbGxiYWNrIC0gY2FsbGJhY2sgdG8gaGFuZGxlIG10bGxpYiBkZWNsYXJhdGlvbiAob3B0aW9uYWwpXHJcblx0ICogQHJldHVybiB7VEhSRUUuT2JqZWN0M0R9IC0gT2JqZWN0M0QgKHdpdGggZGVmYXVsdCBtYXRlcmlhbClcclxuXHQgKi9cclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICggZGF0YSwgbXRsbGliQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdmVjdG9yKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHV2KCB1LCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGZhY2UzKCBhLCBiLCBjLCBub3JtYWxzICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFscyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmFjZV9vZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG1lc2hOKCBtZXNoTmFtZSwgbWF0ZXJpYWxOYW1lICkge1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0aWNlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5tZXJnZVZlcnRpY2VzKCk7XHJcblx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5hZGQoIG1lc2ggKTtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdFx0XHRtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtZXNoTmFtZSAhPT0gdW5kZWZpbmVkICkgbWVzaC5uYW1lID0gbWVzaE5hbWU7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsTmFtZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCk7XHJcblx0XHRcdFx0bWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsTmFtZTtcclxuXHJcblx0XHRcdFx0bWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcclxuXHRcdHZhciBvYmplY3QgPSBncm91cDtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCk7XHJcblx0XHR2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgdXZzID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkX2ZhY2UoIGEsIGIsIGMsIG5vcm1hbHNfaW5kcyApIHtcclxuXHJcblx0XHRcdGlmICggbm9ybWFsc19pbmRzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UzKFxyXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGEgKSAtIChmYWNlX29mZnNldCArIDEpLFxyXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGIgKSAtIChmYWNlX29mZnNldCArIDEpLFxyXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGMgKSAtIChmYWNlX29mZnNldCArIDEpXHJcblx0XHRcdFx0KSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZTMoXHJcblx0XHRcdFx0XHRwYXJzZUludCggYSApIC0gKGZhY2Vfb2Zmc2V0ICsgMSksXHJcblx0XHRcdFx0XHRwYXJzZUludCggYiApIC0gKGZhY2Vfb2Zmc2V0ICsgMSksXHJcblx0XHRcdFx0XHRwYXJzZUludCggYyApIC0gKGZhY2Vfb2Zmc2V0ICsgMSksXHJcblx0XHRcdFx0XHRbXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHBhcnNlSW50KCBub3JtYWxzX2luZHNbIDAgXSApIC0gMSBdLmNsb25lKCksXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHBhcnNlSW50KCBub3JtYWxzX2luZHNbIDEgXSApIC0gMSBdLmNsb25lKCksXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHBhcnNlSW50KCBub3JtYWxzX2luZHNbIDIgXSApIC0gMSBdLmNsb25lKClcclxuXHRcdFx0XHRcdF1cclxuXHRcdFx0XHQpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZF91dnMoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cdFx0XHRcdHV2c1sgcGFyc2VJbnQoIGEgKSAtIDEgXS5jbG9uZSgpLFxyXG5cdFx0XHRcdHV2c1sgcGFyc2VJbnQoIGIgKSAtIDEgXS5jbG9uZSgpLFxyXG5cdFx0XHRcdHV2c1sgcGFyc2VJbnQoIGMgKSAtIDEgXS5jbG9uZSgpXHJcblx0XHRcdF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gaGFuZGxlX2ZhY2VfbGluZShmYWNlcywgdXZzLCBub3JtYWxzX2luZHMpIHtcclxuXHJcblx0XHRcdGlmICggZmFjZXNbIDMgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhZGRfZmFjZSggZmFjZXNbIDAgXSwgZmFjZXNbIDEgXSwgZmFjZXNbIDIgXSwgbm9ybWFsc19pbmRzICk7XHJcblxyXG5cdFx0XHRcdGlmICghKHV2cyA9PT0gdW5kZWZpbmVkKSAmJiB1dnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0YWRkX3V2cyggdXZzWyAwIF0sIHV2c1sgMSBdLCB1dnNbIDIgXSApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICghKG5vcm1hbHNfaW5kcyA9PT0gdW5kZWZpbmVkKSAmJiBub3JtYWxzX2luZHMubGVuZ3RoID4gMCkge1xyXG5cclxuXHRcdFx0XHRcdGFkZF9mYWNlKCBmYWNlc1sgMCBdLCBmYWNlc1sgMSBdLCBmYWNlc1sgMyBdLCBbIG5vcm1hbHNfaW5kc1sgMCBdLCBub3JtYWxzX2luZHNbIDEgXSwgbm9ybWFsc19pbmRzWyAzIF0gXSk7XHJcblx0XHRcdFx0XHRhZGRfZmFjZSggZmFjZXNbIDEgXSwgZmFjZXNbIDIgXSwgZmFjZXNbIDMgXSwgWyBub3JtYWxzX2luZHNbIDEgXSwgbm9ybWFsc19pbmRzWyAyIF0sIG5vcm1hbHNfaW5kc1sgMyBdIF0pO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGFkZF9mYWNlKCBmYWNlc1sgMCBdLCBmYWNlc1sgMSBdLCBmYWNlc1sgMyBdKTtcclxuXHRcdFx0XHRcdGFkZF9mYWNlKCBmYWNlc1sgMSBdLCBmYWNlc1sgMiBdLCBmYWNlc1sgMyBdKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoISh1dnMgPT09IHVuZGVmaW5lZCkgJiYgdXZzLmxlbmd0aCA+IDApIHtcclxuXHJcblx0XHRcdFx0XHRhZGRfdXZzKCB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdICk7XHJcblx0XHRcdFx0XHRhZGRfdXZzKCB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIHYgZmxvYXQgZmxvYXQgZmxvYXRcclxuXHJcblx0XHR2YXIgdmVydGV4X3BhdHRlcm4gPSAvdiggK1tcXGR8XFwufFxcK3xcXC18ZV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZV0rKS87XHJcblxyXG5cdFx0Ly8gdm4gZmxvYXQgZmxvYXQgZmxvYXRcclxuXHJcblx0XHR2YXIgbm9ybWFsX3BhdHRlcm4gPSAvdm4oICtbXFxkfFxcLnxcXCt8XFwtfGVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGVdKykvO1xyXG5cclxuXHRcdC8vIHZ0IGZsb2F0IGZsb2F0XHJcblxyXG5cdFx0dmFyIHV2X3BhdHRlcm4gPSAvdnQoICtbXFxkfFxcLnxcXCt8XFwtfGVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGVdKykvO1xyXG5cclxuXHRcdC8vIGYgdmVydGV4IHZlcnRleCB2ZXJ0ZXggLi4uXHJcblxyXG5cdFx0dmFyIGZhY2VfcGF0dGVybjEgPSAvZiggK1xcZCspKCArXFxkKykoICtcXGQrKSggK1xcZCspPy87XHJcblxyXG5cdFx0Ly8gZiB2ZXJ0ZXgvdXYgdmVydGV4L3V2IHZlcnRleC91diAuLi5cclxuXHJcblx0XHR2YXIgZmFjZV9wYXR0ZXJuMiA9IC9mKCArKFxcZCspXFwvKFxcZCspKSggKyhcXGQrKVxcLyhcXGQrKSkoICsoXFxkKylcXC8oXFxkKykpKCArKFxcZCspXFwvKFxcZCspKT8vO1xyXG5cclxuXHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgLi4uXHJcblxyXG5cdFx0dmFyIGZhY2VfcGF0dGVybjMgPSAvZiggKyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSkoICsoXFxkKylcXC8oXFxkKylcXC8oXFxkKykpKCArKFxcZCspXFwvKFxcZCspXFwvKFxcZCspKSggKyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSk/LztcclxuXHJcblx0XHQvLyBmIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIC4uLlxyXG5cclxuXHRcdHZhciBmYWNlX3BhdHRlcm40ID0gL2YoICsoXFxkKylcXC9cXC8oXFxkKykpKCArKFxcZCspXFwvXFwvKFxcZCspKSggKyhcXGQrKVxcL1xcLyhcXGQrKSkoICsoXFxkKylcXC9cXC8oXFxkKykpPy9cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBsaW5lcyA9IGRhdGEuc3BsaXQoIFwiXFxuXCIgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF07XHJcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcclxuXHJcblx0XHRcdHZhciByZXN1bHQ7XHJcblxyXG5cdFx0XHRpZiAoIGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KCAwICkgPT09ICcjJyApIHtcclxuXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IHZlcnRleF9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJ2IDEuMCAyLjAgMy4wXCIsIFwiMS4wXCIsIFwiMi4wXCIsIFwiMy4wXCJdXHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlY3RvcihcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICksXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApLFxyXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKVxyXG5cdFx0XHRcdCkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoICggcmVzdWx0ID0gbm9ybWFsX3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFtcInZuIDEuMCAyLjAgMy4wXCIsIFwiMS4wXCIsIFwiMi4wXCIsIFwiMy4wXCJdXHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggdmVjdG9yKFxyXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKSxcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICksXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApXHJcblx0XHRcdFx0KSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSB1dl9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJ2dCAwLjEgMC4yXCIsIFwiMC4xXCIsIFwiMC4yXCJdXHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCB1dihcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICksXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApXHJcblx0XHRcdFx0KSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4xLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJmIDEgMiAzXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIHVuZGVmaW5lZF1cclxuXHJcblx0XHRcdFx0aGFuZGxlX2ZhY2VfbGluZShbIHJlc3VsdFsgMSBdLCByZXN1bHRbIDIgXSwgcmVzdWx0WyAzIF0sIHJlc3VsdFsgNCBdIF0pO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4yLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJmIDEvMSAyLzIgMy8zXCIsIFwiIDEvMVwiLCBcIjFcIiwgXCIxXCIsIFwiIDIvMlwiLCBcIjJcIiwgXCIyXCIsIFwiIDMvM1wiLCBcIjNcIiwgXCIzXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXHJcblxyXG5cdFx0XHRcdGhhbmRsZV9mYWNlX2xpbmUoXHJcblx0XHRcdFx0XHRbIHJlc3VsdFsgMiBdLCByZXN1bHRbIDUgXSwgcmVzdWx0WyA4IF0sIHJlc3VsdFsgMTEgXSBdLCAvL2ZhY2VzXHJcblx0XHRcdFx0XHRbIHJlc3VsdFsgMyBdLCByZXN1bHRbIDYgXSwgcmVzdWx0WyA5IF0sIHJlc3VsdFsgMTIgXSBdIC8vdXZcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4zLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJmIDEvMS8xIDIvMi8yIDMvMy8zXCIsIFwiIDEvMS8xXCIsIFwiMVwiLCBcIjFcIiwgXCIxXCIsIFwiIDIvMi8yXCIsIFwiMlwiLCBcIjJcIiwgXCIyXCIsIFwiIDMvMy8zXCIsIFwiM1wiLCBcIjNcIiwgXCIzXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cclxuXHJcblx0XHRcdFx0aGFuZGxlX2ZhY2VfbGluZShcclxuXHRcdFx0XHRcdFsgcmVzdWx0WyAyIF0sIHJlc3VsdFsgNiBdLCByZXN1bHRbIDEwIF0sIHJlc3VsdFsgMTQgXSBdLCAvL2ZhY2VzXHJcblx0XHRcdFx0XHRbIHJlc3VsdFsgMyBdLCByZXN1bHRbIDcgXSwgcmVzdWx0WyAxMSBdLCByZXN1bHRbIDE1IF0gXSwgLy91dlxyXG5cdFx0XHRcdFx0WyByZXN1bHRbIDQgXSwgcmVzdWx0WyA4IF0sIHJlc3VsdFsgMTIgXSwgcmVzdWx0WyAxNiBdIF0gLy9ub3JtYWxcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm40LmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBbXCJmIDEvLzEgMi8vMiAzLy8zXCIsIFwiIDEvLzFcIiwgXCIxXCIsIFwiMVwiLCBcIiAyLy8yXCIsIFwiMlwiLCBcIjJcIiwgXCIgMy8vM1wiLCBcIjNcIiwgXCIzXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXHJcblxyXG5cdFx0XHRcdGhhbmRsZV9mYWNlX2xpbmUoXHJcblx0XHRcdFx0XHRbIHJlc3VsdFsgMiBdLCByZXN1bHRbIDUgXSwgcmVzdWx0WyA4IF0sIHJlc3VsdFsgMTEgXSBdLCAvL2ZhY2VzXHJcblx0XHRcdFx0XHRbIF0sIC8vdXZcclxuXHRcdFx0XHRcdFsgcmVzdWx0WyAzIF0sIHJlc3VsdFsgNiBdLCByZXN1bHRbIDkgXSwgcmVzdWx0WyAxMiBdIF0gLy9ub3JtYWxcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggL15vIC8udGVzdCggbGluZSApICkge1xyXG5cclxuXHRcdFx0XHQvLyBvYmplY3RcclxuXHJcblx0XHRcdFx0bWVzaE4oKTtcclxuXHRcdFx0XHRmYWNlX29mZnNldCA9IGZhY2Vfb2Zmc2V0ICsgdmVydGljZXMubGVuZ3RoO1xyXG5cdFx0XHRcdHZlcnRpY2VzID0gW107XHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblx0XHRcdFx0b2JqZWN0Lm5hbWUgPSBsaW5lLnN1YnN0cmluZyggMiApLnRyaW0oKTtcclxuXHRcdFx0XHRncm91cC5hZGQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggL15nIC8udGVzdCggbGluZSApICkge1xyXG5cclxuXHRcdFx0XHQvLyBncm91cFxyXG5cclxuXHRcdFx0XHRtZXNoTiggbGluZS5zdWJzdHJpbmcoIDIgKS50cmltKCksIHVuZGVmaW5lZCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggL151c2VtdGwgLy50ZXN0KCBsaW5lICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIG1hdGVyaWFsXHJcblxyXG5cdFx0XHRcdG1lc2hOKCB1bmRlZmluZWQsIGxpbmUuc3Vic3RyaW5nKCA3ICkudHJpbSgpICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAvXm10bGxpYiAvLnRlc3QoIGxpbmUgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gbXRsIGZpbGVcclxuXHJcblx0XHRcdFx0aWYgKCBtdGxsaWJDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbXRsZmlsZSA9IGxpbmUuc3Vic3RyaW5nKCA3ICk7XHJcblx0XHRcdFx0XHRtdGxmaWxlID0gbXRsZmlsZS50cmltKCk7XHJcblx0XHRcdFx0XHRtdGxsaWJDYWxsYmFjayggbXRsZmlsZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAvXnMgLy50ZXN0KCBsaW5lICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFNtb290aCBzaGFkaW5nXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJUSFJFRS5PQkpNVExMb2FkZXI6IFVuaGFuZGxlZCBsaW5lIFwiICsgbGluZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL0FkZCBsYXN0IG9iamVjdFxyXG5cdFx0bWVzaE4odW5kZWZpbmVkLCB1bmRlZmluZWQpO1xyXG5cclxuXHRcdHJldHVybiBncm91cDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9CSk1UTExvYWRlci5wcm90b3R5cGUgKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVEhSRUUuT0JKTVRMTG9hZGVyO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuICB2YXIgSGFtbWVyID0gcmVxdWlyZSgnaGFtbWVyanMnKTtcclxuXHJcbiAgdmFyIGluc3RhbmNlID0ge30sIGhhbW1lcnRpbWUsIGNhbSwgY2FtQW5jaG9yLCBtaW5aID0gMDtcclxuICB2YXIgc3dpbmdYID0gMCwgc3dpbmdZID0gMCwgd2FzTW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgaW5zdGFuY2UuaW5pdCA9IGZ1bmN0aW9uKGNhbWVyYSwgY2FtZXJhQW5jaG9yLCBtaW5DYW1aKSB7XHJcbiAgICB2YXIgaGFtbWVydGltZSA9IG5ldyBIYW1tZXIoZG9jdW1lbnQuYm9keSwge30pO1xyXG5cclxuICAgIGNhbSA9IGNhbWVyYTtcclxuICAgIGNhbUFuY2hvciA9IGNhbWVyYUFuY2hvcjtcclxuICAgIG1pblogPSBtaW5DYW1aO1xyXG5cclxuICAgIGhhbW1lcnRpbWUuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcclxuXHJcbiAgICBoYW1tZXJ0aW1lLm9uKCdwYW4nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHZhciB0dXJuWSA9IE1hdGguUEkgKiAwLjAyICogKGUuZGVsdGFYIC8gd2luZG93LmlubmVyV2lkdGgpLFxyXG4gICAgICAgICAgdHVyblggPSBNYXRoLlBJICogMC4wMiAqIChlLmRlbHRhWSAvIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcblxyXG4gICAgICBpZihjYW1BbmNob3IpIHtcclxuICAgICAgICBjYW1BbmNob3Iucm90YXRpb24ueSArPSB0dXJuWTtcclxuICAgICAgICBjYW1BbmNob3Iucm90YXRpb24ueCArPSB0dXJuWDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYW0ucm90YXRpb24ueSArPSB0dXJuWTtcclxuICAgICAgICBjYW0ucm90YXRpb24ueCArPSB0dXJuWDtcclxuICAgICAgfVxyXG4gICAgICBzd2luZ1ggPSB0dXJuWDtcclxuICAgICAgc3dpbmdZID0gdHVyblk7XHJcblxyXG4gICAgICB3YXNNb3ZlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBoYW1tZXJ0aW1lLm9uKCdwaW5jaG1vdmUnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmKGUuc2NhbGUgPj0gMS4wICYmIGNhbWVyYS5wb3NpdGlvbi56IDw9IG1pblopIHJldHVybjtcclxuXHJcbiAgICAgIGNhbWVyYS50cmFuc2xhdGVaKDEgLSBlLnNjYWxlIC8gMik7XHJcbiAgICAgIHdhc01vdmVkID0gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYoZS53aGVlbERlbHRhKSB7IC8vIENocm9tZVxyXG4gICAgICAgIGNhbWVyYS5wb3NpdGlvbi56IC09IGUud2hlZWxEZWx0YSAvIDEyMDtcclxuICAgICAgfSBlbHNlIHsgLy8gSUUgLyBGaXJlZm94XHJcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogLT0gTWF0aC5taW4oLTUsIE1hdGgubWF4KGUuZGVsdGFZLCA1KSk7XHJcbiAgICAgIH1cclxuICAgICAgd2FzTW92ZWQgPSB0cnVlO1xyXG4gICAgfSlcclxuICB9O1xyXG5cclxuICBpbnN0YW5jZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKCFjYW1BbmNob3IpIGNhbUFuY2hvciA9IGNhbTtcclxuXHJcbiAgICBpZihzd2luZ1ggIT0gMCkge1xyXG4gICAgICBjYW1BbmNob3Iucm90YXRpb24ueCArPSBzd2luZ1g7XHJcbiAgICAgIGlmKHN3aW5nWCA8IC0wLjAwMSkge1xyXG4gICAgICAgIHN3aW5nWCArPSAwLjAwMTtcclxuICAgICAgfSBlbHNlIGlmKHN3aW5nWCA+IDAuMDAxKSB7XHJcbiAgICAgICAgc3dpbmdYIC09IDAuMDAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN3aW5nWCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZihzd2luZ1kgIT0gMCkge1xyXG4gICAgICBjYW1BbmNob3Iucm90YXRpb24ueSArPSBzd2luZ1k7XHJcbiAgICAgIGlmKHN3aW5nWSA8IC0wLjAwMSkge1xyXG4gICAgICAgIHN3aW5nWSArPSAwLjAwMTtcclxuICAgICAgfSBlbHNlIGlmKHN3aW5nWSA+IDAuMDAxKSB7XHJcbiAgICAgICAgc3dpbmdZIC09IDAuMDAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN3aW5nWSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpbnN0YW5jZS53YXNNb3ZlZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2FzTW92ZWQ7IH07XHJcblxyXG4gIHJldHVybiBpbnN0YW5jZTtcclxufSkoKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGxvYWRpbmcgPSB0cnVlLCBjb250YWluZXI7XHJcblxyXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbihlbGVtLCBpbWdVcmwpIHtcclxuICAgIGNvbnRhaW5lciA9IGVsZW07XHJcblxyXG4gICAgaWYoaW1nVXJsKSB7XHJcbiAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgaW1nLnNyYyA9IGltZ1VybDtcclxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGltZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgIGxvYWRpbmcgPSBmYWxzZTtcclxuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufSkoKTtcclxuIiwidmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKSxcclxuICAgIFdvcmxkID0gcmVxdWlyZSgndGhyZWUtd29ybGQnKSxcclxuICAgIE9iakxvYWRlciA9IHJlcXVpcmUoJy4vT0JKTVRMTG9hZGVyJyksXHJcbiAgICBMb2FkaW5nID0gcmVxdWlyZSgnLi9sb2FkaW5nJyksXHJcbiAgICBDb250cm9scyA9IHJlcXVpcmUoJy4va2luZXRpYy1jb250cm9scycpO1xyXG5cclxuTG9hZGluZy5zdGFydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmdcIikpO1xyXG5cclxuV29ybGQuaW5pdCh7IGNhbURpc3RhbmNlOiAwLCBjbGVhckNvbG9yOiAweGZmZmZmZiB9KTtcclxuV29ybGQuc3RhcnRSZW5kZXJMb29wKCk7XHJcbkNvbnRyb2xzLmluaXQoV29ybGQuZ2V0Q2FtZXJhKCkpO1xyXG5cclxudmFyIGxvYWRlciA9IG5ldyBPYmpMb2FkZXIoKSwgbWVzaCwgYW5jaG9yLCBjYW0gPSBXb3JsZC5nZXRDYW1lcmEoKTtcclxuXHJcbmNhbS5yb3RhdGlvbi5vcmRlciA9ICdZWFonO1xyXG5cclxudmFyIHNjcmVlbiA9IG5ldyBUSFJFRS5NZXNoKFxyXG4gIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgwLjUsIDIuMiwgMi4yKSxcclxuICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe21hcDogVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZShcImZ1Y2t5ZWEucG5nXCIpIH0pXHJcbik7XHJcbnNjcmVlbi5wb3NpdGlvbi5zZXQoMC43LCAxLjIsIDApO1xyXG5cclxuYW5jaG9yID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5sb2FkZXIubG9hZCgnbW9kZWwvVFYyLm9iaicsICdtb2RlbC9UVjIubXRsJywgZnVuY3Rpb24odHYpIHtcclxuICB0di5yb3RhdGlvbi5zZXQoMCwgLU1hdGguUEkvMiwgMCk7XHJcbiAgdHYuc2NhbGUuc2V0KDE4LCAxOCwgMTgpO1xyXG4gIHR2LmNoaWxkcmVuWzhdLm1hdGVyaWFsLm9wYWNpdHkgPSAwLjI1O1xyXG4gIHR2LmNoaWxkcmVuWzhdLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICB0di5jaGlsZHJlbls4XS5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgdHYuYWRkKHNjcmVlbik7XHJcblxyXG4gIGZvcih2YXIgc2lkZT0wOyBzaWRlPDQ7IHNpZGUrKykge1xyXG4gICAgdmFyIHNpZGVBbmNob3IgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuICAgIGZvcih2YXIgaT0wOyBpPDEwMDsgaSsrKSB7XHJcbiAgICAgIHZhciB0bXAgPSB0di5jbG9uZSgpO1xyXG4gICAgICB0bXAucG9zaXRpb24uc2V0KC0yNTAgKyAoaSAlIDEwKSAqIDUwLCAtMjUwICsgTWF0aC5mbG9vcihpIC8gMTApICogNTAsIC0yNzUgKTtcclxuICAgICAgc2lkZUFuY2hvci5hZGQodG1wKTtcclxuICAgIH1cclxuICAgIHNpZGVBbmNob3Iucm90YXRpb24ueSA9IHNpZGUgKiAoTWF0aC5QSS8yKTtcclxuICAgIGFuY2hvci5hZGQoc2lkZUFuY2hvcik7XHJcbiAgfVxyXG4gIExvYWRpbmcuc3RvcCgpO1xyXG5cclxufSk7XHJcbldvcmxkLmFkZChhbmNob3IpO1xyXG5cclxuLypcclxuc2V0VGltZW91dChmdW5jdGlvbiBhZGRTY2FuKCkge1xyXG4gIHZhciBzZXJ2aWNlID0gWydzc2gnLCAnaHR0cCcsICdmdHAnXVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKV07XHJcbiAgdmFyIHNjYW5Cb3ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgU0VSVklDRVNbc2VydmljZV0pO1xyXG4gIHNjYW5Cb3gucG9zaXRpb24uc2V0KC01MCArIDEyICogKGN1cnJlbnRJbmRleCAlIDEwKSwgLTUwICsgMTIgKiBNYXRoLmZsb29yKGN1cnJlbnRJbmRleCAvIDEwKSwgMCk7XHJcbiAgYW5jaG9yLmFkZChzY2FuQm94KTtcclxuICBjdXJyZW50SW5kZXggPSArK2N1cnJlbnRJbmRleCAlIDEwMDtcclxuICBzZXRUaW1lb3V0KGFkZFNjYW4sIE1hdGgucmFuZG9tKCkgKiA1MDApO1xyXG59LCAxMDApO1xyXG4qL1xyXG4iLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC40IC0gMjAxNC0wOS0yOFxyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9yaWsgVGFuZ2VsZGVyO1xyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cclxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01TJywgJ21zJywgJ28nXTtcclxudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xyXG5cclxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxudmFyIGFicyA9IE1hdGguYWJzO1xyXG52YXIgbm93ID0gRGF0ZS5ub3c7XHJcblxyXG4vKipcclxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XHJcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxyXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcclxuICogQHBhcmFtIHtTdHJpbmd9IGZuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XHJcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICovXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XHJcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcclxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGV4dGVuZCBvYmplY3QuXHJcbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlXVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxyXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xyXG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xyXG59XHJcblxyXG4vKipcclxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxyXG4gKi9cclxuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xyXG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXHJcbiAgICAgICAgY2hpbGRQO1xyXG5cclxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xyXG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XHJcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XHJcblxyXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICBleHRlbmQoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cclxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xyXG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxyXG4gKiBAcGFyYW0geyp9IHZhbDFcclxuICogQHBhcmFtIHsqfSB2YWwyXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xyXG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXHJcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xyXG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcclxuICogQG1ldGhvZCBoYXNQYXJlbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcclxuICovXHJcbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXHJcbiAqL1xyXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcclxuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xyXG59XHJcblxyXG4vKipcclxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcclxuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XHJcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xyXG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xyXG59XHJcblxyXG4vKipcclxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxyXG4gKi9cclxuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcclxuICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xyXG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvcnQpIHtcclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcclxuICovXHJcbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcclxuICAgIHZhciBwcmVmaXgsIHByb3A7XHJcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xyXG5cclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xyXG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcclxuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgdW5pcXVlIGlkXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXHJcbiAqL1xyXG52YXIgX3VuaXF1ZUlkID0gMTtcclxuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xyXG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyk7XHJcbn1cclxuXHJcbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XHJcblxyXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xyXG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XHJcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xyXG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcclxudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xyXG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcclxuXHJcbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XHJcblxyXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xyXG52YXIgSU5QVVRfTU9WRSA9IDI7XHJcbnZhciBJTlBVVF9FTkQgPSA0O1xyXG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcclxuXHJcbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XHJcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XHJcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xyXG52YXIgRElSRUNUSU9OX1VQID0gODtcclxudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XHJcblxyXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcclxudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xyXG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xyXG5cclxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcclxudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XHJcblxyXG4vKipcclxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqIEByZXR1cm5zIHtJbnB1dH1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xyXG5cclxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxyXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxyXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xyXG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcblxyXG59XHJcblxyXG5JbnB1dC5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYmluZCB0aGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXHJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxyXG4gKiBAcmV0dXJucyB7SW5wdXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcclxuICAgIHZhciBUeXBlO1xyXG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcclxuXHJcbiAgICBpZiAoaW5wdXRDbGFzcykge1xyXG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xyXG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XHJcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xyXG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcclxuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcclxuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcclxuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcclxuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcclxuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XHJcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcclxuXHJcbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xyXG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcclxuXHJcbiAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXHJcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcclxuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcclxuXHJcbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcclxuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xyXG5cclxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XHJcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcclxuXHJcbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XHJcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xyXG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XHJcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcclxuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXHJcbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xyXG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXHJcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcclxuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XHJcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XHJcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcclxuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcclxuXHJcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcclxuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xyXG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XHJcblxyXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XHJcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcclxuXHJcbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XHJcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xyXG5cclxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XHJcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xyXG5cclxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XHJcblxyXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcclxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XHJcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xyXG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcclxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XHJcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcclxuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcclxuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcclxuXHJcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcclxuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcclxuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxyXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xyXG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgICAgICAgeTogY2VudGVyLnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xyXG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcclxuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcclxuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXHJcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXHJcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XHJcblxyXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHZhciBkZWx0YVggPSBsYXN0LmRlbHRhWCAtIGlucHV0LmRlbHRhWDtcclxuICAgICAgICB2YXIgZGVsdGFZID0gbGFzdC5kZWx0YVkgLSBpbnB1dC5kZWx0YVk7XHJcblxyXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xyXG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcclxuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcclxuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xyXG5cclxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXHJcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xyXG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xyXG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XHJcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XHJcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XHJcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcclxuICovXHJcbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XHJcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcclxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xyXG4gICAgdmFyIHBvaW50ZXJzID0gW107XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xyXG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcclxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXHJcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxyXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcclxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcclxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcclxuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XHJcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XHJcblxyXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcclxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxyXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XHJcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xyXG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxyXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcclxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XHJcbiAgICBpZiAoeCA9PT0geSkge1xyXG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xyXG4gICAgICAgIHJldHVybiB4ID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cclxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcclxuICAgIH1cclxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxyXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcclxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcclxuICAgIH1cclxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxyXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcclxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSAtIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXHJcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xyXG59XHJcblxyXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xyXG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcclxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcclxuICAgIG1vdXNldXA6IElOUFVUX0VORFxyXG59O1xyXG5cclxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XHJcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcclxuXHJcbi8qKlxyXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xyXG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcclxuXHJcbiAgICB0aGlzLmFsbG93ID0gdHJ1ZTsgLy8gdXNlZCBieSBJbnB1dC5Ub3VjaE1vdXNlIHRvIGRpc2FibGUgbW91c2UgZXZlbnRzXHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXHJcblxyXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcclxuXHJcbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcclxuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXHJcbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQgfHwgIXRoaXMuYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXHJcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcclxuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcclxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxyXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXHJcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXHJcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcclxufTtcclxuXHJcbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXHJcbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xyXG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcclxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxyXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcclxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxyXG59O1xyXG5cclxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xyXG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcclxuXHJcbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxyXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XHJcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xyXG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xyXG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcclxufVxyXG5cclxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcclxuICAgIC8qKlxyXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xyXG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XHJcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xyXG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xyXG5cclxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcclxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xyXG5cclxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcclxuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcclxuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xyXG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxyXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxyXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxyXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xyXG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXHJcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXHJcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxyXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xyXG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG5cclxuLyoqXHJcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XHJcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XHJcblxyXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cclxuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxyXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHRoaXMge1RvdWNoSW5wdXR9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XHJcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcclxuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XHJcblxyXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xyXG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xyXG59XHJcblxyXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xyXG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXHJcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXHJcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxyXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG5cclxuLyoqXHJcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xyXG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XHJcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xyXG4gICAgICAgIGlmICghdG91Y2hlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcclxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xyXG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xyXG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xyXG5cclxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXHJcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcclxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxyXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xyXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcclxuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcclxuICAgIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcclxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xyXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcclxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xyXG4gICAgXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxyXG4gKlxyXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cclxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcclxuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xyXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XHJcbn1cclxuXHJcbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XHJcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxyXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIG1vc3QgbW9iaWxlIGJyb3dzZXIgYWxzbyBlbWl0IG1vdXNlZXZlbnRzLCByaWdodCBhZnRlciB0b3VjaHN0YXJ0XHJcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiAhdGhpcy5tb3VzZS5hbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNldCB0aGUgYWxsb3dNb3VzZSB3aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2UuYWxsb3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XHJcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XHJcblxyXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXHJcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcclxudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xyXG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcclxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcclxudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XHJcblxyXG4vKipcclxuICogVG91Y2ggQWN0aW9uXHJcbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuc2V0KHZhbHVlKTtcclxufVxyXG5cclxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcclxuICAgICAqL1xyXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcclxuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAgICAgKi9cclxuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICAvLyBub3QgbmVlZGVkIHdpdGggbmF0aXZlIHN1cHBvcnQgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eVxyXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxyXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XHJcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSk7XHJcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc05vbmUgfHxcclxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XHJcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XHJcbiAgICAgKi9cclxuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcclxuICAgIC8vIG5vbmVcclxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG5cclxuICAgIC8vIHBhbi14IGFuZCBwYW4teSBjYW4gYmUgY29tYmluZWRcclxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX1BBTl9YICsgJyAnICsgVE9VQ0hfQUNUSU9OX1BBTl9ZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBhbi14IE9SIHBhbi15XHJcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFuaXB1bGF0aW9uXHJcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXHJcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXHJcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxyXG4gKlxyXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXHJcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXHJcbiAqXHJcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cclxuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cclxuICpcclxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxyXG4gKiAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xyXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcclxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxyXG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxyXG4gKi9cclxudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcclxudmFyIFNUQVRFX0JFR0FOID0gMjtcclxudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xyXG52YXIgU1RBVEVfRU5ERUQgPSA4O1xyXG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xyXG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XHJcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcclxuXHJcbi8qKlxyXG4gKiBSZWNvZ25pemVyXHJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcclxuXHJcbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXHJcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xyXG5cclxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XHJcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XHJcbn1cclxuXHJcblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcclxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XHJcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xyXG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcclxuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XHJcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcclxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcclxuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZW1pdCh3aXRoU3RhdGUpIHtcclxuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgKHdpdGhTdGF0ZSA/IHN0YXRlU3RyKHN0YXRlKSA6ICcnKSwgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXHJcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcclxuICAgICAgICAgICAgZW1pdCh0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVtaXQoKTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xyXG5cclxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxyXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgICAgICBlbWl0KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXHJcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXHJcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcclxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbiB3ZSBlbWl0P1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XHJcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcclxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xyXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGV4dGVuZCh7fSwgaW5wdXREYXRhKTtcclxuXHJcbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XHJcbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XHJcblxyXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxyXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxyXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXHJcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcclxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcclxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcclxuICovXHJcbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XHJcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcclxuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcclxuICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xyXG4gICAgICAgIHJldHVybiAnbW92ZSc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcclxuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xyXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcclxuICAgICAgICByZXR1cm4gJ2Rvd24nO1xyXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XHJcbiAgICAgICAgcmV0dXJuICd1cCc7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xyXG4gICAgICAgIHJldHVybiAnbGVmdCc7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcclxuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXHJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XHJcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcclxuICAgIGlmIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XHJcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG9pbnRlcnM6IDFcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcclxuICAgICAqL1xyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcclxuXHJcbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XHJcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcclxuXHJcbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxyXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFBhblxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMucFggPSBudWxsO1xyXG4gICAgdGhpcy5wWSA9IG51bGw7XHJcbn1cclxuXHJcbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3BhbicsXHJcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWN0aW9ucztcclxuICAgIH0sXHJcblxyXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XHJcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XHJcblxyXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cclxuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcclxuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XHJcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQaW5jaFxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xyXG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3BpbmNoJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgICAgcG9pbnRlcnM6IDJcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcclxuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcclxuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dCwgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUHJlc3NcclxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XHJcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG59XHJcblxyXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXHJcbiAgICAgICAgcG9pbnRlcnM6IDEsXHJcbiAgICAgICAgdGltZTogNTAwLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxyXG4gICAgICAgIHRocmVzaG9sZDogNSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xyXG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblxyXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XHJcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxyXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcclxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVcclxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xyXG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgICAgcG9pbnRlcnM6IDJcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogU3dpcGVcclxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMTAsXHJcbiAgICAgICAgdmVsb2NpdHk6IDAuNjUsXHJcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcclxuICAgICAgICBwb2ludGVyczogMVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciB2ZWxvY2l0eTtcclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlYO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0LmRpcmVjdGlvbiAmJlxyXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcclxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcclxuICogYSBzaW5nbGUgdGFwLlxyXG4gKlxyXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcclxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXHJcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcclxuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcclxuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG59XHJcblxyXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAndGFwJyxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICB0YXBzOiAxLFxyXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXHJcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxyXG4gICAgICAgIHRocmVzaG9sZDogMiwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcclxuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xyXG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcclxuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHJcbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxyXG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcclxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcclxuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcclxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cclxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcclxuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xyXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhbiBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xyXG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtzdHJpbmd9XHJcbiAqL1xyXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNCc7XHJcblxyXG4vKipcclxuICogZGVmYXVsdCBzZXR0aW5nc1xyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5IYW1tZXIuZGVmYXVsdHMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBkb21FdmVudHM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXHJcbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXHJcbiAgICAgKi9cclxuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBlbmFibGU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXHJcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cclxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXHJcbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xyXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIGlucHV0Q2xhc3M6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcclxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHByZXNldDogW1xyXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxyXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfV0sXHJcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH0sIFsncm90YXRlJ11dLFxyXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIseyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH1dLFxyXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfSwgWydzd2lwZSddXSxcclxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXHJcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dLFxyXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cclxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqL1xyXG4gICAgY3NzUHJvcHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cclxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcclxuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcclxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgU1RPUCA9IDE7XHJcbnZhciBGT1JDRURfU1RPUCA9IDI7XHJcblxyXG4vKipcclxuICogTWFuYWdlclxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIEhhbW1lci5kZWZhdWx0cyk7XHJcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHJcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XHJcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcclxuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XHJcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XHJcblxyXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgZWFjaChvcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcclxuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcclxuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxuTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXHJcbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxyXG4gICAgICovXHJcbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcclxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcclxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxyXG4gICAgICovXHJcbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xyXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xyXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcjtcclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG5cclxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cclxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXHJcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxyXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xyXG5cclxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxyXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxyXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcclxuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxyXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcclxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXHJcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxyXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cclxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXHJcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxyXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXHJcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxyXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxyXG4gICAgICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcclxuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcclxuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplciksIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGJpbmQgZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XHJcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XHJcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xyXG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xyXG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcclxuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXHJcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxyXG4gICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XHJcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcclxuICovXHJcbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XHJcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBlbGVtZW50LnN0eWxlW3ByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpXSA9IGFkZCA/IHZhbHVlIDogJyc7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XHJcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcclxuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcclxuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcclxufVxyXG5cclxuZXh0ZW5kKEhhbW1lciwge1xyXG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxyXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcclxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxyXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXHJcblxyXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxyXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxyXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcclxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcclxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXHJcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcclxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxyXG5cclxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcclxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcclxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxyXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXHJcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXHJcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXHJcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcclxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXHJcblxyXG4gICAgTWFuYWdlcjogTWFuYWdlcixcclxuICAgIElucHV0OiBJbnB1dCxcclxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcclxuXHJcbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxyXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcclxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcclxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxyXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcclxuXHJcbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxyXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxyXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxyXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxyXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcclxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXHJcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXHJcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxyXG5cclxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcclxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXHJcbiAgICBlYWNoOiBlYWNoLFxyXG4gICAgbWVyZ2U6IG1lcmdlLFxyXG4gICAgZXh0ZW5kOiBleHRlbmQsXHJcbiAgICBpbmhlcml0OiBpbmhlcml0LFxyXG4gICAgYmluZEZuOiBiaW5kRm4sXHJcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcclxufSk7XHJcblxyXG5pZiAodHlwZW9mIGRlZmluZSA9PSBUWVBFX0ZVTkNUSU9OICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gSGFtbWVyO1xyXG4gICAgfSk7XHJcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XHJcbn0gZWxzZSB7XHJcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XHJcbn1cclxuXHJcbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcclxuIiwidmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcclxuXHJcbnZhciBXb3JsZCA9IChmdW5jdGlvbigpIHtcclxuICAvLyBJbnRlcm5hbHNcclxuXHJcbiAgdmFyIGNhbWVyYSwgc2NlbmUsIHJlbmRlcmVyLCBmcmFtZUNhbGxiYWNrLCBzZWxmID0ge307XHJcblxyXG4gIGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgIGlmKGZyYW1lQ2FsbGJhY2spIGZyYW1lQ2FsbGJhY2soKTtcclxuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xyXG4gIH1cclxuXHJcblx0ZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XHJcblxyXG5cdFx0Y2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xyXG5cdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcbiAgLy8gRXhwb3J0c1xyXG5cclxuICBzZWxmLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDEsIG9wdGlvbnMuZmFyUGxhbmUgfHwgMjAwMCk7XHJcbiAgICBjYW1lcmEucG9zaXRpb24ueiA9IG9wdGlvbnMuY2FtRGlzdGFuY2UgfHwgMTAwO1xyXG4gICAgZnJhbWVDYWxsYmFjayA9IG9wdGlvbnMucmVuZGVyQ2FsbGJhY2s7XHJcblxyXG4gICAgLy8gc2NlbmVcclxuXHJcbiAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xyXG5cclxuICAgIHZhciBhbWJpZW50ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodChvcHRpb25zLmFtYmllbnRMaWdodENvbG9yIHx8IDB4ZmZmZmZmKTtcclxuICAgIHNjZW5lLmFkZChhbWJpZW50KTtcclxuXHJcbiAgICByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKG9wdGlvbnMucmVuZGVyZXJPcHRzKTtcclxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICBpZihvcHRpb25zLmNsZWFyQ29sb3IpIHJlbmRlcmVyLnNldENsZWFyQ29sb3Iob3B0aW9ucy5jbGVhckNvbG9yKTtcclxuXHJcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplLCBmYWxzZSApO1xyXG4gIH1cclxuXHJcbiAgc2VsZi5hZGQgPSBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgIHNjZW5lLmFkZChvYmplY3QpO1xyXG4gIH1cclxuXHJcbiAgc2VsZi5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbigpIHtcclxuICAgIHJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgc2VsZi5nZXRDYW1lcmEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNhbWVyYTsgfTtcclxuXHJcbiAgcmV0dXJuIHNlbGY7XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xyXG4iLCJ2YXIgc2VsZiA9IHNlbGYgfHwge307Ly8gRmlsZTpzcmMvVGhyZWUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBUSFJFRSA9IHsgUkVWSVNJT046ICc2OScgfTtcblxuLy8gYnJvd3NlcmlmeSBzdXBwb3J0XG5cbmlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcblxufVxuXG4vLyBwb2x5ZmlsbHNcblxuaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6IDA7XG5cblx0fTtcblxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cblxuVEhSRUUuTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIgfTtcblxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXG5cblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XG5cblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cbi8vIFNIQURPV0lORyBUWVBFU1xuXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XG5cbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xuXG4vLyBzaWRlXG5cblRIUkVFLkZyb250U2lkZSA9IDA7XG5USFJFRS5CYWNrU2lkZSA9IDE7XG5USFJFRS5Eb3VibGVTaWRlID0gMjtcblxuLy8gc2hhZGluZ1xuXG5USFJFRS5Ob1NoYWRpbmcgPSAwO1xuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XG5cbi8vIGNvbG9yc1xuXG5USFJFRS5Ob0NvbG9ycyA9IDA7XG5USFJFRS5GYWNlQ29sb3JzID0gMTtcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XG5cbi8vIGJsZW5kaW5nIG1vZGVzXG5cblRIUkVFLk5vQmxlbmRpbmcgPSAwO1xuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5USFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxuLy8gIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxuXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5USFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcblRIUkVFLk1pbkVxdWF0aW9uID0gMTAzO1xuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBkZXN0aW5hdGlvbiBmYWN0b3JzXG5cblRIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG5USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcblRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcblRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBzb3VyY2UgZmFjdG9yc1xuXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG4vL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcbi8vVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG4vL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuLy9USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcblxuXG4vLyBURVhUVVJFIENPTlNUQU5UU1xuXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcblxuLy8gTWFwcGluZyBtb2Rlc1xuXG5USFJFRS5VVk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFdyYXBwaW5nIG1vZGVzXG5cblRIUkVFLlJlcGVhdFdyYXBwaW5nID0gMTAwMDtcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5cbi8vIEZpbHRlcnNcblxuVEhSRUUuTmVhcmVzdEZpbHRlciA9IDEwMDM7XG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcblRIUkVFLkxpbmVhckZpbHRlciA9IDEwMDY7XG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcblRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5cbi8vIERhdGEgdHlwZXNcblxuVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XG5USFJFRS5TaG9ydFR5cGUgPSAxMDExO1xuVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuVEhSRUUuSW50VHlwZSA9IDEwMTM7XG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuVEhSRUUuRmxvYXRUeXBlID0gMTAxNTtcblxuLy8gUGl4ZWwgdHlwZXNcblxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XG5USFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE3O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xuXG4vLyBQaXhlbCBmb3JtYXRzXG5cblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcblRIUkVFLlJHQkZvcm1hdCA9IDEwMjA7XG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XG5USFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjM7XG5cbi8vIEREUyAvIFNUM0MgQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcblRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xuXG5cbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXG5cblRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XG5USFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xuXG5cbi8vIEZpbGU6c3JjL21hdGgvQ29sb3IuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoIGFyZ3VtZW50c1sgMCBdLCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXMuc2V0KCBjb2xvciApXG5cbn07XG5cblRIUkVFLkNvbG9yLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXG5cblx0cjogMSwgZzogMSwgYjogMSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuXHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xuXG5cdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcblx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XG5cblx0XHR0aGlzLnIgPSByO1xuXHRcdHRoaXMuZyA9IGc7XG5cdFx0dGhpcy5iID0gYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0aWYgKCBzID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGh1ZTJyZ2IgPSBmdW5jdGlvbiAoIHAsIHEsIHQgKSB7XG5cblx0XHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcblx0XHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcblx0XHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xuXHRcdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuXHRcdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XG5cdFx0XHRcdHJldHVybiBwO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuXHRcdFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG5cdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcblx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcblxuXHRcdC8vIHJnYigyNTUsMCwwKVxuXG5cdFx0aWYgKCAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS5leGVjKCBzdHlsZSApO1xuXG5cdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuXHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmdiKDEwMCUsMCUsMCUpXG5cblx0XHRpZiAoIC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLnRlc3QoIHN0eWxlICkgKSB7XG5cblx0XHRcdHZhciBjb2xvciA9IC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLmV4ZWMoIHN0eWxlICk7XG5cblx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuXHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHQvLyAjZmYwMDAwXG5cblx0XHRpZiAoIC9eXFwjKFswLTlhLWZdezZ9KSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXXs2fSkkL2kuZXhlYyggc3R5bGUgKTtcblxuXHRcdFx0dGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxNiApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gI2YwMFxuXG5cdFx0aWYgKCAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS5leGVjKCBzdHlsZSApO1xuXG5cdFx0XHR0aGlzLnNldEhleCggcGFyc2VJbnQoIGNvbG9yWyAxIF0gKyBjb2xvclsgMSBdICsgY29sb3JbIDIgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMyBdICsgY29sb3JbIDMgXSwgMTYgKSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdC8vIHJlZFxuXG5cdFx0aWYgKCAvXihcXHcrKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR0aGlzLnNldEhleCggVEhSRUUuQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XG5cdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnIgKiBjb2xvci5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yLmcgKiBjb2xvci5nO1xuXHRcdHRoaXMuYiA9IGNvbG9yLmIgKiBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggY29sb3IuciApO1xuXHRcdHRoaXMuZyA9IE1hdGguc3FydCggY29sb3IuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggY29sb3IuYiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cblx0XHR0aGlzLnIgPSByICogcjtcblx0XHR0aGlzLmcgPSBnICogZztcblx0XHR0aGlzLmIgPSBiICogYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcblx0XHR0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRIZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xuXG5cdH0sXG5cblx0Z2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XG5cblx0fSxcblxuXHRnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcblx0XHR2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XG5cdFx0dmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XG5cblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG5cdFx0XHRodWUgPSAwO1xuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcblxuXHRcdFx0c3dpdGNoICggbWF4ICkge1xuXG5cdFx0XHRcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGh1ZSAvPSA2O1xuXG5cdFx0fVxuXG5cdFx0aHNsLmggPSBodWU7XG5cdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xuXHRcdGhzbC5sID0gbGlnaHRuZXNzO1xuXG5cdFx0cmV0dXJuIGhzbDtcblxuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xuXG5cdH0sXG5cblx0b2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcblxuXHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XG5cblx0XHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgKz0gY29sb3Iucjtcblx0XHR0aGlzLmcgKz0gY29sb3IuZztcblx0XHR0aGlzLmIgKz0gY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcblx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy5yICs9IHM7XG5cdFx0dGhpcy5nICs9IHM7XG5cdFx0dGhpcy5iICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnIgKj0gcztcblx0XHR0aGlzLmcgKj0gcztcblx0XHR0aGlzLmIgKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLnIgPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuZyA9IGFycmF5WyAxIF07XG5cdFx0dGhpcy5iID0gYXJyYXlbIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIFsgdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiBdO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcbidiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcbidicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuJ2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG4nZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcbidkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuJ2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG4naW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuJ2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuJ2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcbidsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcbidtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuJ25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuJ3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4Rixcbidyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG4nc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuJ3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcblxuLy8gRmlsZTpzcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufTtcblxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlF1YXRlcm5pb24sXG5cblx0X3g6IDAsX3k6IDAsIF96OiAwLCBfdzogMCxcblxuXHRnZXQgeCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9LFxuXG5cdHNldCB4ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeSAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9LFxuXG5cdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9LFxuXG5cdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgdyAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9LFxuXG5cdHNldCB3ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl93ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblx0XHR9XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHR2YXIgYzEgPSBNYXRoLmNvcyggZXVsZXIuX3ggLyAyICk7XG5cdFx0dmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcblx0XHR2YXIgczEgPSBNYXRoLnNpbiggZXVsZXIuX3ggLyAyICk7XG5cdFx0dmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcblxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuXHRcdFx0cztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0dmFyIHYxLCByO1xuXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRcdGlmICggciA8IEVQUyApIHtcblxuXHRcdFx0XHRyID0gMDtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdFx0djEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5feCA9IHYxLng7XG5cdFx0XHR0aGlzLl95ID0gdjEueTtcblx0XHRcdHRoaXMuX3ogPSB2MS56O1xuXHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0aWYgKCBsID09PSAwICkge1xuXG5cdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHR0aGlzLl93ID0gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGwgPSAxIC8gbDtcblxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuXHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuXG5cdH0sXG5cblx0c2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XG5cblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcblx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuXHRcdHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XG5cdFx0XHR0aGlzLl95ID0gLSBxYi5feTtcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xuXG5cdFx0XHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29weSggcWIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHc7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cblx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG5cdFx0XHR0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xuXHRcdFx0dGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcblx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG5cdFx0XHR0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cblx0cmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cbn1cblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy54ICo9IHM7XG5cdFx0dGhpcy55ICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0aWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cblx0XHRcdHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG5cdFx0XHR0aGlzLnggKj0gaW52U2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IGludlNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcblxuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGlmICggdGhpcy54IDwgdi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA8IHYueSApIHtcblxuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1pbi55O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1heC55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpLFxuXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XG5cblx0XHR2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuXHRcdFx0dGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHRoaXMueCwgdGhpcy55ICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cdFx0dmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcblxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF0gKSAqIGQ7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiBkO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIHF4ID0gcS54O1xuXHRcdHZhciBxeSA9IHEueTtcblx0XHR2YXIgcXogPSBxLno7XG5cdFx0dmFyIHF3ID0gcS53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHR2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1hdHJpeDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggLz0gdi54O1xuXHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0dGhpcy56IC89IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xuXG5cdFx0XHR2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gaW52U2NhbGFyO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHR0aGlzLnogPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcblxuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnogPiB2LnogKSB7XG5cblx0XHRcdHRoaXMueiA9IHYuejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuXHRcdGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cblx0XHRcdHRoaXMueCA9IG1pbi54O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cblx0XHRcdHRoaXMueCA9IG1heC54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuXHRcdFx0dGhpcy55ID0gbWluLnk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueiA8IG1pbi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSBtaW4uejtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueiA+IG1heC56ICkge1xuXG5cdFx0XHR0aGlzLnogPSBtYXguejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKSxcblxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggICkge1xuXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG5cdFx0dGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XG5cdFx0dGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEsIGRvdDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0ZG90ID0gdGhpcy5kb3QoIHYxICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNvcHkoIHYxICkubXVsdGlwbHlTY2FsYXIoIGRvdCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBsYW5lTm9ybWFsICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuXHRcdH1cblxuXHR9KCksXG5cblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbm9ybWFsICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54O1xuXHRcdHZhciBkeSA9IHRoaXMueSAtIHYueTtcblx0XHR2YXIgZHogPSB0aGlzLnogLSB2Lno7XG5cblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXG5cdH0sXG5cblx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuXG5cdH0sXG5cblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xuXG5cdH0sXG5cblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG5cblx0fSxcblxuXHRnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcblx0fSxcblxuXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XG5cdFx0dGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcblx0XHR0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgIDIgXSApLmxlbmd0aCgpO1xuXHRcdHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgIDYgXSApLmxlbmd0aCgpO1xuXHRcdHZhciBzeiA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA4IF0sIG0uZWxlbWVudHNbIDkgXSwgbS5lbGVtZW50c1sgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHR2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gbWVbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3I0LmpzXG5cbi8qKlxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yNCxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXHRcdHRoaXMudyA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFc6IGZ1bmN0aW9uICggdyApIHtcblxuXHRcdHRoaXMudyA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAzOiB0aGlzLncgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cdFx0dGhpcy53ICs9IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblx0XHR0aGlzLncgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cdFx0dGhpcy53IC09IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblx0XHR0aGlzLncgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXHRcdHZhciB3ID0gdGhpcy53O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xuXHRcdHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xuXG5cdFx0XHR2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gaW52U2NhbGFyO1xuXHRcdFx0dGhpcy53ICo9IGludlNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblx0XHRcdHRoaXMudyA9IDE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG5cdFx0aWYgKCBzIDwgMC4wMDAxICkge1xuXG5cdFx0XHQgdGhpcy54ID0gMTtcblx0XHRcdCB0aGlzLnkgPSAwO1xuXHRcdFx0IHRoaXMueiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQgdGhpcy54ID0gcS54IC8gcztcblx0XHRcdCB0aGlzLnkgPSBxLnkgLyBzO1xuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxuXHRcdCAgICYmICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApXG5cdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXG5cdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcblx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKVxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcblxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblxuXHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XG5cdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xuXG5cdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkgeyAvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeHggPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xuXHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkgeyAvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcblx0XHRcdFx0XHR4ID0geHkgLyB5O1xuXHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgeyAvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXG5cblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xuXHRcdFx0XHRcdHggPSB4eiAvIHo7XG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXG5cdFx0fVxuXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXG5cdFx0XHRcdFx0XHQgICsgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxIClcblx0XHRcdFx0XHRcdCAgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcblxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcblx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0aWYgKCB0aGlzLnggPiB2LnggKSB7XG5cblx0XHRcdHRoaXMueCA9IHYueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55ID4gdi55ICkge1xuXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueiA+IHYueiApIHtcblxuXHRcdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLncgPiB2LncgKSB7XG5cblx0XHRcdHRoaXMudyA9IHYudztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudyA8IHYudyApIHtcblxuXHRcdFx0dGhpcy53ID0gdi53O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1pbi55O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1heC55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnogPCBtaW4ueiApIHtcblxuXHRcdFx0dGhpcy56ID0gbWluLno7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcblxuXHRcdFx0dGhpcy56ID0gbWF4Lno7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudyA8IG1pbi53ICkge1xuXG5cdFx0XHR0aGlzLncgPSBtaW4udztcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMudyA+IG1heC53ICkge1xuXG5cdFx0XHR0aGlzLncgPSBtYXgudztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdH07XG5cblx0fSApKCksXG5cbiAgICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgICAgIHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblx0XHR0aGlzLncgPSAtIHRoaXMudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNCggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdHRoaXMuX3ggPSB4IHx8IDA7XG5cdHRoaXMuX3kgPSB5IHx8IDA7XG5cdHRoaXMuX3ogPSB6IHx8IDA7XG5cdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xuXG59O1xuXG5USFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcblxuVEhSRUUuRXVsZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcblxuXHRfeDogMCwgX3k6IDAsIF96OiAwLCBfb3JkZXI6IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcixcblxuXHRnZXQgeCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9LFxuXG5cdHNldCB4ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeSAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9LFxuXG5cdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9LFxuXG5cdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgb3JkZXIgKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXG5cdH0sXG5cblx0c2V0IG9yZGVyICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcblx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyICkge1xuXG5cdFx0dmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xuXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS8yMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9jb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdHZhciBzcXggPSBxLnggKiBxLng7XG5cdFx0dmFyIHNxeSA9IHEueSAqIHEueTtcblx0XHR2YXIgc3F6ID0gcS56ICogcS56O1xuXHRcdHZhciBzcXcgPSBxLncgKiBxLnc7XG5cblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLncgLSBxLnkgKiBxLnogKSwgKCBzcXcgLSBzcXggLSBzcXkgKyBzcXogKSApO1xuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLnogKyBxLnkgKiBxLncgKSwgLSAxLCAxICkgKTtcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAyICogKCBxLnogKiBxLncgLSBxLnggKiBxLnkgKSwgKCBzcXcgKyBzcXggLSBzcXkgLSBzcXogKSApO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLncgLSBxLnkgKiBxLnogKSwgLSAxLCAxICkgKTtcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLnogKyBxLnkgKiBxLncgKSwgKCBzcXcgLSBzcXggLSBzcXkgKyBzcXogKSApO1xuXHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueSArIHEueiAqIHEudyApLCAoIHNxdyAtIHNxeCArIHNxeSAtIHNxeiApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS54ICogcS53ICsgcS55ICogcS56ICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggMiAqICggcS55ICogcS53IC0gcS56ICogcS54ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAyICogKCBxLnogKiBxLncgLSBxLnggKiBxLnkgKSwgKCBzcXcgLSBzcXggKyBzcXkgLSBzcXogKSApO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS53ICsgcS56ICogcS55ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS55ICogcS53IC0gcS54ICogcS56ICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS55ICsgcS56ICogcS53ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEudyAtIHEueiAqIHEueSApLCAoIHNxdyAtIHNxeCArIHNxeSAtIHNxeiApICk7XG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggMiAqICggcS55ICogcS53IC0gcS54ICogcS56ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS54ICogcS55ICsgcS56ICogcS53ICksIC0gMSwgMSApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLncgKyBxLnkgKiBxLnogKSwgKCBzcXcgLSBzcXggKyBzcXkgLSBzcXogKSApO1xuXHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueiArIHEueSAqIHEudyApLCAoIHNxdyArIHNxeCAtIHNxeSAtIHNxeiApICk7XG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueiAqIHEudyAtIHEueCAqIHEueSApLCAtIDEsIDEgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUXVhdGVybmlvbigpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cblx0XHR2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBuZXdPcmRlciApIHtcblxuXHRcdFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcblx0XHRcdHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XG5cblx0XHR9O1xuXG5cblx0fSgpLFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBbIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyIF07XG5cblx0fSxcblxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5FdWxlciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTGluZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuTGluZTMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcblxuXHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcblx0XHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuXHRcdFx0c3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcblx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG5cdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcblxuXHRcdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcblxuXHRcdFx0XHR0ID0gVEhSRUUuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0O1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cblx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5MaW5lMygpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IyKCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxuXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gSW5maW5pdHk7XG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9LFxuXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG5cdFx0KTtcblxuXHR9LFxuXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94MigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxuXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW5zJywgd29ybGQgdHJhbnNmb3Jtc1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0b2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdLmFycmF5O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0djEuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9LFxuXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcblx0XHQgICAgIHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcblx0XHRcdCAoIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICkgJiYgKCBib3gubWF4LnogPD0gdGhpcy5tYXgueiApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG5cdFx0KTtcblxuXHR9LFxuXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuXHRcdCAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlcigpO1xuXHRcdFx0cmVzdWx0LnJhZGl1cyA9IHRoaXMuc2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpXG5cdFx0XTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0Ly8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcblx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG5cdFx0XHRwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcblx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG5cdFx0XHRwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcblx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxuXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94MygpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblxuXHRcdDEsIDAsIDAsXG5cdFx0MCwgMSwgMCxcblx0XHQwLCAwLCAxXG5cblx0XSApO1xuXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4MyxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMyBdID0gbjEyOyB0ZVsgNiBdID0gbjEzO1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDUgXSA9IG4zMjsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cblx0fSxcblxuXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldCwgaWw7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG5cdFx0XHRcdHYxLnggPSBhcnJheVsgaiBdO1xuXHRcdFx0XHR2MS55ID0gYXJyYXlbIGogKyAxIF07XG5cdFx0XHRcdHYxLnogPSBhcnJheVsgaiArIDIgXTtcblxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuXHRcdFx0XHRhcnJheVsgaiBdICAgICA9IHYxLng7XG5cdFx0XHRcdGFycmF5WyBqICsgMSBdID0gdjEueTtcblx0XHRcdFx0YXJyYXlbIGogKyAyIF0gPSB2MS56O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXG5cdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuXHRcdFx0ZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcblxuXHRcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XG5cblx0fSxcblxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxuXHRcdC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxuXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gICBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcblx0XHR0ZVsgMSBdID0gLSBtZVsgMTAgXSAqIG1lWyAxIF0gKyBtZVsgMiBdICogbWVbIDkgXTtcblx0XHR0ZVsgMiBdID0gICBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xuXHRcdHRlWyAzIF0gPSAtIG1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xuXHRcdHRlWyA0IF0gPSAgIG1lWyAxMCBdICogbWVbIDAgXSAtIG1lWyAyIF0gKiBtZVsgOCBdO1xuXHRcdHRlWyA1IF0gPSAtIG1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XG5cdFx0dGVbIDYgXSA9ICAgbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcblx0XHR0ZVsgNyBdID0gLSBtZVsgOSBdICogbWVbIDAgXSArIG1lWyAxIF0gKiBtZVsgOCBdO1xuXHRcdHRlWyA4IF0gPSAgIG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XG5cblx0XHR2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xuXG5cdFx0Ly8gbm8gaW52ZXJzZVxuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XG5cblx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxLjAgLyBkZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgICAgIF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG5cblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcblx0XHRcdHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXG5cdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG5cdFx0XTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDMoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cblx0XHQxLCAwLCAwLCAwLFxuXHRcdDAsIDEsIDAsIDAsXG5cdFx0MCwgMCwgMSwgMCxcblx0XHQwLCAwLCAwLCAxXG5cblx0XSApO1xuXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuXG5cdH0sXG5cblx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0KCBtZVsgMCBdLCBtZVsgMSBdLCBtZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbIDQgXSwgbWVbIDUgXSwgbWVbIDYgXSApLmxlbmd0aCgpO1xuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXG5cdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcblx0XHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcblx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBhICogZDtcblx0XHRcdHRlWyA2IF0gPSBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gZjtcblx0XHRcdHRlWyA4IF0gPSBkICogZTtcblxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG5cdFx0XHR0ZVsgNiBdID0gYiAqIGU7XG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XG5cdFx0dmFyIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0dmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHR0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xuXHRcdHRlWyA0IF0gPSB4eSAtIHd6O1xuXHRcdHRlWyA4IF0gPSB4eiArIHd5O1xuXG5cdFx0dGVbIDEgXSA9IHh5ICsgd3o7XG5cdFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcblx0XHR0ZVsgOSBdID0geXogLSB3eDtcblxuXHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xuXHRcdHRlWyA2IF0gPSB5eiArIHd4O1xuXHRcdHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHogPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR6LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdGlmICggei5sZW5ndGgoKSA9PT0gMCApIHtcblxuXHRcdFx0XHR6LnogPSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRpZiAoIHgubGVuZ3RoKCkgPT09IDAgKSB7XG5cblx0XHRcdFx0ei54ICs9IDAuMDAwMTtcblx0XHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcblxuXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xuXHRcdFx0dGVbIDEgXSA9IHgueTsgdGVbIDUgXSA9IHkueTsgdGVbIDkgXSA9IHoueTtcblx0XHRcdHRlWyAyIF0gPSB4Lno7IHRlWyA2IF0gPSB5Lno7IHRlWyAxMCBdID0gei56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0sIG4gKSB7XG5cblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcblx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICk7XG5cblx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xuXHRcdHJbIDQgXSA9IHRlWyA0IF07IHJbIDUgXSA9IHRlWyA1IF07IHJbIDYgXSA9IHRlWyA2IF07IHJbIDcgXSA9IHRlWyA3IF07XG5cdFx0clsgOCBdICA9IHRlWyA4IF07IHJbIDkgXSAgPSB0ZVsgOSBdOyByWyAxMCBdID0gdGVbIDEwIF07IHJbIDExIF0gPSB0ZVsgMTEgXTtcblx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuXG5cdH0sXG5cblx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQsIGlsOyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuXHRcdFx0XHR2MS54ID0gYXJyYXlbIGogXTtcblx0XHRcdFx0djEueSA9IGFycmF5WyBqICsgMSBdO1xuXHRcdFx0XHR2MS56ID0gYXJyYXlbIGogKyAyIF07XG5cblx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0XHRcdFx0YXJyYXlbIGogXSAgICAgPSB2MS54O1xuXHRcdFx0XHRhcnJheVsgaiArIDEgXSA9IHYxLnk7XG5cdFx0XHRcdGFycmF5WyBqICsgMiBdID0gdjEuejtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cblx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xuXG5cdH0sXG5cblx0Y3Jvc3NWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0fSxcblxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdHJldHVybiAoXG5cdFx0XHRuNDEgKiAoXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdCkgK1xuXHRcdFx0bjQyICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40MyAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDQgKiAoXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdClcblxuXHRcdCk7XG5cblx0fSxcblxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0ICAgICBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0cmV0dXJuIHYxLnNldCggdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IHYueDtcblx0XHR0ZVsgMTMgXSA9IHYueTtcblx0XHR0ZVsgMTQgXSA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSBtZVsgMCBdLCBuMTIgPSBtZVsgNCBdLCBuMTMgPSBtZVsgOCBdLCBuMTQgPSBtZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gbWVbIDEgXSwgbjIyID0gbWVbIDUgXSwgbjIzID0gbWVbIDkgXSwgbjI0ID0gbWVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IG1lWyAyIF0sIG4zMiA9IG1lWyA2IF0sIG4zMyA9IG1lWyAxMCBdLCBuMzQgPSBtZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gbWVbIDMgXSwgbjQyID0gbWVbIDcgXSwgbjQzID0gbWVbIDExIF0sIG40NCA9IG1lWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NDtcblx0XHR0ZVsgNCBdID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0O1xuXHRcdHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XG5cdFx0dGVbIDEyIF0gPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cdFx0dGVbIDEgXSA9IG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NDtcblx0XHR0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xuXHRcdHRlWyA5IF0gPSBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQ7XG5cdFx0dGVbIDEzIF0gPSBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQ7XG5cdFx0dGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcblx0XHR0ZVsgNiBdID0gbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0O1xuXHRcdHRlWyAxMCBdID0gbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0O1xuXHRcdHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xuXHRcdHRlWyAzIF0gPSBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDM7XG5cdFx0dGVbIDcgXSA9IG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40Mztcblx0XHR0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40Mztcblx0XHR0ZVsgMTUgXSA9IG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMztcblxuXHRcdHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcblxuXHRcdGlmICggZGV0ID09IDAgKSB7XG5cblx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH0sXG5cblx0cm90YXRlWTogZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcblx0XHR2YXIgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0dmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIE1hdGgubWF4KCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApICk7XG5cblx0fSxcblxuXHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCB4LFxuXHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsICAwLCAwLFxuXHRcdFx0MCwgYywgLSBzLCAwLFxuXHRcdFx0MCwgcywgIGMsIDAsXG5cdFx0XHQwLCAwLCAgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQgYywgMCwgcywgMCxcblx0XHRcdCAwLCAxLCAwLCAwLFxuXHRcdFx0LSBzLCAwLCBjLCAwLFxuXHRcdFx0IDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0YywgLSBzLCAwLCAwLFxuXHRcdFx0cywgIGMsIDAsIDAsXG5cdFx0XHQwLCAgMCwgMSwgMCxcblx0XHRcdDAsICAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cdFx0dmFyIHQgPSAxIC0gYztcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcblx0XHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG5cdFx0XHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0IHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCwgMCxcblx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5zY2FsZSggc2NhbGUgKTtcblx0XHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRcdGlmICggZGV0IDwgMCApIHtcblx0XHRcdFx0c3ggPSAtIHN4O1xuXHRcdFx0fVxuXG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XG5cdFx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cblx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cblx0XHRcdG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxuXG5cdFx0XHR2YXIgaW52U1ggPSAxIC8gc3g7XG5cdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG5cdFx0XHR2YXIgaW52U1ogPSAxIC8gc3o7XG5cblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdHNjYWxlLnggPSBzeDtcblx0XHRcdHNjYWxlLnkgPSBzeTtcblx0XHRcdHNjYWxlLnogPSBzejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHR2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0dmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xuXHRcdHZhciB5bWluID0gLSB5bWF4O1xuXHRcdHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcblx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XG5cblx0XHRyZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XG5cblx0fSxcblxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcblx0XHR2YXIgaCA9IHRvcCAtIGJvdHRvbTtcblx0XHR2YXIgcCA9IGZhciAtIG5lYXI7XG5cblx0XHR2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgLyB3O1xuXHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XG5cblx0XHR0ZVsgMCBdID0gMiAvIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAvIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IC0gMiAvIHA7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHJldHVybiBbXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxuXHRcdFx0dGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSwgdGVbIDcgXSxcblx0XHRcdHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdLCB0ZVsgMTEgXSxcblx0XHRcdHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXG5cdFx0XTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUmF5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuUmF5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxuXG5cdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0fSxcblxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcblxuXHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0ZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24gKCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvRGlzdGFuY2UvV201RGlzdFJheTNTZWdtZW50My5jcHBcblx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuXHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cblx0XHR2YXIgc2VnQ2VudGVyID0gdjAuY2xvbmUoKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdHZhciBzZWdEaXIgPSB2MS5jbG9uZSgpLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcblx0XHR2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcblx0XHR2YXIgZGlmZiA9IHRoaXMub3JpZ2luLmNsb25lKCkuc3ViKCBzZWdDZW50ZXIgKTtcblx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xuXHRcdHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xuXHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xuXHRcdHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xuXHRcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuXHRcdGlmICggZGV0ID49IDAgKSB7XG5cblx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuXHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRpZiAoIHMwID49IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuXHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG5cdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcblx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcblx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXG5cdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiA1XG5cblx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblxuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gM1xuXG5cdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gMlxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG5cdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG5cdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG5cdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XG5cblx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHRvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0Rpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzcXJEaXN0O1xuXG5cdH0sXG5cblx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcblxuXHR9LFxuXG5cdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktc3BoZXJlLWludGVyc2VjdGlvbi9cblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0XHR2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0XHR2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XG5cblx0XHRcdHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG5cdFx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cblx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXHRcdFx0aWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHRcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwIFxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG5cdFx0dmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdGlmICggZGVub21pbmF0b3IgPT0gMCApIHtcblxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6ICBudWxsO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fSxcblxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCAsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LWJveC1pbnRlcnNlY3Rpb24vXG5cblx0XHR2YXIgdG1pbix0bWF4LHR5bWluLHR5bWF4LHR6bWluLHR6bWF4O1xuXG5cdFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuXHRcdGlmICggaW52ZGlyeCA+PSAwICkge1xuXG5cdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cdFx0XHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHR9XG5cblx0XHRpZiAoIGludmRpcnkgPj0gMCApIHtcblxuXHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHQvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG5cdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG5cdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuXHRcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XG5cblx0XHRpZiAoIGludmRpcnogPj0gMCApIHtcblxuXHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xuXG5cdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuXHRcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcblxuXHRcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cblx0XHR2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGVkZ2UxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXG5cblx0XHRcdGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRcdGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG5cdFx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG5cdFx0XHR2YXIgc2lnbjtcblxuXHRcdFx0aWYgKCBEZE4gPiAwICkge1xuXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdHNpZ24gPSAxO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG5cdFx0XHRcdHNpZ24gPSAtIDE7XG5cdFx0XHRcdERkTiA9IC0gRGROO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuXHRcdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xuXG5cdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuXHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuXHRcdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBRZE4gPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG5cdFx0dGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XG5cblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5SYXkoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwaGVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG59O1xuXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSAge1xuXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cblx0XHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuY2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiBcdFx0fTtcblxuXHR9KCksXG5cblx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xuXG5cdH0sXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcblxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG5cdFx0cmV0dXJuIGJveDtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuU3BoZXJlKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5GcnVzdHVtID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdHRoaXMucGxhbmVzID0gW1xuXG5cdFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuXHRcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgVEhSRUUuUGxhbmUoKSxcblx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuXHRcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgVEhSRUUuUGxhbmUoKSxcblx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcblxuXHRdO1xuXG59O1xuXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRnJ1c3R1bSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XG5cdFx0cGxhbmVzWyAxIF0uY29weSggcDEgKTtcblx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xuXHRcdHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XG5cdFx0cGxhbmVzWyA0IF0uY29weSggcDQgKTtcblx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xuXHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuXHRcdHZhciBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcblx0XHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xuXG5cdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cdFx0dmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0dmFyIG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XG5cblx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XG5cblx0XHRcdFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcblx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcblx0XHRcdFx0cDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcblx0XHRcdFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcblx0XHRcdFx0cDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcblxuXHRcdFx0XHR2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XG5cdFx0XHRcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuXHRcdFx0XHQvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxuXG5cdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0fSgpLFxuXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuRnJ1c3R1bSgpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUGxhbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxufTtcblxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0dmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cblx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cblx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuXHRcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG5cdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcblx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb25zdGFudCAqPSAtIDE7XG5cdFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cblx0fSxcblxuXHRwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xuXG5cdH0sXG5cblx0b3J0aG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XG5cblx0fSxcblxuXHRpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcblxuXHRcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG5cdFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRpZiAoIGRlbm9taW5hdG9yID09IDAgKSB7XG5cblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0XHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT0gMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggbGluZS5zdGFydCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0XHRpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xuXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblxuXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIG5ldyBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XG5cdFx0XHQvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXHRcdFx0dmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKTtcblxuXHRcdFx0dmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XG5cdFx0XHRuZXdDb3BsYW5hclBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5ld05vcm1hbCwgbmV3Q29wbGFuYXJQb2ludCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudCAtIG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT0gdGhpcy5jb25zdGFudCApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuUGxhbmUoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRoID0ge1xuXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cblxuXHRcdHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XG5cdFx0dmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG5cdFx0dmFyIHJuZCA9IDAsIHI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMyApIHtcblxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9ICctJztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09IDE0ICkge1xuXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJzQnO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHJuZCA8PSAweDAyICkgcm5kID0gMHgyMDAwMDAwICsgKCBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwICkgfCAwO1xuXHRcdFx0XHRcdHIgPSBybmQgJiAweGY7XG5cdFx0XHRcdFx0cm5kID0gcm5kID4+IDQ7XG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gY2hhcnNbICggaSA9PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdXVpZC5qb2luKCAnJyApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XG5cblx0Y2xhbXA6IGZ1bmN0aW9uICggeCwgYSwgYiApIHtcblxuXHRcdHJldHVybiAoIHggPCBhICkgPyBhIDogKCAoIHggPiBiICkgPyBiIDogeCApO1xuXG5cdH0sXG5cblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGluZilcblxuXHRjbGFtcEJvdHRvbTogZnVuY3Rpb24gKCB4LCBhICkge1xuXG5cdFx0cmV0dXJuIHggPCBhID8gYSA6IHg7XG5cblx0fSxcblxuXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5cblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdFx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cblx0fSxcblxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG5cdH0sXG5cblx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXG5cdC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXG5cblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIDY1MjgwICogTWF0aC5yYW5kb20oKSArIDI1NSAqIE1hdGgucmFuZG9tKCkgKSAvIDY1NTM1O1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG5cdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcblxuXHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5cblx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xuXG5cdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cblx0fSxcblxuXHRkZWdUb1JhZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvciA9IE1hdGguUEkgLyAxODA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkZWdyZWVzICkge1xuXG5cdFx0XHRyZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJhZFRvRGVnOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcmFkaWFuVG9EZWdyZWVzRmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XG5cblx0XHRcdHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwbGluZS5qc1xuXG4vKipcbiAqIFNwbGluZSBmcm9tIFR3ZWVuLmpzLCBzbGlnaHRseSBvcHRpbWl6ZWQgKGFuZCB0cmFzaGVkKVxuICogaHR0cDovL3NvbGUuZ2l0aHViLmNvbS90d2Vlbi5qcy9leGFtcGxlcy8wNV9zcGxpbmUuaHRtbFxuICpcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwbGluZSA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG5cdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXG5cdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXG5cdHBhLCBwYiwgcGMsIHBkO1xuXG5cdHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcblxuXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcblx0XHRjWyAxIF0gPSBpbnRQb2ludDtcblx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcblx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcblxuXHRcdHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xuXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xuXHRcdHBjID0gdGhpcy5wb2ludHNbIGNbIDIgXSBdO1xuXHRcdHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xuXG5cdFx0dzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcblxuXHRcdHYzLnggPSBpbnRlcnBvbGF0ZSggcGEueCwgcGIueCwgcGMueCwgcGQueCwgd2VpZ2h0LCB3MiwgdzMgKTtcblx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XG5cdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xuXG5cdFx0cmV0dXJuIHYzO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRwID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29vcmRzO1xuXG5cdH07XG5cblx0Ly8gYXBwcm94aW1hdGUgbGVuZ3RoIGJ5IHN1bW1pbmcgbGluZWFyIHNlZ21lbnRzXG5cblx0dGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XG5cblx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcblx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXG5cdFx0XHRvbGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXG5cdFx0XHR0b3RhbExlbmd0aCA9IDA7XG5cblx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcblxuXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcblxuXHRcdGlmICggISBuU3ViRGl2aXNpb25zICkgblN1YkRpdmlzaW9ucyA9IDEwMDtcblxuXHRcdG5TYW1wbGVzID0gdGhpcy5wb2ludHMubGVuZ3RoICogblN1YkRpdmlzaW9ucztcblxuXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgblNhbXBsZXM7IGkgKysgKSB7XG5cblx0XHRcdGluZGV4ID0gaSAvIG5TYW1wbGVzO1xuXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG5cdFx0XHR0bXBWZWMuY29weSggcG9zaXRpb24gKTtcblxuXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XG5cblx0XHRcdG9sZFBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XG5cblx0XHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBpbmRleDtcblx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblxuXHRcdFx0aWYgKCBpbnRQb2ludCAhPSBvbGRJbnRQb2ludCApIHtcblxuXHRcdFx0XHRjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcblx0XHRcdFx0b2xkSW50UG9pbnQgPSBpbnRQb2ludDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXG5cblx0XHRjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xuXG5cdH07XG5cblx0dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcblxuXHRcdHZhciBpLCBqLFxuXHRcdFx0aW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxuXHRcdFx0bGluZWFyRGlzdGFuY2UsIHJlYWxEaXN0YW5jZSxcblx0XHRcdHNhbXBsaW5nLCBwb3NpdGlvbixcblx0XHRcdG5ld3BvaW50cyA9IFtdLFxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHNsID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuXHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHQvL3RtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSAtIDEgXSApO1xuXHRcdFx0Ly9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XG5cblx0XHRcdHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xuXG5cdFx0XHRzYW1wbGluZyA9IE1hdGguY2VpbCggc2FtcGxpbmdDb2VmICogcmVhbERpc3RhbmNlIC8gc2wudG90YWwgKTtcblxuXHRcdFx0aW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cdFx0XHRpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDwgc2FtcGxpbmcgLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdGluZGV4ID0gaW5kZXhDdXJyZW50ICsgaiAqICggMSAvIHNhbXBsaW5nICkgKiAoIGluZGV4TmV4dCAtIGluZGV4Q3VycmVudCApO1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcblx0XHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcblxuXHR9O1xuXG5cdC8vIENhdG11bGwtUm9tXG5cblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHRyZXN1bHQuY3Jvc3MoIHYwICk7XG5cblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcblx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljb29yZGluYXRlc1xuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuXHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcblx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG5cdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuXHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcblx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cblx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdC8vIGNvbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0aWYgKCBkZW5vbSA9PSAwICkge1xuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG5cdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xuXHRcdH1cblxuXHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XG5cblx0XHQvLyBiYXJ5Y29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XG5cblx0fTtcblxufSgpO1xuXG5USFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgdjEgKTtcblxuXHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcblxuXHR9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHR0aGlzLmEuY29weSggYSApO1xuXHRcdHRoaXMuYi5jb3B5KCBiICk7XG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xuXG5cdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuXHRcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcblx0XHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXJlYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cblx0XHRcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cblx0fSxcblxuXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVHJpYW5nbGUoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0Nsb2NrLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xuXG5cdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcblxuXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdHRoaXMub2xkVGltZSA9IDA7XG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkNsb2NrLFxuXG5cdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiBzZWxmLnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0ID8gc2VsZi5wZXJmb3JtYW5jZS5ub3coKVxuXHRcdFx0XHRcdCA6IERhdGUubm93KCk7XG5cblx0XHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcblx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHR9LFxuXG5cdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmdldERlbHRhKCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0fSxcblxuXHRnZXREZWx0YTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRpZmYgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcblxuXHRcdFx0dGhpcy5zdGFydCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdHZhciBuZXdUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQgPyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpXG5cdFx0XHRcdFx0IDogRGF0ZS5ub3coKTtcblxuXHRcdFx0ZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG5cdFx0XHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGlmZjtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge31cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRXZlbnREaXNwYXRjaGVyLFxuXG5cdGFwcGx5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xuXHRcdG9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXG5cdH0sXG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XG5cblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cblx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb20vXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cbiAqL1xuXG4oIGZ1bmN0aW9uICggVEhSRUUgKSB7XG5cblx0VEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xuXG5cdFx0dGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cblx0XHR0aGlzLnBhcmFtcyA9IHtcblx0XHRcdFNwcml0ZToge30sXG5cdFx0XHRNZXNoOiB7fSxcblx0XHRcdFBvaW50Q2xvdWQ6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0XHRMT0Q6IHt9LFxuXHRcdFx0TGluZToge31cblx0XHR9O1xuXG5cdH07XG5cblx0dmFyIGRlc2NTb3J0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG5cdH07XG5cblx0dmFyIGludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuXHRcdHByZWNpc2lvbjogMC4wMDAxLFxuXHRcdGxpbmVQcmVjaXNpb246IDEsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cblx0XHRcdGlmICggb2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdH1cblxuXHR9O1xuXG59KCBUSFJFRSApICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuXHR0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcblx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXG5cdHRoaXMudXAgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0dmFyIG9uUm90YXRpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXHR9O1xuXG5cdHZhciBvblF1YXRlcm5pb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblx0fTtcblxuXHRyb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xuXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0fSxcblx0XHRyb3RhdGlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdH0sXG5cdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0fSxcblx0XHRzY2FsZToge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdH0sXG5cdH0gKTtcblxuXHR0aGlzLnJlbmRlckRlcHRoID0gbnVsbDtcblxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcblxufTtcblxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcblxuXHRnZXQgZXVsZXJPcmRlciAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLicgKTtcblxuXHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xuXG5cdH0sXG5cblx0c2V0IGV1bGVyT3JkZXIgKCB2YWx1ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byAucm90YXRpb24ub3JkZXIuJyApO1xuXG5cdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Z2V0IHVzZVF1YXRlcm5pb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG5cdH0sXG5cblx0c2V0IHVzZVF1YXRlcm5pb24gKCB2YWx1ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgZGlzdGFuY2UgKSB7XG5cblx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fSxcblxuXHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0XHRtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6XCIsIG9iamVjdCwgXCJjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcblxuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOlwiLCBvYmplY3QsIFwiaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xuXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lLCByZWN1cnNpdmUgKTtcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5pZCA9PT0gaWQgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5SWQoIGlkLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH0sXG5cblx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5uYW1lID09PSBuYW1lICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcblx0XHRcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeU5hbWUoIG5hbWUsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fSxcblxuXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XG5cblx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC4zLFxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0RXhwb3J0ZXInXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vXG5cblx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0dmFyIHBhcnNlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRpZiAoIG91dHB1dC5nZW9tZXRyaWVzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b3V0cHV0Lmdlb21ldHJpZXMgPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBqc29uID0gZ2VvbWV0cnkudG9KU09OKCk7XG5cblx0XHRcdFx0ZGVsZXRlIGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkudXVpZCBdID0ganNvbjtcblxuXHRcdFx0XHRvdXRwdXQuZ2VvbWV0cmllcy5wdXNoKCBqc29uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5LnV1aWQ7XG5cblx0XHR9O1xuXG5cdFx0Ly9cblxuXHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdHZhciBwYXJzZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCBvdXRwdXQubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b3V0cHV0Lm1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxzWyBtYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIganNvbiA9IG1hdGVyaWFsLnRvSlNPTigpO1xuXG5cdFx0XHRcdGRlbGV0ZSBqc29uLm1ldGFkYXRhO1xuXG5cdFx0XHRcdG1hdGVyaWFsc1sgbWF0ZXJpYWwudXVpZCBdID0ganNvbjtcblxuXHRcdFx0XHRvdXRwdXQubWF0ZXJpYWxzLnB1c2goIGpzb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWwudXVpZDtcblxuXHRcdH07XG5cblx0XHQvL1xuXG5cdFx0dmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGRhdGEudXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gb2JqZWN0LnR5cGU7XG5cblx0XHRcdGlmICggb2JqZWN0Lm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gb2JqZWN0Lm5hbWU7XG5cdFx0XHRpZiAoIEpTT04uc3RyaW5naWZ5KCBvYmplY3QudXNlckRhdGEgKSAhPT0gJ3t9JyApIGRhdGEudXNlckRhdGEgPSBvYmplY3QudXNlckRhdGE7XG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICE9PSB0cnVlICkgZGF0YS52aXNpYmxlID0gb2JqZWN0LnZpc2libGU7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0ZGF0YS5mb3YgPSBvYmplY3QuZm92O1xuXHRcdFx0XHRkYXRhLmFzcGVjdCA9IG9iamVjdC5hc3BlY3Q7XG5cdFx0XHRcdGRhdGEubmVhciA9IG9iamVjdC5uZWFyO1xuXHRcdFx0XHRkYXRhLmZhciA9IG9iamVjdC5mYXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRkYXRhLmxlZnQgPSBvYmplY3QubGVmdDtcblx0XHRcdFx0ZGF0YS5yaWdodCA9IG9iamVjdC5yaWdodDtcblx0XHRcdFx0ZGF0YS50b3AgPSBvYmplY3QudG9wO1xuXHRcdFx0XHRkYXRhLmJvdHRvbSA9IG9iamVjdC5ib3R0b207XG5cdFx0XHRcdGRhdGEubmVhciA9IG9iamVjdC5uZWFyO1xuXHRcdFx0XHRkYXRhLmZhciA9IG9iamVjdC5mYXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdGRhdGEuY29sb3IgPSBvYmplY3QuY29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRcdGRhdGEuaW50ZW5zaXR5ID0gb2JqZWN0LmludGVuc2l0eTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXHRcdFx0XHRkYXRhLmludGVuc2l0eSA9IG9iamVjdC5pbnRlbnNpdHk7XG5cdFx0XHRcdGRhdGEuZGlzdGFuY2UgPSBvYmplY3QuZGlzdGFuY2U7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXHRcdFx0XHRkYXRhLmludGVuc2l0eSA9IG9iamVjdC5pbnRlbnNpdHk7XG5cdFx0XHRcdGRhdGEuZGlzdGFuY2UgPSBvYmplY3QuZGlzdGFuY2U7XG5cdFx0XHRcdGRhdGEuYW5nbGUgPSBvYmplY3QuYW5nbGU7XG5cdFx0XHRcdGRhdGEuZXhwb25lbnQgPSBvYmplY3QuZXhwb25lbnQ7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXHRcdFx0XHRkYXRhLmdyb3VuZENvbG9yID0gb2JqZWN0Lmdyb3VuZENvbG9yLmdldEhleCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG5cdFx0XHRcdGRhdGEuZ2VvbWV0cnkgPSBwYXJzZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdFx0ZGF0YS5tYXRlcmlhbCA9IHBhcnNlTWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHRcdGRhdGEuZ2VvbWV0cnkgPSBwYXJzZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdFx0ZGF0YS5tYXRlcmlhbCA9IHBhcnNlTWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XG5cblx0XHRcdFx0ZGF0YS5tYXRlcmlhbCA9IHBhcnNlTWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRhdGEubWF0cml4ID0gb2JqZWN0Lm1hdHJpeC50b0FycmF5KCk7XG5cblx0XHRcdGlmICggb2JqZWN0LmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0ZGF0YS5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRkYXRhLmNoaWxkcmVuLnB1c2goIHBhcnNlT2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0b3V0cHV0Lm9iamVjdCA9IHBhcnNlT2JqZWN0KCB0aGlzICk7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cblx0XHRvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdG9iamVjdC51cC5jb3B5KCB0aGlzLnVwICk7XG5cblx0XHRvYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbiApO1xuXHRcdG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMucXVhdGVybmlvbiApO1xuXHRcdG9iamVjdC5zY2FsZS5jb3B5KCB0aGlzLnNjYWxlICk7XG5cblx0XHRvYmplY3QucmVuZGVyRGVwdGggPSB0aGlzLnJlbmRlckRlcHRoO1xuXG5cdFx0b2JqZWN0LnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRoaXMucm90YXRpb25BdXRvVXBkYXRlO1xuXG5cdFx0b2JqZWN0Lm1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXHRcdG9iamVjdC5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRoaXMubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdG9iamVjdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0b2JqZWN0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG5cdFx0b2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcblxuXHRcdG9iamVjdC51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdG9iamVjdC5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL1Byb2plY3Rvci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUHJvamVjdG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XG5cblx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG5cdFx0dmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xuXG5cdH07XG5cblx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XG5cdFx0dmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0fTtcblxuXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0dGhpcy5hID0gYTtcblx0dGhpcy5iID0gYjtcblx0dGhpcy5jID0gYztcblxuXHR0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBub3JtYWwgaW5zdGFuY2VvZiBBcnJheSA/IG5vcm1hbCA6IFtdO1xuXG5cdHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBjb2xvciBpbnN0YW5jZW9mIEFycmF5ID8gY29sb3IgOiBbXTtcblxuXHR0aGlzLnZlcnRleFRhbmdlbnRzID0gW107XG5cblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbn07XG5cblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cblx0XHRmYWNlLm5vcm1hbC5jb3B5KCB0aGlzLm5vcm1hbCApO1xuXHRcdGZhY2UuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG5cdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gdGhpcy5tYXRlcmlhbEluZGV4O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRmYWNlLnZlcnRleENvbG9yc1sgaSBdID0gdGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IHRoaXMudmVydGV4VGFuZ2VudHNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhY2U7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2U0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKVxuXHRyZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSxcblxuXHRnZXQgbGVuZ3RoICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuXHR9LFxuXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG5cdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICAgICBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAgICAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAgICAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIHRoaXMuYXJyYXkgKSwgdGhpcy5pdGVtU2l6ZSApO1xuXG5cdH1cblxufTtcblxuLy9cblxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBkYXRhLCBpdGVtU2l6ZSApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggZGF0YSwgaXRlbVNpemUgKTtcblxuXG59O1xuXG5USFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBkYXRhLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGRhdGEsIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBkYXRhLCBpdGVtU2l6ZSApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggZGF0YSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGRhdGEsIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBkYXRhLCBpdGVtU2l6ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cdHRoaXMuYXR0cmlidXRlc0tleXMgPSBbXTtcblxuXHR0aGlzLmRyYXdjYWxscyA9IFtdO1xuXHR0aGlzLm9mZnNldHMgPSB0aGlzLmRyYXdjYWxsczsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnksXG5cblx0YWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSB7IGFycmF5OiBhcmd1bWVudHNbIDEgXSwgaXRlbVNpemU6IGFyZ3VtZW50c1sgMiBdIH07XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXHRcdHRoaXMuYXR0cmlidXRlc0tleXMgPSBPYmplY3Qua2V5cyggdGhpcy5hdHRyaWJ1dGVzICk7XG5cblx0fSxcblxuXHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHR9LFxuXG5cdGFkZERyYXdDYWxsOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQgKSB7XG5cblx0XHR0aGlzLmRyYXdjYWxscy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdGluZGV4OiBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkID8gaW5kZXhPZmZzZXQgOiAwXG5cblx0XHR9ICk7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBUT0RPXG5cblx0fSxcblxuXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHNldHRpbmdzICkge1xuXG5cdFx0c2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7ICd2ZXJ0ZXhDb2xvcnMnOiBUSFJFRS5Ob0NvbG9ycyB9O1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuXHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBzZXR0aW5ncy52ZXJ0ZXhDb2xvcnM7XG5cdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xuXHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFscyA9IGZhY2VzWyAwIF0udmVydGV4Tm9ybWFscy5sZW5ndGggPT0gMztcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcy5sZW5ndGggKiAzICogMyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG5cdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcy5sZW5ndGggKiAzICogMyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRpZiAoIHZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSB7XG5cblx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcy5sZW5ndGggKiAzICogMyApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzLmxlbmd0aCAqIDMgKiAyICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgaTIgPSAwLCBpMyA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKyssIGkyICs9IDYsIGkzICs9IDkgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHR2YXIgYiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdHZhciBjID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRwb3NpdGlvbnNbIGkzICAgICBdID0gYS54O1xuXHRcdFx0cG9zaXRpb25zWyBpMyArIDEgXSA9IGEueTtcblx0XHRcdHBvc2l0aW9uc1sgaTMgKyAyIF0gPSBhLno7XG5cblx0XHRcdHBvc2l0aW9uc1sgaTMgKyAzIF0gPSBiLng7XG5cdFx0XHRwb3NpdGlvbnNbIGkzICsgNCBdID0gYi55O1xuXHRcdFx0cG9zaXRpb25zWyBpMyArIDUgXSA9IGIuejtcblxuXHRcdFx0cG9zaXRpb25zWyBpMyArIDYgXSA9IGMueDtcblx0XHRcdHBvc2l0aW9uc1sgaTMgKyA3IF0gPSBjLnk7XG5cdFx0XHRwb3NpdGlvbnNbIGkzICsgOCBdID0gYy56O1xuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWxzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciBuYSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdO1xuXHRcdFx0XHR2YXIgbmIgPSBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXTtcblx0XHRcdFx0dmFyIG5jID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF07XG5cblx0XHRcdFx0bm9ybWFsc1sgaTMgICAgIF0gPSBuYS54O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDEgXSA9IG5hLnk7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgMiBdID0gbmEuejtcblxuXHRcdFx0XHRub3JtYWxzWyBpMyArIDMgXSA9IG5iLng7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgNCBdID0gbmIueTtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA1IF0gPSBuYi56O1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgNiBdID0gbmMueDtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA3IF0gPSBuYy55O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDggXSA9IG5jLno7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIG4gPSBmYWNlLm5vcm1hbDtcblxuXHRcdFx0XHRub3JtYWxzWyBpMyAgICAgXSA9IG4ueDtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyAxIF0gPSBuLnk7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgMiBdID0gbi56O1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgMyBdID0gbi54O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDQgXSA9IG4ueTtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA1IF0gPSBuLno7XG5cblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA2IF0gPSBuLng7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgNyBdID0gbi55O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDggXSA9IG4uejtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZlcnRleENvbG9ycyA9PT0gVEhSRUUuRmFjZUNvbG9ycyApIHtcblxuXHRcdFx0XHR2YXIgZmMgPSBmYWNlLmNvbG9yO1xuXG5cdFx0XHRcdGNvbG9yc1sgaTMgICAgIF0gPSBmYy5yO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgMSBdID0gZmMuZztcblx0XHRcdFx0Y29sb3JzWyBpMyArIDIgXSA9IGZjLmI7XG5cblx0XHRcdFx0Y29sb3JzWyBpMyArIDMgXSA9IGZjLnI7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA0IF0gPSBmYy5nO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgNSBdID0gZmMuYjtcblxuXHRcdFx0XHRjb2xvcnNbIGkzICsgNiBdID0gZmMucjtcblx0XHRcdFx0Y29sb3JzWyBpMyArIDcgXSA9IGZjLmc7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA4IF0gPSBmYy5iO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLlZlcnRleENvbG9ycyApIHtcblxuXHRcdFx0XHR2YXIgdmNhID0gZmFjZS52ZXJ0ZXhDb2xvcnNbIDAgXTtcblx0XHRcdFx0dmFyIHZjYiA9IGZhY2UudmVydGV4Q29sb3JzWyAxIF07XG5cdFx0XHRcdHZhciB2Y2MgPSBmYWNlLnZlcnRleENvbG9yc1sgMiBdO1xuXG5cdFx0XHRcdGNvbG9yc1sgaTMgICAgIF0gPSB2Y2Eucjtcblx0XHRcdFx0Y29sb3JzWyBpMyArIDEgXSA9IHZjYS5nO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgMiBdID0gdmNhLmI7XG5cblx0XHRcdFx0Y29sb3JzWyBpMyArIDMgXSA9IHZjYi5yO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgNCBdID0gdmNiLmc7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA1IF0gPSB2Y2IuYjtcblxuXHRcdFx0XHRjb2xvcnNbIGkzICsgNiBdID0gdmNjLnI7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA3IF0gPSB2Y2MuZztcblx0XHRcdFx0Y29sb3JzWyBpMyArIDggXSA9IHZjYy5iO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciB1dmEgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXVsgMCBdO1xuXHRcdFx0XHR2YXIgdXZiID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF1bIDEgXTtcblx0XHRcdFx0dmFyIHV2YyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdWyAyIF07XG5cblx0XHRcdFx0dXZzWyBpMiAgICAgXSA9IHV2YS54O1xuXHRcdFx0XHR1dnNbIGkyICsgMSBdID0gdXZhLnk7XG5cblx0XHRcdFx0dXZzWyBpMiArIDIgXSA9IHV2Yi54O1xuXHRcdFx0XHR1dnNbIGkyICsgMyBdID0gdXZiLnk7XG5cblx0XHRcdFx0dXZzWyBpMiArIDQgXSA9IHV2Yy54O1xuXHRcdFx0XHR1dnNbIGkyICsgNSBdID0gdXZjLnk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKClcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcblxuXHRcdFx0XHR2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xuXHRcdFx0XHRiYi5tYWtlRW1wdHkoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3Iuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblx0XHRcdFx0XHRiYi5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWluLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgKSB7XG5cblx0XHRcdFx0Ym94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3Iuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblx0XHRcdFx0XHRib3guZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJveC5jZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0XHRcdC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogIHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXG5cblx0XHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3Iuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9KCksXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cdH0sXG5cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsXG5cblx0XHRcdHBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0YWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5pbmRleCApIHtcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG5cblx0XHRcdFx0dmFyIG9mZnNldHMgPSAoIHRoaXMub2Zmc2V0cy5sZW5ndGggPiAwID8gdGhpcy5vZmZzZXRzIDogWyB7IHN0YXJ0OiAwLCBjb3VudDogaW5kaWNlcy5sZW5ndGgsIGluZGV4OiAwIH0gXSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBvZmZzZXRzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gb2Zmc2V0c1sgaiBdLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIGogXS5jb3VudDtcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBqIF0uaW5kZXg7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHR2QSA9ICggaW5kZXggKyBpbmRpY2VzWyBpICAgICBdICkgKiAzO1xuXHRcdFx0XHRcdFx0dkIgPSAoIGluZGV4ICsgaW5kaWNlc1sgaSArIDEgXSApICogMztcblx0XHRcdFx0XHRcdHZDID0gKCBpbmRleCArIGluZGljZXNbIGkgKyAyIF0gKSAqIDM7XG5cblx0XHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XG5cdFx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcblxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSAgICAgXSArPSBjYi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XG5cblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICAgICBdICs9IGNiLng7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgICAgIF0gKz0gY2IueDtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMSBdICs9IGNiLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XG5cblx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuXHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBpICAgICBdID0gY2IueDtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG5cdFx0XHRhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG5cdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXG5cblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcy5pbmRleCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCB0aGlzLmF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1dikgaW4gQnVmZmVyR2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCknICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblx0XHR2YXIgdXZzID0gdGhpcy5hdHRyaWJ1dGVzLnV2LmFycmF5O1xuXG5cdFx0dmFyIG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3RhbmdlbnQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA0ICogblZlcnRpY2VzICksIDQgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRhbmdlbnRzID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQuYXJyYXk7XG5cblx0XHR2YXIgdGFuMSA9IFtdLCB0YW4yID0gW107XG5cblx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBuVmVydGljZXM7IGsgKysgKSB7XG5cblx0XHRcdHRhbjFbIGsgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyBrIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHZCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHZDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdFx0dXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblx0XHRcdHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cdFx0XHR1dkMgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuXG5cdFx0XHR4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxuXHRcdFx0czEsIHMyLCB0MSwgdDIsIHI7XG5cblx0XHR2YXIgc2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGEsIGIsIGMgKSB7XG5cblx0XHRcdHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXHRcdFx0dkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG5cdFx0XHR2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuXHRcdFx0dXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xuXHRcdFx0dXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xuXHRcdFx0dXZDLmZyb21BcnJheSggdXZzLCBjICogMiApO1xuXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xuXHRcdFx0eDIgPSB2Qy54IC0gdkEueDtcblxuXHRcdFx0eTEgPSB2Qi55IC0gdkEueTtcblx0XHRcdHkyID0gdkMueSAtIHZBLnk7XG5cblx0XHRcdHoxID0gdkIueiAtIHZBLno7XG5cdFx0XHR6MiA9IHZDLnogLSB2QS56O1xuXG5cdFx0XHRzMSA9IHV2Qi54IC0gdXZBLng7XG5cdFx0XHRzMiA9IHV2Qy54IC0gdXZBLng7XG5cblx0XHRcdHQxID0gdXZCLnkgLSB1dkEueTtcblx0XHRcdHQyID0gdXZDLnkgLSB1dkEueTtcblxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcblxuXHRcdFx0c2Rpci5zZXQoXG5cdFx0XHRcdCggdDIgKiB4MSAtIHQxICogeDIgKSAqIHIsXG5cdFx0XHRcdCggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXG5cdFx0XHRcdCggdDIgKiB6MSAtIHQxICogejIgKSAqIHJcblx0XHRcdCk7XG5cblx0XHRcdHRkaXIuc2V0KFxuXHRcdFx0XHQoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuXHRcdFx0XHQoIHMxICogeTIgLSBzMiAqIHkxICkgKiByLFxuXHRcdFx0XHQoIHMxICogejIgLSBzMiAqIHoxICkgKiByXG5cdFx0XHQpO1xuXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBiIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XG5cblx0XHRcdHRhbjJbIGEgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcblxuXHRcdH1cblxuXHRcdHZhciBpLCBpbDtcblx0XHR2YXIgaiwgamw7XG5cdFx0dmFyIGlBLCBpQiwgaUM7XG5cblx0XHRpZiAoIHRoaXMuZHJhd2NhbGxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5hZGREcmF3Q2FsbCggMCwgaW5kaWNlcy5sZW5ndGgsIDAgKTtcblxuXHRcdH1cblxuXHRcdHZhciBkcmF3Y2FsbHMgPSB0aGlzLmRyYXdjYWxscztcblxuXHRcdGZvciAoIGogPSAwLCBqbCA9IGRyYXdjYWxscy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gZHJhd2NhbGxzWyBqIF0uc3RhcnQ7XG5cdFx0XHR2YXIgY291bnQgPSBkcmF3Y2FsbHNbIGogXS5jb3VudDtcblx0XHRcdHZhciBpbmRleCA9IGRyYXdjYWxsc1sgaiBdLmluZGV4O1xuXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0aUEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcblx0XHRcdFx0aUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG5cdFx0XHRcdGlDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xuXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCBpQSwgaUIsIGlDICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdywgdCwgdGVzdDtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuXHRcdFx0bi5mcm9tQXJyYXkoIG5vcm1hbHMsIHYgKiAzICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHR0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0dyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRzWyB2ICogNCAgICAgXSA9IHRtcC54O1xuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMSBdID0gdG1wLnk7XG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAyIF0gPSB0bXAuejtcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDMgXSA9IHc7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBqID0gMCwgamwgPSBkcmF3Y2FsbHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cblx0XHRcdHZhciBzdGFydCA9IGRyYXdjYWxsc1sgaiBdLnN0YXJ0O1xuXHRcdFx0dmFyIGNvdW50ID0gZHJhd2NhbGxzWyBqIF0uY291bnQ7XG5cdFx0XHR2YXIgaW5kZXggPSBkcmF3Y2FsbHNbIGogXS5pbmRleDtcblxuXHRcdFx0Zm9yICggaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGlBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XG5cdFx0XHRcdGlCID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xuXHRcdFx0XHRpQyA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXTtcblxuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGlBICk7XG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaUIgKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpQyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHQvKlxuXHRcdGNvbXB1dGVPZmZzZXRzXG5cdFx0Q29tcHV0ZSB0aGUgZHJhdyBvZmZzZXQgZm9yIGxhcmdlIG1vZGVscyBieSBjaHVua2luZyB0aGUgaW5kZXggYnVmZmVyIGludG8gY2h1bmtzIG9mIDY1ayBhZGRyZXNzYWJsZSB2ZXJ0aWNlcy5cblx0XHRUaGlzIG1ldGhvZCB3aWxsIGVmZmVjdGl2ZWx5IHJld3JpdGUgdGhlIGluZGV4IGJ1ZmZlciBhbmQgcmVtYXAgYWxsIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggdGhlIG5ldyBpbmRpY2VzLlxuXHRcdFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBleHBhbmQgdGhlIHZlcnRleCBjb3VudCB0byBwcmV2ZW50IHNwcmF3bGVkIHRyaWFuZ2xlcyBhY3Jvc3MgZHJhdyBvZmZzZXRzLlxuXHRcdGluZGV4QnVmZmVyU2l6ZSAtIERlZmF1bHRzIHRvIDY1NTM1LCBidXQgYWxsb3dzIGZvciBsYXJnZXIgb3Igc21hbGxlciBjaHVua3MuXG5cdCovXG5cdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoIGluZGV4QnVmZmVyU2l6ZSApIHtcblxuXHRcdHZhciBzaXplID0gaW5kZXhCdWZmZXJTaXplO1xuXHRcdGlmICggaW5kZXhCdWZmZXJTaXplID09PSB1bmRlZmluZWQgKVxuXHRcdFx0c2l6ZSA9IDY1NTM1OyAvL1dlYkdMIGxpbWl0cyB0eXBlIG9mIGluZGV4IGJ1ZmZlciB2YWx1ZXMgdG8gMTYtYml0LlxuXG5cdFx0dmFyIHMgPSBEYXRlLm5vdygpO1xuXG5cdFx0dmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0dmFyIHZlcnRpY2VzQ291bnQgPSAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKTtcblx0XHR2YXIgZmFjZXNDb3VudCA9ICggaW5kaWNlcy5sZW5ndGggLyAzICk7XG5cblx0XHQvKlxuXHRcdGNvbnNvbGUubG9nKFwiQ29tcHV0aW5nIGJ1ZmZlcnMgaW4gb2Zmc2V0cyBvZiBcIitzaXplK1wiIC0+IGluZGljZXM6XCIraW5kaWNlcy5sZW5ndGgrXCIgdmVydGljZXM6XCIrdmVydGljZXMubGVuZ3RoKTtcblx0XHRjb25zb2xlLmxvZyhcIkZhY2VzIHRvIHByb2Nlc3M6IFwiKyhpbmRpY2VzLmxlbmd0aC8zKSk7XG5cdFx0Y29uc29sZS5sb2coXCJSZW9yZGVyaW5nIFwiK3ZlcnRpY2VzQ291bnQrXCIgdmVydGljZXMuXCIpO1xuXHRcdCovXG5cblx0XHR2YXIgc29ydGVkSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggaW5kaWNlcy5sZW5ndGggKTsgLy8xNi1iaXQgYnVmZmVyc1xuXHRcdHZhciBpbmRleFB0ciA9IDA7XG5cdFx0dmFyIHZlcnRleFB0ciA9IDA7XG5cblx0XHR2YXIgb2Zmc2V0cyA9IFsgeyBzdGFydDowLCBjb3VudDowLCBpbmRleDowIH0gXTtcblx0XHR2YXIgb2Zmc2V0ID0gb2Zmc2V0c1sgMCBdO1xuXG5cdFx0dmFyIGR1cGxpY2F0ZWRWZXJ0aWNlcyA9IDA7XG5cdFx0dmFyIG5ld1ZlcnRpY2VNYXBzID0gMDtcblx0XHR2YXIgZmFjZVZlcnRpY2VzID0gbmV3IEludDMyQXJyYXkoIDYgKTtcblx0XHR2YXIgdmVydGV4TWFwID0gbmV3IEludDMyQXJyYXkoIHZlcnRpY2VzLmxlbmd0aCApO1xuXHRcdHZhciByZXZWZXJ0ZXhNYXAgPSBuZXcgSW50MzJBcnJheSggdmVydGljZXMubGVuZ3RoICk7XG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdmVydGljZXMubGVuZ3RoOyBqICsrICkgeyB2ZXJ0ZXhNYXBbIGogXSA9IC0gMTsgcmV2VmVydGV4TWFwWyBqIF0gPSAtIDE7IH1cblxuXHRcdC8qXG5cdFx0XHRUcmF2ZXJzZSBldmVyeSBmYWNlIGFuZCByZW9yZGVyIHZlcnRpY2VzIGluIHRoZSBwcm9wZXIgb2Zmc2V0cyBvZiA2NWsuXG5cdFx0XHRXZSBjYW4gaGF2ZSBtb3JlIHRoYW4gNjVrIGVudHJpZXMgaW4gdGhlIGluZGV4IGJ1ZmZlciBwZXIgb2Zmc2V0LCBidXQgb25seSByZWZlcmVuY2UgNjVrIHZhbHVlcy5cblx0XHQqL1xuXHRcdGZvciAoIHZhciBmaW5kZXggPSAwOyBmaW5kZXggPCBmYWNlc0NvdW50OyBmaW5kZXggKysgKSB7XG5cdFx0XHRuZXdWZXJ0aWNlTWFwcyA9IDA7XG5cblx0XHRcdGZvciAoIHZhciB2byA9IDA7IHZvIDwgMzsgdm8gKysgKSB7XG5cdFx0XHRcdHZhciB2aWQgPSBpbmRpY2VzWyBmaW5kZXggKiAzICsgdm8gXTtcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhNYXBbIHZpZCBdID09IC0gMSApIHtcblx0XHRcdFx0XHQvL1VubWFwcGVkIHZlcnRpY2Vcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbIHZvICogMiBdID0gdmlkO1xuXHRcdFx0XHRcdGZhY2VWZXJ0aWNlc1sgdm8gKiAyICsgMSBdID0gLSAxO1xuXHRcdFx0XHRcdG5ld1ZlcnRpY2VNYXBzICsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhNYXBbIHZpZCBdIDwgb2Zmc2V0LmluZGV4ICkge1xuXHRcdFx0XHRcdC8vUmV1c2VkIHZlcnRpY2VzIGZyb20gcHJldmlvdXMgYmxvY2sgKGR1cGxpY2F0ZSlcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbIHZvICogMiBdID0gdmlkO1xuXHRcdFx0XHRcdGZhY2VWZXJ0aWNlc1sgdm8gKiAyICsgMSBdID0gLSAxO1xuXHRcdFx0XHRcdGR1cGxpY2F0ZWRWZXJ0aWNlcyArKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvL1JldXNlZCB2ZXJ0aWNlIGluIHRoZSBjdXJyZW50IGJsb2NrXG5cdFx0XHRcdFx0ZmFjZVZlcnRpY2VzWyB2byAqIDIgXSA9IHZpZDtcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbIHZvICogMiArIDEgXSA9IHZlcnRleE1hcFsgdmlkIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZhY2VNYXggPSB2ZXJ0ZXhQdHIgKyBuZXdWZXJ0aWNlTWFwcztcblx0XHRcdGlmICggZmFjZU1heCA+ICggb2Zmc2V0LmluZGV4ICsgc2l6ZSApICkge1xuXHRcdFx0XHR2YXIgbmV3X29mZnNldCA9IHsgc3RhcnQ6aW5kZXhQdHIsIGNvdW50OjAsIGluZGV4OnZlcnRleFB0ciB9O1xuXHRcdFx0XHRvZmZzZXRzLnB1c2goIG5ld19vZmZzZXQgKTtcblx0XHRcdFx0b2Zmc2V0ID0gbmV3X29mZnNldDtcblxuXHRcdFx0XHQvL1JlLWV2YWx1YXRlIHJldXNlZCB2ZXJ0aWNlcyBpbiBsaWdodCBvZiBuZXcgb2Zmc2V0LlxuXHRcdFx0XHRmb3IgKCB2YXIgdiA9IDA7IHYgPCA2OyB2ICs9IDIgKSB7XG5cdFx0XHRcdFx0dmFyIG5ld192aWQgPSBmYWNlVmVydGljZXNbIHYgKyAxIF07XG5cdFx0XHRcdFx0aWYgKCBuZXdfdmlkID4gLSAxICYmIG5ld192aWQgPCBvZmZzZXQuaW5kZXggKVxuXHRcdFx0XHRcdFx0ZmFjZVZlcnRpY2VzWyB2ICsgMSBdID0gLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVpbmRleCB0aGUgZmFjZS5cblx0XHRcdGZvciAoIHZhciB2ID0gMDsgdiA8IDY7IHYgKz0gMiApIHtcblx0XHRcdFx0dmFyIHZpZCA9IGZhY2VWZXJ0aWNlc1sgdiBdO1xuXHRcdFx0XHR2YXIgbmV3X3ZpZCA9IGZhY2VWZXJ0aWNlc1sgdiArIDEgXTtcblxuXHRcdFx0XHRpZiAoIG5ld192aWQgPT09IC0gMSApXG5cdFx0XHRcdFx0bmV3X3ZpZCA9IHZlcnRleFB0ciArKztcblxuXHRcdFx0XHR2ZXJ0ZXhNYXBbIHZpZCBdID0gbmV3X3ZpZDtcblx0XHRcdFx0cmV2VmVydGV4TWFwWyBuZXdfdmlkIF0gPSB2aWQ7XG5cdFx0XHRcdHNvcnRlZEluZGljZXNbIGluZGV4UHRyICsrIF0gPSBuZXdfdmlkIC0gb2Zmc2V0LmluZGV4OyAvL1hYWCBvdmVyZmxvd3MgYXQgMTZiaXRcblx0XHRcdFx0b2Zmc2V0LmNvdW50ICsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIE1vdmUgYWxsIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gbWFwIHRvIHRoZSBuZXcgY29tcHV0ZWQgaW5kaWNlcyAsIGFsc28gZXhwYW5kIHRoZSB2ZXJ0aWNlIHN0YWNrIHRvIG1hdGNoIG91ciBuZXcgdmVydGV4UHRyLiAqL1xuXHRcdHRoaXMucmVvcmRlckJ1ZmZlcnMoIHNvcnRlZEluZGljZXMsIHJldlZlcnRleE1hcCwgdmVydGV4UHRyICk7XG5cdFx0dGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcblxuXHRcdC8qXG5cdFx0dmFyIG9yZGVyVGltZSA9IERhdGUubm93KCk7XG5cdFx0Y29uc29sZS5sb2coXCJSZW9yZGVyIHRpbWU6IFwiKyhvcmRlclRpbWUtcykrXCJtc1wiKTtcblx0XHRjb25zb2xlLmxvZyhcIkR1cGxpY2F0ZWQgXCIrZHVwbGljYXRlZFZlcnRpY2VzK1wiIHZlcnRpY2VzLlwiKTtcblx0XHRjb25zb2xlLmxvZyhcIkNvbXB1dGUgQnVmZmVycyB0aW1lOiBcIisoRGF0ZS5ub3coKS1zKStcIm1zXCIpO1xuXHRcdGNvbnNvbGUubG9nKFwiRHJhdyBvZmZzZXRzOiBcIitvZmZzZXRzLmxlbmd0aCk7XG5cdFx0Ki9cblxuXHRcdHJldHVybiBvZmZzZXRzO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmxvZyggJ0J1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IFRPRE8nICk7XG5cblx0fSxcblxuXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cblx0XHR2YXIgeCwgeSwgeiwgbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHggPSBub3JtYWxzWyBpIF07XG5cdFx0XHR5ID0gbm9ybWFsc1sgaSArIDEgXTtcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG5cdFx0XHRuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuXHRcdFx0bm9ybWFsc1sgaSAgICAgXSAqPSBuO1xuXHRcdFx0bm9ybWFsc1sgaSArIDEgXSAqPSBuO1xuXHRcdFx0bm9ybWFsc1sgaSArIDIgXSAqPSBuO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Lypcblx0XHRyZW9kZXJCdWZmZXJzOlxuXHRcdFJlb3JkZXIgYXR0cmlidXRlcyBiYXNlZCBvbiBhIG5ldyBpbmRleEJ1ZmZlciBhbmQgaW5kZXhNYXAuXG5cdFx0aW5kZXhCdWZmZXIgLSBVaW50MTZBcnJheSBvZiB0aGUgbmV3IG9yZGVyZWQgaW5kaWNlcy5cblx0XHRpbmRleE1hcCAtIEludDMyQXJyYXkgd2hlcmUgdGhlIHBvc2l0aW9uIGlzIHRoZSBuZXcgdmVydGV4IElEIGFuZCB0aGUgdmFsdWUgdGhlIG9sZCB2ZXJ0ZXggSUQgZm9yIGVhY2ggdmVydGV4LlxuXHRcdHZlcnRleENvdW50IC0gQW1vdW50IG9mIHRvdGFsIHZlcnRpY2VzIGNvbnNpZGVyZWQgaW4gdGhpcyByZW9yZGVyaW5nIChpbiBjYXNlIHlvdSB3YW50IHRvIGdyb3cgdGhlIHZlcnRpY2Ugc3RhY2spLlxuXHQqL1xuXHRyZW9yZGVyQnVmZmVyczogZnVuY3Rpb24gKCBpbmRleEJ1ZmZlciwgaW5kZXhNYXAsIHZlcnRleENvdW50ICkge1xuXG5cdFx0LyogQ3JlYXRlIGEgY29weSBvZiBhbGwgYXR0cmlidXRlcyBmb3IgcmVvcmRlcmluZy4gKi9cblx0XHR2YXIgc29ydGVkQXR0cmlidXRlcyA9IHt9O1xuXHRcdGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcblx0XHRcdGlmICggYXR0ciA9PSAnaW5kZXgnIClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgc291cmNlQXJyYXkgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5hcnJheTtcblx0XHRcdHNvcnRlZEF0dHJpYnV0ZXNbIGF0dHIgXSA9IG5ldyBzb3VyY2VBcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uaXRlbVNpemUgKiB2ZXJ0ZXhDb3VudCApO1xuXHRcdH1cblxuXHRcdC8qIE1vdmUgYXR0cmlidXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgbmV3IGluZGV4IG1hcCAqL1xuXHRcdGZvciAoIHZhciBuZXdfdmlkID0gMDsgbmV3X3ZpZCA8IHZlcnRleENvdW50OyBuZXdfdmlkICsrICkge1xuXHRcdFx0dmFyIHZpZCA9IGluZGV4TWFwWyBuZXdfdmlkIF07XG5cdFx0XHRmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggYXR0ciA9PSAnaW5kZXgnIClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIGF0dHJBcnJheSA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLmFycmF5O1xuXHRcdFx0XHR2YXIgYXR0clNpemUgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5pdGVtU2l6ZTtcblx0XHRcdFx0dmFyIHNvcnRlZEF0dHIgPSBzb3J0ZWRBdHRyaWJ1dGVzWyBhdHRyIF07XG5cdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGF0dHJTaXplOyBrICsrIClcblx0XHRcdFx0XHRzb3J0ZWRBdHRyWyBuZXdfdmlkICogYXR0clNpemUgKyBrIF0gPSBhdHRyQXJyYXlbIHZpZCAqIGF0dHJTaXplICsgayBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIENhcnJ5IHRoZSBuZXcgc29ydGVkIGJ1ZmZlcnMgbG9jYWxseSAqL1xuXHRcdHRoaXMuYXR0cmlidXRlc1sgJ2luZGV4JyBdLmFycmF5ID0gaW5kZXhCdWZmZXI7XG5cdFx0Zm9yICggdmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXHRcdFx0aWYgKCBhdHRyID09ICdpbmRleCcgKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLmFycmF5ID0gc29ydGVkQXR0cmlidXRlc1sgYXR0ciBdO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0ubnVtSXRlbXMgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5pdGVtU2l6ZSAqIHZlcnRleENvdW50O1xuXHRcdH1cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjAsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5RXhwb3J0ZXInXG5cdFx0XHR9LFxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0ZGF0YToge1xuXHRcdFx0XHRhdHRyaWJ1dGVzOiB7fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblx0XHR2YXIgb2Zmc2V0cyA9IHRoaXMub2Zmc2V0cztcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdHZhciBhcnJheSA9IFtdLCB0eXBlQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHR5cGVBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSB0eXBlQXJyYXlbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcblx0XHRcdFx0aXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcblx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBhcnJheVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdG91dHB1dC5kYXRhLm9mZnNldHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggb2Zmc2V0cyApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRvdXRwdXQuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIHNvdXJjZUF0dHIgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXTtcblx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggYXR0ciwgc291cmNlQXR0ci5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5vZmZzZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRzWyBpIF07XG5cblx0XHRcdGdlb21ldHJ5Lm9mZnNldHMucHVzaCgge1xuXG5cdFx0XHRcdHN0YXJ0OiBvZmZzZXQuc3RhcnQsXG5cdFx0XHRcdGluZGV4OiBvZmZzZXQuaW5kZXgsXG5cdFx0XHRcdGNvdW50OiBvZmZzZXQuY291bnRcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG5cdHRoaXMudmVydGljZXMgPSBbXTtcblx0dGhpcy5jb2xvcnMgPSBbXTsgIC8vIG9uZS10by1vbmUgdmVydGV4IGNvbG9ycywgdXNlZCBpbiBQb2ludHMgYW5kIExpbmVcblxuXHR0aGlzLmZhY2VzID0gW107XG5cblx0dGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xuXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gW107XG5cdHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0dGhpcy5oYXNUYW5nZW50cyA9IGZhbHNlO1xuXG5cdHRoaXMuZHluYW1pYyA9IHRydWU7IC8vIHRoZSBpbnRlcm1lZGlhdGUgdHlwZWQgYXJyYXlzIHdpbGwgYmUgZGVsZXRlZCB3aGVuIHNldCB0byBmYWxzZVxuXG5cdC8vIHVwZGF0ZSBmbGFnc1xuXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXG5cblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCBpbnN0YW5jZW9mIFRIUkVFLkJveDMgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgaW5zdGFuY2VvZiBUSFJFRS5TcGhlcmUgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHR2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XG5cblx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdGVtcFVWcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XG5cblx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHRpZiAoIG5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGFkZEZhY2UgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcblx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cblx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzICkgKTtcblx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXSwgdGVtcFVWc1sgYiBdLCB0ZW1wVVZzWyBjIF0gXSApO1xuXG5cdFx0fTtcblxuXHRcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0YWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRvZmZzZXQuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5taW4sIHRoaXMuYm91bmRpbmdCb3gubWF4ICk7XG5cdFx0b2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAtIDAuNSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKSApO1xuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXG5cdH0sXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0dmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcblxuXHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xuXG5cdFx0dmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XG5cblx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdGlmICggYXJlYVdlaWdodGVkICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xuXHRcdFx0Ly8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxuXG5cdFx0XHR2YXIgdkEsIHZCLCB2QywgdkQ7XG5cdFx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdGRiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgZGMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBiYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xuXG5cdFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXG5cdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXG5cdFx0Ly8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxuXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcblxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxuXG5cdFx0dmFyIHRtcEdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xuXG5cdFx0XHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcblxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XG5cblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGI6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGM6IG5ldyBUSFJFRS5WZWN0b3IzKCkgfTtcblxuXHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcblx0XHRcdFx0XHRkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XG5cblx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcblxuXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuXHRcdFx0Ly8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXG5cblx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHRcdHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdFx0XHQvLyBzdG9yZSBtb3JwaCBub3JtYWxzXG5cblx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcblxuXHRcdFx0XHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XG5cdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuXHRcdC8vIHRhbmdlbnRzIGdvIHRvIHZlcnRpY2VzXG5cblx0XHR2YXIgZiwgZmwsIHYsIHZsLCBpLCBpbCwgdmVydGV4SW5kZXgsXG5cdFx0XHRmYWNlLCB1diwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2Qyxcblx0XHRcdHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXG5cdFx0XHRzMSwgczIsIHQxLCB0MiwgciwgdCwgdGVzdCxcblx0XHRcdHRhbjEgPSBbXSwgdGFuMiA9IFtdLFxuXHRcdFx0c2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0dG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdG1wMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdztcblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHRhbjFbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGNvbnRleHQsIGEsIGIsIGMsIHVhLCB1YiwgdWMgKSB7XG5cblx0XHRcdHZBID0gY29udGV4dC52ZXJ0aWNlc1sgYSBdO1xuXHRcdFx0dkIgPSBjb250ZXh0LnZlcnRpY2VzWyBiIF07XG5cdFx0XHR2QyA9IGNvbnRleHQudmVydGljZXNbIGMgXTtcblxuXHRcdFx0dXZBID0gdXZbIHVhIF07XG5cdFx0XHR1dkIgPSB1dlsgdWIgXTtcblx0XHRcdHV2QyA9IHV2WyB1YyBdO1xuXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xuXHRcdFx0eDIgPSB2Qy54IC0gdkEueDtcblx0XHRcdHkxID0gdkIueSAtIHZBLnk7XG5cdFx0XHR5MiA9IHZDLnkgLSB2QS55O1xuXHRcdFx0ejEgPSB2Qi56IC0gdkEuejtcblx0XHRcdHoyID0gdkMueiAtIHZBLno7XG5cblx0XHRcdHMxID0gdXZCLnggLSB1dkEueDtcblx0XHRcdHMyID0gdXZDLnggLSB1dkEueDtcblx0XHRcdHQxID0gdXZCLnkgLSB1dkEueTtcblx0XHRcdHQyID0gdXZDLnkgLSB1dkEueTtcblxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcblx0XHRcdHNkaXIuc2V0KCAoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxuXHRcdFx0XHRcdCAgKCB0MiAqIHkxIC0gdDEgKiB5MiApICogcixcblx0XHRcdFx0XHQgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHIgKTtcblx0XHRcdHRkaXIuc2V0KCAoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuXHRcdFx0XHRcdCAgKCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcblx0XHRcdFx0XHQgICggczEgKiB6MiAtIHMyICogejEgKSAqIHIgKTtcblxuXHRcdFx0dGFuMVsgYSBdLmFkZCggc2RpciApO1xuXHRcdFx0dGFuMVsgYiBdLmFkZCggc2RpciApO1xuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xuXG5cdFx0XHR0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XG5cdFx0XHR0YW4yWyBjIF0uYWRkKCB0ZGlyICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXHRcdFx0dXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdOyAvLyB1c2UgVVYgbGF5ZXIgMCBmb3IgdGFuZ2VudHNcblxuXHRcdFx0aGFuZGxlVHJpYW5nbGUoIHRoaXMsIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMsIDAsIDEsIDIgKTtcblxuXHRcdH1cblxuXHRcdHZhciBmYWNlSW5kZXggPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBNYXRoLm1pbiggZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCwgMyApOyBpICsrICkge1xuXG5cdFx0XHRcdG4uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCA9IGZhY2VbIGZhY2VJbmRleFsgaSBdIF07XG5cblx0XHRcdFx0dCA9IHRhbjFbIHZlcnRleEluZGV4IF07XG5cblx0XHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuXHRcdFx0XHR0bXAuY29weSggdCApO1xuXHRcdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG5cdFx0XHRcdHRtcDIuY3Jvc3NWZWN0b3JzKCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSwgdCApO1xuXHRcdFx0XHR0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHZlcnRleEluZGV4IF0gKTtcblx0XHRcdFx0dyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdFx0ZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjQoIHRtcC54LCB0bXAueSwgdG1wLnosIHcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XG5cblx0fSxcblxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGQgPSAwO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaSA+IDAgKSB7XG5cblx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cblx0fSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBub3JtYWxNYXRyaXgsXG5cdFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcblx0XHR2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHRmYWNlczEgPSB0aGlzLmZhY2VzLFxuXHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxuXHRcdHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcblx0XHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0aWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcblxuXHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHZlcnRpY2VzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XG5cblx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBmYWNlc1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcblx0XHRcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuXHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xuXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcblxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcblxuXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyB1dnNcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XG5cblx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdC8qXG5cdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cblx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuXHQgKi9cblxuXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xuXG5cdFx0dmFyIHYsIGtleTtcblx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcblx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcblx0XHR2YXIgaSxpbCwgZmFjZTtcblx0XHR2YXIgaW5kaWNlcywgaywgaiwgamwsIHU7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xuXG5cdFx0XHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG5cdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblxuXHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2Vcblx0XHQvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxuXHRcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcblx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xuXHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XG5cblx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcblxuXHRcdFx0dmFyIGR1cEluZGV4ID0gLSAxO1xuXG5cdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXG5cdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxuXHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcblx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xuXG5cdFx0XHRcdFx0ZHVwSW5kZXggPSBuO1xuXHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcblx0XHRcdHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XG5cblx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXG5cblx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcblx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuXHRcdHJldHVybiBkaWZmO1xuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC4wLFxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeUV4cG9ydGVyJ1xuXHRcdFx0fSxcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdHR5cGU6IHRoaXMudHlwZVxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gXCJcIiApIG91dHB1dC5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBvdXRwdXRbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdH1cblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgZmFjZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xuXHRcdHZhciBjb2xvcnMgPSBbXTtcblx0XHR2YXIgY29sb3JzSGFzaCA9IHt9O1xuXHRcdHZhciB1dnMgPSBbXTtcblx0XHR2YXIgdXZzSGFzaCA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHR2YXIgaGFzTWF0ZXJpYWwgPSBmYWxzZTsgLy8gZmFjZS5tYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XG5cdFx0XHR2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcblxuXHRcdFx0dmFyIGZhY2VUeXBlID0gMDtcblxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcblxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcblx0XHRcdGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcblxuXG5cdFx0XHQvKlxuXHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuXHRcdFx0XHRmYWNlcy5wdXNoKFxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xuXG5cdFx0XHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24pICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcblx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoIGNvbG9yICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XG5cdFx0XHRjb2xvcnMucHVzaCggY29sb3IuZ2V0SGV4KCkgKTtcblxuXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdG91dHB1dC5kYXRhID0ge307XG5cblx0XHRvdXRwdXQuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXHRcdG91dHB1dC5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xuXHRcdGlmICggY29sb3JzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG5cdFx0aWYgKCB1dnMubGVuZ3RoID4gMCApIG91dHB1dC5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRvdXRwdXQuZGF0YS5mYWNlcyA9IGZhY2VzO1xuXG5cdFx0Ly9cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHV2ID0gdXZzWyBpIF0sIHV2Q29weSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Q29weSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0fVxuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKCkge1xuXG5cdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG5cdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cblx0fTtcblxufSgpO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0aWYgKCBjYW1lcmEgPT09IHVuZGVmaW5lZCApIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgY2FtZXJhICk7XG5cblx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRyZXR1cm4gY2FtZXJhO1xufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzXG5cbi8qKlxuICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXG4gKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkN1YmVDYW1lcmEgPSBmdW5jdGlvbiAoIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XG5cblx0dmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdGNhbWVyYVBYLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhUFggKTtcblxuXHR2YXIgY2FtZXJhTlggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cblx0dmFyIGNhbWVyYVBZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xuXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cblx0dmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XG5cdGNhbWVyYU5ZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApICk7XG5cdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG5cdHZhciBjYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cblx0dmFyIGNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYU5aLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XG5cdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xuXG5cdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCB7IGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIgfSApO1xuXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuXHRcdHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcblxuXHR9O1xuXG59O1xuXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG5cdHRoaXMuem9vbSA9IDE7XG5cblx0dGhpcy5sZWZ0ID0gbGVmdDtcblx0dGhpcy5yaWdodCA9IHJpZ2h0O1xuXHR0aGlzLnRvcCA9IHRvcDtcblx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG5cdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG5cdHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcblx0dmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoKTtcblxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xuXG5cdGNhbWVyYS56b29tID0gdGhpcy56b29tO1xuXG5cdGNhbWVyYS5sZWZ0ID0gdGhpcy5sZWZ0O1xuXHRjYW1lcmEucmlnaHQgPSB0aGlzLnJpZ2h0O1xuXHRjYW1lcmEudG9wID0gdGhpcy50b3A7XG5cdGNhbWVyYS5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblxuXHRjYW1lcmEubmVhciA9IHRoaXMubmVhcjtcblx0Y2FtZXJhLmZhciA9IHRoaXMuZmFyO1xuXG5cdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdHJldHVybiBjYW1lcmE7XG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcblxuXHR0aGlzLnpvb20gPSAxO1xuXG5cdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcblx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XG5cdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG5cdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XG5cblxuLyoqXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXG4gKiAzNW1tIChmdWxsZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xuXG5cdGlmICggZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCApIGZyYW1lSGVpZ2h0ID0gMjQ7XG5cblx0dGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufVxuXG5cbi8qKlxuICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuICpcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEEgfCBCIHwgQyB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqICAgfCBEIHwgRSB8IEYgfFxuICogICArLS0tKy0tLSstLS0rXG4gKlxuICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuICpcbiAqICAgdmFyIHcgPSAxOTIwO1xuICogICB2YXIgaCA9IDEwODA7XG4gKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcbiAqXG4gKiAgIC0tQS0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tQi0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tQy0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tRC0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG4gKiAgIC0tRS0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG4gKiAgIC0tRi0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG4gKlxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0dGhpcy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG5cdHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG5cdHRoaXMud2lkdGggPSB3aWR0aDtcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGZvdiA9IFRIUkVFLk1hdGgucmFkVG9EZWcoIDIgKiBNYXRoLmF0YW4oIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiApICogMC41ICkgLyB0aGlzLnpvb20gKSApO1xuXG5cdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XG5cblx0XHR2YXIgYXNwZWN0ID0gdGhpcy5mdWxsV2lkdGggLyB0aGlzLmZ1bGxIZWlnaHQ7XG5cdFx0dmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xuXHRcdHZhciBib3R0b20gPSAtIHRvcDtcblx0XHR2YXIgbGVmdCA9IGFzcGVjdCAqIGJvdHRvbTtcblx0XHR2YXIgcmlnaHQgPSBhc3BlY3QgKiB0b3A7XG5cdFx0dmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdHZhciBoZWlnaHQgPSBNYXRoLmFicyggdG9wIC0gYm90dG9tICk7XG5cblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXG5cdFx0XHRsZWZ0ICsgdGhpcy54ICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcblx0XHRcdGxlZnQgKyAoIHRoaXMueCArIHRoaXMud2lkdGggKSAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXG5cdFx0XHR0b3AgLSAoIHRoaXMueSArIHRoaXMuaGVpZ2h0ICkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG5cdFx0XHR0b3AgLSB0aGlzLnkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG5cdFx0XHR0aGlzLm5lYXIsXG5cdFx0XHR0aGlzLmZhclxuXHRcdCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBjYW1lcmEgKTtcblxuXHRjYW1lcmEuem9vbSA9IHRoaXMuem9vbTtcblxuXHRjYW1lcmEuZm92ID0gdGhpcy5mb3Y7XG5cdGNhbWVyYS5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcblx0Y2FtZXJhLm5lYXIgPSB0aGlzLm5lYXI7XG5cdGNhbWVyYS5mYXIgPSB0aGlzLmZhcjtcblxuXHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRyZXR1cm4gY2FtZXJhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaWdodCc7XG5cdFxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRpZiAoIGxpZ2h0ID09PSB1bmRlZmluZWQgKSBsaWdodCA9IG5ldyBUSFJFRS5MaWdodCgpO1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG5cdGxpZ2h0LmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9BbWJpZW50TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkFtYmllbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxufTtcblxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoKTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9BcmVhTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIE1QYW5rbmluIC8gaHR0cDovL3d3dy5yZWRwbGFudC5kZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQXJlYUxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cblx0dGhpcy50eXBlID0gJ0FyZWFMaWdodCc7XG5cblx0dGhpcy5ub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cdHRoaXMucmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblxuXHR0aGlzLndpZHRoID0gMS4wO1xuXHR0aGlzLmhlaWdodCA9IDEuMDtcblxuXHR0aGlzLmNvbnN0YW50QXR0ZW51YXRpb24gPSAxLjU7XG5cdHRoaXMubGluZWFyQXR0ZW51YXRpb24gPSAwLjU7XG5cdHRoaXMucXVhZHJhdGljQXR0ZW51YXRpb24gPSAwLjE7XG5cbn07XG5cblRIUkVFLkFyZWFMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblxuXG4vLyBGaWxlOnNyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG5cdHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblxuXHR0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSAtIDUwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFSaWdodCA9IDUwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFUb3AgPSA1MDA7XG5cdHRoaXMuc2hhZG93Q2FtZXJhQm90dG9tID0gLSA1MDA7XG5cblx0dGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cblx0dGhpcy5zaGFkb3dCaWFzID0gMDtcblx0dGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuXHR0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuXHR0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuXHQvL1xuXG5cdHRoaXMuc2hhZG93Q2FzY2FkZSA9IGZhbHNlO1xuXG5cdHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEwMDAgKTtcblx0dGhpcy5zaGFkb3dDYXNjYWRlQ291bnQgPSAyO1xuXG5cdHRoaXMuc2hhZG93Q2FzY2FkZUJpYXMgPSBbIDAsIDAsIDAgXTtcblx0dGhpcy5zaGFkb3dDYXNjYWRlV2lkdGggPSBbIDUxMiwgNTEyLCA1MTIgXTtcblx0dGhpcy5zaGFkb3dDYXNjYWRlSGVpZ2h0ID0gWyA1MTIsIDUxMiwgNTEyIF07XG5cblx0dGhpcy5zaGFkb3dDYXNjYWRlTmVhclogPSBbIC0gMS4wMDAsIDAuOTkwLCAwLjk5OCBdO1xuXHR0aGlzLnNoYWRvd0Nhc2NhZGVGYXJaICA9IFsgIDAuOTkwLCAwLjk5OCwgMS4wMDAgXTtcblxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVBcnJheSA9IFtdO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuXHR0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG5cdHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoKTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuXHRsaWdodC50YXJnZXQgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXG5cdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG5cdGxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG5cdGxpZ2h0Lm9ubHlTaGFkb3cgPSB0aGlzLm9ubHlTaGFkb3c7XG5cblx0Ly9cblxuXHRsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gdGhpcy5zaGFkb3dDYW1lcmFOZWFyO1xuXHRsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSB0aGlzLnNoYWRvd0NhbWVyYUZhcjtcblxuXHRsaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gdGhpcy5zaGFkb3dDYW1lcmFMZWZ0O1xuXHRsaWdodC5zaGFkb3dDYW1lcmFSaWdodCA9IHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQ7XG5cdGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCA9IHRoaXMuc2hhZG93Q2FtZXJhVG9wO1xuXHRsaWdodC5zaGFkb3dDYW1lcmFCb3R0b20gPSB0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbTtcblxuXHRsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG5cdGxpZ2h0LnNoYWRvd0JpYXMgPSB0aGlzLnNoYWRvd0JpYXM7XG5cdGxpZ2h0LnNoYWRvd0RhcmtuZXNzID0gdGhpcy5zaGFkb3dEYXJrbmVzcztcblxuXHRsaWdodC5zaGFkb3dNYXBXaWR0aCA9IHRoaXMuc2hhZG93TWFwV2lkdGg7XG5cdGxpZ2h0LnNoYWRvd01hcEhlaWdodCA9IHRoaXMuc2hhZG93TWFwSGVpZ2h0O1xuXG5cdC8vXG5cblx0bGlnaHQuc2hhZG93Q2FzY2FkZSA9IHRoaXMuc2hhZG93Q2FzY2FkZTtcblxuXHRsaWdodC5zaGFkb3dDYXNjYWRlT2Zmc2V0LmNvcHkoIHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCApO1xuXHRsaWdodC5zaGFkb3dDYXNjYWRlQ291bnQgPSB0aGlzLnNoYWRvd0Nhc2NhZGVDb3VudDtcblxuXHRsaWdodC5zaGFkb3dDYXNjYWRlQmlhcyA9IHRoaXMuc2hhZG93Q2FzY2FkZUJpYXMuc2xpY2UoIDAgKTtcblx0bGlnaHQuc2hhZG93Q2FzY2FkZVdpZHRoID0gdGhpcy5zaGFkb3dDYXNjYWRlV2lkdGguc2xpY2UoIDAgKTtcblx0bGlnaHQuc2hhZG93Q2FzY2FkZUhlaWdodCA9IHRoaXMuc2hhZG93Q2FzY2FkZUhlaWdodC5zbGljZSggMCApO1xuXG5cdGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWiA9IHRoaXMuc2hhZG93Q2FzY2FkZU5lYXJaLnNsaWNlKCAwICk7XG5cdGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaICA9IHRoaXMuc2hhZG93Q2FzY2FkZUZhclouc2xpY2UoIDAgKTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uICggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcblxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMTAwLCAwICk7XG5cblx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgpO1xuXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG5cdGxpZ2h0Lmdyb3VuZENvbG9yLmNvcHkoIHRoaXMuZ3JvdW5kQ29sb3IgKTtcblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cblx0cmV0dXJuIGxpZ2h0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCk7XG5cblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XG5cblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cdGxpZ2h0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9TcG90TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCApIHtcblxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG5cdHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG5cdHRoaXMuZXhwb25lbnQgPSAoIGV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGV4cG9uZW50IDogMTA7XG5cblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG5cdHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFGb3YgPSA1MDtcblxuXHR0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcblxuXHR0aGlzLnNoYWRvd0JpYXMgPSAwO1xuXHR0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuXG5cdHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XG5cdHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuXHR0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG5cdHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoKTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuXHRsaWdodC50YXJnZXQgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXG5cdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXHRsaWdodC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG5cdGxpZ2h0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0bGlnaHQuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xuXG5cdGxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG5cdGxpZ2h0Lm9ubHlTaGFkb3cgPSB0aGlzLm9ubHlTaGFkb3c7XG5cblx0Ly9cblxuXHRsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gdGhpcy5zaGFkb3dDYW1lcmFOZWFyO1xuXHRsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSB0aGlzLnNoYWRvd0NhbWVyYUZhcjtcblx0bGlnaHQuc2hhZG93Q2FtZXJhRm92ID0gdGhpcy5zaGFkb3dDYW1lcmFGb3Y7XG5cblx0bGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuXHRsaWdodC5zaGFkb3dCaWFzID0gdGhpcy5zaGFkb3dCaWFzO1xuXHRsaWdodC5zaGFkb3dEYXJrbmVzcyA9IHRoaXMuc2hhZG93RGFya25lc3M7XG5cblx0bGlnaHQuc2hhZG93TWFwV2lkdGggPSB0aGlzLnNoYWRvd01hcFdpZHRoO1xuXHRsaWdodC5zaGFkb3dNYXBIZWlnaHQgPSB0aGlzLnNoYWRvd01hcEhlaWdodDtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ2FjaGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNhY2hlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZmlsZXMgPSB7fTtcblxufTtcblxuVEhSRUUuQ2FjaGUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DYWNoZSxcblxuXHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG5cdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmZpbGVzID0ge31cblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkZXIgPSBmdW5jdGlvbiAoIHNob3dTdGF0dXMgKSB7XG5cblx0dGhpcy5zaG93U3RhdHVzID0gc2hvd1N0YXR1cztcblx0dGhpcy5zdGF0dXNEb21FbGVtZW50ID0gc2hvd1N0YXR1cyA/IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuYWRkU3RhdHVzRWxlbWVudCgpIDogbnVsbDtcblxuXHR0aGlzLmltYWdlTG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cblx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG5cdHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcblxufTtcblxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxuXG5cdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0YWRkU3RhdHVzRWxlbWVudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG5cdFx0ZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0ZS5zdHlsZS5yaWdodCA9ICcwcHgnO1xuXHRcdGUuc3R5bGUudG9wID0gJzBweCc7XG5cdFx0ZS5zdHlsZS5mb250U2l6ZSA9ICcwLjhlbSc7XG5cdFx0ZS5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cdFx0ZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMCwwLDAsMC4yNSknO1xuXHRcdGUuc3R5bGUuY29sb3IgPSAnI2ZmZic7XG5cdFx0ZS5zdHlsZS53aWR0aCA9ICcxMjBweCc7XG5cdFx0ZS5zdHlsZS5wYWRkaW5nID0gJzAuNWVtIDAuNWVtIDAuNWVtIDAuNWVtJztcblx0XHRlLnN0eWxlLnpJbmRleCA9IDEwMDA7XG5cblx0XHRlLmlubmVySFRNTCA9ICdMb2FkaW5nIC4uLic7XG5cblx0XHRyZXR1cm4gZTtcblxuXHR9LFxuXG5cdHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoIHByb2dyZXNzICkge1xuXG5cdFx0dmFyIG1lc3NhZ2UgPSAnTG9hZGVkICc7XG5cblx0XHRpZiAoIHByb2dyZXNzLnRvdGFsICkge1xuXG5cdFx0XHRtZXNzYWdlICs9ICggMTAwICogcHJvZ3Jlc3MubG9hZGVkIC8gcHJvZ3Jlc3MudG90YWwgKS50b0ZpeGVkKCAwICkgKyAnJSc7XG5cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1lc3NhZ2UgKz0gKCBwcm9ncmVzcy5sb2FkZWQgLyAxMDI0ICkudG9GaXhlZCggMiApICsgJyBLQic7XG5cblx0XHR9XG5cblx0XHR0aGlzLnN0YXR1c0RvbUVsZW1lbnQuaW5uZXJIVE1MID0gbWVzc2FnZTtcblxuXHR9LFxuXG5cdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG5cdFx0cGFydHMucG9wKCk7XG5cblx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XG5cblx0fSxcblxuXHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGggKSB7XG5cblx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdG5lZWRzVGFuZ2VudHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG0gPSBtYXRlcmlhbHNbIGkgXTtcblxuXHRcdFx0aWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoIG0sIHRleHR1cmVQYXRoICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIG5lYXJlc3RfcG93MiggbiApIHtcblxuXHRcdFx0dmFyIGwgPSBNYXRoLmxvZyggbiApIC8gTWF0aC5MTjI7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoICBsICkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZV90ZXh0dXJlKCB3aGVyZSwgbmFtZSwgc291cmNlRmlsZSwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XG5cblx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgc291cmNlRmlsZTtcblxuXHRcdFx0dmFyIHRleHR1cmU7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xuXG5cdFx0XHRpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cblx0XHRcdFx0bG9hZGVyID0gc2NvcGUuaW1hZ2VMb2FkZXI7XG5cdFx0XHRcdGxvYWRlci5jcm9zc09yaWdpbiA9IHNjb3BlLmNyb3NzT3JpZ2luO1xuXHRcdFx0XHRsb2FkZXIubG9hZCggZnVsbFBhdGgsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdFx0IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB3aWR0aCA9IG5lYXJlc3RfcG93MiggaW1hZ2Uud2lkdGggKTtcblx0XHRcdFx0XHRcdHZhciBoZWlnaHQgPSBuZWFyZXN0X3BvdzIoIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRcdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBjYW52YXM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS5zb3VyY2VGaWxlID0gc291cmNlRmlsZTtcblxuXHRcdFx0aWYgKCByZXBlYXQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuc2V0KCByZXBlYXRbIDAgXSwgcmVwZWF0WyAxIF0gKTtcblxuXHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHRpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRleHR1cmUub2Zmc2V0LnNldCggb2Zmc2V0WyAwIF0sIG9mZnNldFsgMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3cmFwICkge1xuXG5cdFx0XHRcdHZhciB3cmFwTWFwID0ge1xuXHRcdFx0XHRcdCdyZXBlYXQnOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcblx0XHRcdFx0XHQnbWlycm9yJzogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB3cmFwTWFwWyB3cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwUyA9IHdyYXBNYXBbIHdyYXBbIDAgXSBdO1xuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cblx0XHRcdH1cblxuXHRcdFx0d2hlcmVbIG5hbWUgXSA9IHRleHR1cmU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZ2IyaGV4KCByZ2IgKSB7XG5cblx0XHRcdHJldHVybiAoIHJnYlsgMCBdICogMjU1IDw8IDE2ICkgKyAoIHJnYlsgMSBdICogMjU1IDw8IDggKSArIHJnYlsgMiBdICogMjU1O1xuXG5cdFx0fVxuXG5cdFx0Ly8gZGVmYXVsdHNcblxuXHRcdHZhciBtdHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblx0XHR2YXIgbXBhcnMgPSB7IGNvbG9yOiAweGVlZWVlZSwgb3BhY2l0eTogMS4wLCBtYXA6IG51bGwsIGxpZ2h0TWFwOiBudWxsLCBub3JtYWxNYXA6IG51bGwsIGJ1bXBNYXA6IG51bGwsIHdpcmVmcmFtZTogZmFsc2UgfTtcblxuXHRcdC8vIHBhcmFtZXRlcnMgZnJvbSBtb2RlbCBmaWxlXG5cblx0XHRpZiAoIG0uc2hhZGluZyApIHtcblxuXHRcdFx0dmFyIHNoYWRpbmcgPSBtLnNoYWRpbmcudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBzaGFkaW5nID09PSAncGhvbmcnICkgbXR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXHRcdFx0ZWxzZSBpZiAoIHNoYWRpbmcgPT09ICdiYXNpYycgKSBtdHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiBUSFJFRVsgbS5ibGVuZGluZyBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1wYXJzLmJsZW5kaW5nID0gVEhSRUVbIG0uYmxlbmRpbmcgXTtcblxuXHRcdH1cblxuXHRcdGlmICggbS50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkIHx8IG0ub3BhY2l0eSA8IDEuMCApIHtcblxuXHRcdFx0bXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcblxuXHRcdH1cblxuXHRcdGlmICggbS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1wYXJzLmRlcHRoV3JpdGUgPSBtLmRlcHRoV3JpdGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtcGFycy52aXNpYmxlID0gbS52aXNpYmxlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLmZsaXBTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtcGFycy5zaWRlID0gVEhSRUUuQmFja1NpZGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0uZG91YmxlU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bXBhcnMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1wYXJzLndpcmVmcmFtZSA9IG0ud2lyZWZyYW1lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG0udmVydGV4Q29sb3JzID09PSAnZmFjZScgKSB7XG5cblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcblxuXHRcdFx0fSBlbHNlIGlmICggbS52ZXJ0ZXhDb2xvcnMgKSB7XG5cblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjb2xvcnNcblxuXHRcdGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XG5cblx0XHRcdG1wYXJzLmNvbG9yID0gcmdiMmhleCggbS5jb2xvckRpZmZ1c2UgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG0uRGJnQ29sb3IgKSB7XG5cblx0XHRcdG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcblxuXHRcdH1cblxuXHRcdGlmICggbS5jb2xvclNwZWN1bGFyICkge1xuXG5cdFx0XHRtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLmNvbG9yQW1iaWVudCApIHtcblxuXHRcdFx0bXBhcnMuYW1iaWVudCA9IHJnYjJoZXgoIG0uY29sb3JBbWJpZW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0uY29sb3JFbWlzc2l2ZSApIHtcblxuXHRcdFx0bXBhcnMuZW1pc3NpdmUgPSByZ2IyaGV4KCBtLmNvbG9yRW1pc3NpdmUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vZGlmaWVyc1xuXG5cdFx0aWYgKCBtLnRyYW5zcGFyZW5jeSApIHtcblxuXHRcdFx0bXBhcnMub3BhY2l0eSA9IG0udHJhbnNwYXJlbmN5O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLnNwZWN1bGFyQ29lZiApIHtcblxuXHRcdFx0bXBhcnMuc2hpbmluZXNzID0gbS5zcGVjdWxhckNvZWY7XG5cblx0XHR9XG5cblx0XHQvLyB0ZXh0dXJlc1xuXG5cdFx0aWYgKCBtLm1hcERpZmZ1c2UgJiYgdGV4dHVyZVBhdGggKSB7XG5cblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ21hcCcsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBMaWdodCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbGlnaHRNYXAnLCBtLm1hcExpZ2h0LCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBCdW1wICYmIHRleHR1cmVQYXRoICkge1xuXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdidW1wTWFwJywgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbm9ybWFsTWFwJywgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBTcGVjdWxhciAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnc3BlY3VsYXJNYXAnLCBtLm1hcFNwZWN1bGFyLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBBbHBoYSAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYWxwaGFNYXAnLCBtLm1hcEFscGhhLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIG0ubWFwQnVtcFNjYWxlICkge1xuXG5cdFx0XHRtcGFycy5idW1wU2NhbGUgPSBtLm1hcEJ1bXBTY2FsZTtcblxuXHRcdH1cblxuXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3Igbm9ybWFsIG1hcHBlZCBtYXRlcmlhbFxuXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCApIHtcblxuXHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgJ25vcm1hbG1hcCcgXTtcblx0XHRcdHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdFx0XHR1bmlmb3Jtc1sgJ3ROb3JtYWwnIF0udmFsdWUgPSBtcGFycy5ub3JtYWxNYXA7XG5cblx0XHRcdGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbICd1Tm9ybWFsU2NhbGUnIF0udmFsdWUuc2V0KCBtLm1hcE5vcm1hbEZhY3RvciwgbS5tYXBOb3JtYWxGYWN0b3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1wYXJzLm1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgJ3REaWZmdXNlJyBdLnZhbHVlID0gbXBhcnMubWFwO1xuXHRcdFx0XHR1bmlmb3Jtc1sgJ2VuYWJsZURpZmZ1c2UnIF0udmFsdWUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbXBhcnMuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbICd0U3BlY3VsYXInIF0udmFsdWUgPSBtcGFycy5zcGVjdWxhck1hcDtcblx0XHRcdFx0dW5pZm9ybXNbICdlbmFibGVTcGVjdWxhcicgXS52YWx1ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtcGFycy5saWdodE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgJ3RBTycgXS52YWx1ZSA9IG1wYXJzLmxpZ2h0TWFwO1xuXHRcdFx0XHR1bmlmb3Jtc1sgJ2VuYWJsZUFPJyBdLnZhbHVlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgdGhlIG1vbWVudCBkb24ndCBoYW5kbGUgZGlzcGxhY2VtZW50IHRleHR1cmVcblxuXHRcdFx0dW5pZm9ybXNbICdkaWZmdXNlJyBdLnZhbHVlLnNldEhleCggbXBhcnMuY29sb3IgKTtcblx0XHRcdHVuaWZvcm1zWyAnc3BlY3VsYXInIF0udmFsdWUuc2V0SGV4KCBtcGFycy5zcGVjdWxhciApO1xuXHRcdFx0dW5pZm9ybXNbICdhbWJpZW50JyBdLnZhbHVlLnNldEhleCggbXBhcnMuYW1iaWVudCApO1xuXG5cdFx0XHR1bmlmb3Jtc1sgJ3NoaW5pbmVzcycgXS52YWx1ZSA9IG1wYXJzLnNoaW5pbmVzcztcblxuXHRcdFx0aWYgKCBtcGFycy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbICdvcGFjaXR5JyBdLnZhbHVlID0gbXBhcnMub3BhY2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxuXHRcdFx0aWYgKCBtcGFycy50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbXR5cGUgXSggbXBhcnMgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5EYmdOYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbS5EYmdOYW1lO1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xuXG5cdGhhbmRsZXJzOiBbXSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcblxuXHRcdHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xuXG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0dmFyIHJlZ2V4ID0gdGhpcy5oYW5kbGVyc1sgaSBdO1xuXHRcdFx0dmFyIGxvYWRlciAgPSB0aGlzLmhhbmRsZXJzWyBpICsgMSBdO1xuXG5cdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5jYWNoZSA9IG5ldyBUSFJFRS5DYWNoZSgpO1xuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGNhY2hlZCA9IHNjb3BlLmNhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xuXG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdHNjb3BlLmNhY2hlLmFkZCggdXJsLCB0aGlzLnJlc3BvbnNlICk7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzLnJlc3BvbnNlICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9LCBmYWxzZSApO1xuXG5cdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRvblByb2dyZXNzKCBldmVudCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblx0XHRpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuXG5cdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XG5cblx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0fSxcblxuXHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLmNhY2hlID0gbmV3IFRIUkVFLkNhY2hlKCk7XG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGNhY2hlZCA9IHNjb3BlLmNhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRvbkxvYWQoIGNhY2hlZCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcblxuXHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRzY29wZS5jYWNoZS5hZGQoIHVybCwgdGhpcyApO1xuXG5cdFx0XHRcdG9uTG9hZCggdGhpcyApO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdFx0b25Qcm9ncmVzcyggZXZlbnQgKTtcblxuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdG9uRXJyb3IoIGV2ZW50ICk7XG5cblx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuXHRcdGltYWdlLnNyYyA9IHVybDtcblxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdH1cblxufVxuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5KU09OTG9hZGVyID0gZnVuY3Rpb24gKCBzaG93U3RhdHVzICkge1xuXG5cdFRIUkVFLkxvYWRlci5jYWxsKCB0aGlzLCBzaG93U3RhdHVzICk7XG5cblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Mb2FkZXIucHJvdG90eXBlICk7XG5cblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0Ly8gdG9kbzogdW5pZnkgbG9hZCBBUEkgdG8gZm9yIGVhc2llciBTY2VuZUxvYWRlciB1c2VcblxuXHR0ZXh0dXJlUGF0aCA9IHRleHR1cmVQYXRoICYmICggdHlwZW9mIHRleHR1cmVQYXRoID09PSAnc3RyaW5nJyApID8gdGV4dHVyZVBhdGggOiB0aGlzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHR0aGlzLm9uTG9hZFN0YXJ0KCk7XG5cdHRoaXMubG9hZEFqYXhKU09OKCB0aGlzLCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkQWpheEpTT04gPSBmdW5jdGlvbiAoIGNvbnRleHQsIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoLCBjYWxsYmFja1Byb2dyZXNzICkge1xuXG5cdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHR2YXIgbGVuZ3RoID0gMDtcblxuXHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkRPTkUgKSB7XG5cblx0XHRcdGlmICggeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDAgKSB7XG5cblx0XHRcdFx0aWYgKCB4aHIucmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGpzb24ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1ldGFkYXRhLnR5cGUgPT09ICdzY2VuZScgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiBcIicgKyB1cmwgKyAnXCIgc2VlbXMgdG8gYmUgYSBTY2VuZS4gVXNlIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIHJlc3VsdC5nZW9tZXRyeSwgcmVzdWx0Lm1hdGVyaWFscyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogXCInICsgdXJsICsgJ1wiIHNlZW1zIHRvIGJlIHVucmVhY2hhYmxlIG9yIHRoZSBmaWxlIGlzIGVtcHR5LicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaW4gY29udGV4dCBvZiBtb3JlIGNvbXBsZXggYXNzZXQgaW5pdGlhbGl6YXRpb25cblx0XHRcdFx0Ly8gZG8gbm90IGJsb2NrIG9uIHNpbmdsZSBmYWlsZWQgZmlsZVxuXHRcdFx0XHQvLyBtYXliZSBzaG91bGQgZ28gZXZlbiBvbmUgbW9yZSBsZXZlbCB1cFxuXG5cdFx0XHRcdGNvbnRleHQub25Mb2FkQ29tcGxldGUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogQ291bGRuXFwndCBsb2FkIFwiJyArIHVybCArICdcIiAoJyArIHhoci5zdGF0dXMgKyAnKScgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5MT0FESU5HICkge1xuXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XG5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoICdDb250ZW50LUxlbmd0aCcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2tQcm9ncmVzcyggeyB0b3RhbDogbGVuZ3RoLCBsb2FkZWQ6IHhoci5yZXNwb25zZVRleHQubGVuZ3RoIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5IRUFERVJTX1JFQ0VJVkVEICkge1xuXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoICdDb250ZW50LUxlbmd0aCcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0eGhyLm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXHR4aHIuc2VuZCggbnVsbCApO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XG5cblx0dmFyIHNjb3BlID0gdGhpcyxcblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcblx0c2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcblxuXHRwYXJzZU1vZGVsKCBzY2FsZSApO1xuXG5cdHBhcnNlU2tpbigpO1xuXHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xuXG5cdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuXHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XG5cblx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIGZpLFxuXG5cdFx0b2Zmc2V0LCB6TGVuZ3RoLFxuXG5cdFx0Y29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXG5cblx0XHR0eXBlLFxuXHRcdGlzUXVhZCxcblx0XHRoYXNNYXRlcmlhbCxcblx0XHRoYXNGYWNlVmVydGV4VXYsXG5cdFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcblx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcblxuXHRcdHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBjb2xvciwgaGV4LCBub3JtYWwsXG5cblx0XHR1dkxheWVyLCB1diwgdSwgdixcblxuXHRcdGZhY2VzID0ganNvbi5mYWNlcyxcblx0XHR2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXG5cdFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcblx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcblxuXHRcdG5VdkxheWVycyA9IDA7XG5cblx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ID0gMDtcblx0XHR6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHR2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuXHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ID0gMDtcblx0XHR6TGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cblx0XHRcdGlzUXVhZCAgICAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMCApO1xuXHRcdFx0aGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XG5cdFx0XHRoYXNGYWNlVmVydGV4VXYgICAgID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcblx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xuXHRcdFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG5cdFx0XHRoYXNGYWNlQ29sb3JcdCAgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xuXHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XG5cblx0XHRcdGlmICggaXNRdWFkICkge1xuXG5cdFx0XHRcdGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XG5cdFx0XHRcdGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XG5cdFx0XHRcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuXHRcdFx0XHRmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xuXHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcblx0XHRcdFx0ZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XG5cdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0XHRcdG9mZnNldCArPSA0O1xuXG5cdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuXHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW11cblxuXHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCA0OyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG5cdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHR1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAyICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRmYWNlQS5ub3JtYWwuc2V0KFxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHQpO1xuXG5cblx0XHRcdFx0XHRcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuXHRcdFx0XHRcdGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XG5cdFx0XHRcdFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUEgKTtcblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCk7XG5cdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cblx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcblx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRmYWNlLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuXHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cdFx0dmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xuXG5cdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuXHRcdFx0XHR2YXIgeCA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbldlaWdodHNbIGkgICAgIF07XG5cdFx0XHRcdHZhciB5ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDEgXSA6IDA7XG5cdFx0XHRcdHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XG5cdFx0XHRcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2tpbldlaWdodHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIHgsIHksIHosIHcgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uc2tpbkluZGljZXMgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG5cdFx0XHRcdHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSAgICAgXTtcblx0XHRcdFx0dmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcblx0XHRcdFx0dmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcblx0XHRcdFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcblxuXHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuXHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuXHRcdH1cblxuXG5cdFx0Ly8gY291bGQgY2hhbmdlIHRoaXMgdG8ganNvbi5hbmltYXRpb25zWzBdIG9yIHJlbW92ZSBjb21wbGV0ZWx5XG5cblx0XHRnZW9tZXRyeS5hbmltYXRpb24gPSBqc29uLmFuaW1hdGlvbjtcblx0XHRnZW9tZXRyeS5hbmltYXRpb25zID0ganNvbi5hbmltYXRpb25zO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cblx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBpLCBsLCB2LCB2bCwgZHN0VmVydGljZXMsIHNyY1ZlcnRpY2VzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuXHRcdFx0XHRkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXHRcdFx0XHRzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzIFsgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdGZvciAoIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xuXG5cdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGksIGwsIGMsIGNsLCBkc3RDb2xvcnMsIHNyY0NvbG9ycywgY29sb3I7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaENvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0gPSB7fTtcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5uYW1lID0ganNvbi5tb3JwaENvbG9yc1sgaSBdLm5hbWU7XG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XG5cblx0XHRcdFx0ZHN0Q29sb3JzID0gZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnM7XG5cdFx0XHRcdHNyY0NvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnMgWyBpIF0uY29sb3JzO1xuXG5cdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IHNyY0NvbG9ycy5sZW5ndGg7IGMgPCBjbDsgYyArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICk7XG5cdFx0XHRcdFx0Y29sb3Iuc2V0UkdCKCBzcmNDb2xvcnNbIGMgXSwgc3JjQ29sb3JzWyBjICsgMSBdLCBzcmNDb2xvcnNbIGMgKyAyIF0gKTtcblx0XHRcdFx0XHRkc3RDb2xvcnMucHVzaCggY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dmFyIG1hdGVyaWFscyA9IHRoaXMuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoICk7XG5cblx0XHRpZiAoIHRoaXMubmVlZHNUYW5nZW50cyggbWF0ZXJpYWxzICkgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5LCBtYXRlcmlhbHM6IG1hdGVyaWFscyB9O1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTG9hZGluZ01hbmFnZXIgPSBmdW5jdGlvbiAoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBsb2FkZWQgPSAwLCB0b3RhbCA9IDA7XG5cblx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG5cdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG5cdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cblx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdHRvdGFsICsrO1xuXG5cdH07XG5cblx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRsb2FkZWQgKys7XG5cblx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUub25Qcm9ncmVzcyggdXJsLCBsb2FkZWQsIHRvdGFsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGxvYWRlZCA9PT0gdG90YWwgJiYgc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNjb3BlLm9uTG9hZCgpO1xuXG5cdFx0fVxuXG5cdH07XG5cbn07XG5cblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCk7XG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IGpzb24uYXR0cmlidXRlcztcblxuXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgYXR0cmlidXRlLnR5cGUgXSggYXR0cmlidXRlLmFycmF5ICk7XG5cblx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldHMgPSBqc29uLm9mZnNldHM7XG5cblx0XHRpZiAoIG9mZnNldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2VvbWV0cnkub2Zmc2V0cyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBvZmZzZXRzICkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xuXG5cdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcblx0XHRpZiAoIGpzb24uYW1iaWVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW1iaWVudC5zZXRIZXgoIGpzb24uYW1iaWVudCApO1xuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcblx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3Jtcztcblx0XHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcblx0XHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcdFx0XG5cdFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG5cdFx0aWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRpbmcgPSBqc29uLnNoYWRpbmc7XG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG5cdFx0aWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG5cdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG5cblx0XHRpZiAoIGpzb24ubWF0ZXJpYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcyApO1xuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscyApO1xuXHRcdHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH0sXG5cblx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XG5cdFx0XHR2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeTtcblx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnUGxhbmVHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQm94R2VvbWV0cnknOlxuXHRcdFx0XHRcdGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aCxcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoU2VnbWVudHNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzVG9wLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c0JvdHRvbSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuYXJjXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnR1YmUsXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnAsXG5cdFx0XHRcdFx0XHRcdGRhdGEucSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTY2FsZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhICkuZ2VvbWV0cnk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0XHRcdGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXG5cdH0sXG5cblx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0XHRtYXRlcmlhbHNbIGRhdGEudXVpZCBdID0gbWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cblx0fSxcblxuXHRwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdTY2VuZSc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5leHBvbmVudCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdNZXNoJzpcblxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGRhdGEuZ2VvbWV0cnkgXTtcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGRhdGEubWF0ZXJpYWwgXTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBkYXRhLmdlb21ldHJ5ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTGluZSc6XG5cblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBkYXRhLmdlb21ldHJ5IF07XG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBkYXRhLm1hdGVyaWFsIF07XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgZGF0YS5nZW9tZXRyeSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1Nwcml0ZSc6XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGRhdGEubWF0ZXJpYWwgXTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBkYXRhLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnR3JvdXAnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG5cdFx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcblx0XHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuXHRcdFx0aWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLmNoaWxkcmVuWyBjaGlsZCBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fVxuXG5cdH0oKVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlICk7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAqL1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xuXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdGlmICggdXJsIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cblx0XHRcdHZhciBsb2FkZWQgPSAwO1xuXG5cdFx0XHR2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XG5cdFx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcblx0XHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuXHRcdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gXHRcdFx0XHRcdFx0aWYgKHRleERhdGFzLm1pcG1hcENvdW50ID09IDEpXG4gXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuTWF0ZXJpYWxJZENvdW50ICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcblxuXHR0aGlzLm9wYWNpdHkgPSAxO1xuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cblx0dGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG5cdHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3Rvcjtcblx0dGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xuXG5cdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcblx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblxuXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcblx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xuXG5cdHRoaXMuYWxwaGFUZXN0ID0gMDtcblxuXHR0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxuXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXG5cblx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcblxuXHRcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBrZXkgaW4gdGhpcyApIHtcblxuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBrZXkgPT0gJ292ZXJkcmF3JyApIHtcblxuXHRcdFx0XHRcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0YWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG91dHB1dCA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuMixcblx0XHRcdFx0dHlwZTogJ21hdGVyaWFsJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWxFeHBvcnRlcidcblx0XHRcdH0sXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHR0eXBlOiB0aGlzLnR5cGVcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09IFwiXCIgKSBvdXRwdXQubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdGlmICggdGhpcyBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRvdXRwdXQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBvdXRwdXQudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgb3V0cHV0LmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBvdXRwdXQuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG5cdFx0XHRvdXRwdXQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdFx0b3V0cHV0LmFtYmllbnQgPSB0aGlzLmFtYmllbnQuZ2V0SGV4KCk7XG5cdFx0XHRvdXRwdXQuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xuXHRcdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBvdXRwdXQudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgb3V0cHV0LmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBvdXRwdXQuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0b3V0cHV0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblx0XHRcdG91dHB1dC5hbWJpZW50ID0gdGhpcy5hbWJpZW50LmdldEhleCgpO1xuXHRcdFx0b3V0cHV0LmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcblx0XHRcdG91dHB1dC5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG5cdFx0XHRvdXRwdXQuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cdFx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIG91dHB1dC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblx0XHRcdGlmICggdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBvdXRwdXQuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdFx0aWYgKCB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIG91dHB1dC5zaWRlID0gdGhpcy5zaWRlO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcyBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLkZsYXRTaGFkaW5nICkgb3V0cHV0LnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgb3V0cHV0LmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBvdXRwdXQuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIG91dHB1dC5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cdFx0XHRpZiAoIHRoaXMuc2lkZSAhPT0gVEhSRUUuRnJvbnRTaWRlICkgb3V0cHV0LnNpZGUgPSB0aGlzLnNpZGU7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdG91dHB1dC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG5cdFx0XHRvdXRwdXQudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRvdXRwdXQuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcyBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZU1hdGVyaWFsICkge1xuXG5cdFx0XHRvdXRwdXQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgb3V0cHV0Lm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ICE9PSBmYWxzZSApIG91dHB1dC50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZSAhPT0gZmFsc2UgKSBvdXRwdXQud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NYXRlcmlhbCgpO1xuXG5cdFx0bWF0ZXJpYWwubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdG1hdGVyaWFsLnNpZGUgPSB0aGlzLnNpZGU7XG5cblx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcblxuXHRcdG1hdGVyaWFsLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblxuXHRcdG1hdGVyaWFsLmJsZW5kU3JjID0gdGhpcy5ibGVuZFNyYztcblx0XHRtYXRlcmlhbC5ibGVuZERzdCA9IHRoaXMuYmxlbmREc3Q7XG5cdFx0bWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiA9IHRoaXMuYmxlbmRFcXVhdGlvbjtcblxuXHRcdG1hdGVyaWFsLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuXHRcdG1hdGVyaWFsLmRlcHRoV3JpdGUgPSB0aGlzLmRlcHRoV3JpdGU7XG5cblx0XHRtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gdGhpcy5wb2x5Z29uT2Zmc2V0O1xuXHRcdG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0bWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cblx0XHRtYXRlcmlhbC5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblxuXHRcdG1hdGVyaWFsLm92ZXJkcmF3ID0gdGhpcy5vdmVyZHJhdztcblxuXHRcdG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG5cdG1hdGVyaWFsLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xuXHRtYXRlcmlhbC5saW5lY2FwID0gdGhpcy5saW5lY2FwO1xuXHRtYXRlcmlhbC5saW5lam9pbiA9IHRoaXMubGluZWpvaW47XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZURhc2hlZE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHNjYWxlOiA8ZmxvYXQ+LFxuICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxuICogIGdhcFNpemU6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLnNjYWxlID0gMTtcblx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cdHRoaXMuZ2FwU2l6ZSA9IDE7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoKTtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cblx0bWF0ZXJpYWwubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XG5cblx0bWF0ZXJpYWwuc2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRtYXRlcmlhbC5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemU7XG5cdG1hdGVyaWFsLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCk7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xuXG5cdG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcDtcblxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XG5cblx0bWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwO1xuXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xuXHRtYXRlcmlhbC5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xuXHRtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcblx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0bWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcblxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuXHRtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBhbWJpZW50OiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqXHRmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cdHRoaXMuYW1iaWVudCA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcblxuXHR0aGlzLndyYXBBcm91bmQgPSBmYWxzZTtcblx0dGhpcy53cmFwUkdCID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cblx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblx0bWF0ZXJpYWwuYW1iaWVudC5jb3B5KCB0aGlzLmFtYmllbnQgKTtcblx0bWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xuXG5cdG1hdGVyaWFsLndyYXBBcm91bmQgPSB0aGlzLndyYXBBcm91bmQ7XG5cdG1hdGVyaWFsLndyYXBSR0IuY29weSggdGhpcy53cmFwUkdCICk7XG5cblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xuXG5cdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcblxuXHRtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cblx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XG5cdG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuXHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcblxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hQaG9uZ01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgYW1iaWVudDogPGhleD4sXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIHNwZWN1bGFyOiA8aGV4PixcbiAqICBzaGluaW5lc3M6IDxmbG9hdD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXG4gKlxuICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHR0aGlzLmFtYmllbnQgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XG5cdHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XG5cdHRoaXMuc2hpbmluZXNzID0gMzA7XG5cblx0dGhpcy5tZXRhbCA9IGZhbHNlO1xuXG5cdHRoaXMud3JhcEFyb3VuZCA9IGZhbHNlO1xuXHR0aGlzLndyYXBSR0IgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXHRtYXRlcmlhbC5hbWJpZW50LmNvcHkoIHRoaXMuYW1iaWVudCApO1xuXHRtYXRlcmlhbC5lbWlzc2l2ZS5jb3B5KCB0aGlzLmVtaXNzaXZlICk7XG5cdG1hdGVyaWFsLnNwZWN1bGFyLmNvcHkoIHRoaXMuc3BlY3VsYXIgKTtcblx0bWF0ZXJpYWwuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cblx0bWF0ZXJpYWwubWV0YWwgPSB0aGlzLm1ldGFsO1xuXG5cdG1hdGVyaWFsLndyYXBBcm91bmQgPSB0aGlzLndyYXBBcm91bmQ7XG5cdG1hdGVyaWFsLndyYXBSR0IuY29weSggdGhpcy53cmFwUkdCICk7XG5cblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xuXG5cdG1hdGVyaWFsLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXA7XG5cdG1hdGVyaWFsLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXG5cdG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwO1xuXHRtYXRlcmlhbC5ub3JtYWxTY2FsZS5jb3B5KCB0aGlzLm5vcm1hbFNjYWxlICk7XG5cblx0bWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwO1xuXG5cdG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcDtcblxuXHRtYXRlcmlhbC5lbnZNYXAgPSB0aGlzLmVudk1hcDtcblx0bWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcblx0bWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XG5cdG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcblx0bWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICogfVxuICovXG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRyZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTm9ybWFsTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcblxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5GbGF0U2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hGYWNlTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoRmFjZU1hdGVyaWFsJztcblx0XG5cdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxufTtcblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwsXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC4yLFxuXHRcdFx0XHR0eXBlOiAnbWF0ZXJpYWwnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbEV4cG9ydGVyJ1xuXHRcdFx0fSxcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdG1hdGVyaWFsczogW11cblx0XHR9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0b3V0cHV0Lm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLnRvSlNPTigpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9Qb2ludENsb3VkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc2l6ZTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLnNpemUgPSAxO1xuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoKTtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwuc2l6ZSA9IHRoaXMuc2l6ZTtcblx0bWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcbiAqXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBsaWdodHM6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cblx0dGhpcy5kZWZpbmVzID0ge307XG5cdHRoaXMudW5pZm9ybXMgPSB7fTtcblx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblxuXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59JztcblxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cblxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cblx0Ly8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG5cdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdCdjb2xvcic6IFsgMSwgMSwgMSBdLFxuXHRcdCd1dic6IFsgMCwgMCBdLFxuXHRcdCd1djInOiBbIDAsIDAgXVxuXHR9O1xuXG5cdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcblx0bWF0ZXJpYWwudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG5cblx0bWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCB0aGlzLnVuaWZvcm1zICk7XG5cblx0bWF0ZXJpYWwuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblx0bWF0ZXJpYWwuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcblxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuXHRtYXRlcmlhbC5saWdodHMgPSB0aGlzLmxpZ2h0cztcblxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuXHRtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG5cblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxufTtcblxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwoKTtcblxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuXHRyZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdHRoaXMuZm9nID0gZmFsc2U7XG5cblx0Ly8gc2V0IHBhcmFtZXRlcnNcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5UZXh0dXJlSWRDb3VudCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblxuXHR0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xuXHR0aGlzLm1pcG1hcHMgPSBbXTtcblxuXHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cblx0dGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XG5cdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG5cdHRoaXMuZmxpcFkgPSB0cnVlO1xuXHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cdHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMub25VcGRhdGUgPSBudWxsO1xuXG59O1xuXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IG5ldyBUSFJFRS5VVk1hcHBpbmcoKTtcblxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXG5cblx0Z2V0IG5lZWRzVXBkYXRlICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuXHR9LFxuXG5cdHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cblx0XHR0ZXh0dXJlLmltYWdlID0gdGhpcy5pbWFnZTtcblx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0aGlzLm1pcG1hcHMuc2xpY2UoIDAgKTtcblxuXHRcdHRleHR1cmUubWFwcGluZyA9IHRoaXMubWFwcGluZztcblxuXHRcdHRleHR1cmUud3JhcFMgPSB0aGlzLndyYXBTO1xuXHRcdHRleHR1cmUud3JhcFQgPSB0aGlzLndyYXBUO1xuXG5cdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcblx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xuXG5cdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuXG5cdFx0dGV4dHVyZS5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcblx0XHR0ZXh0dXJlLnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHR0ZXh0dXJlLm9mZnNldC5jb3B5KCB0aGlzLm9mZnNldCApO1xuXHRcdHRleHR1cmUucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cblx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRoaXMucHJlbXVsdGlwbHlBbHBoYTtcblx0XHR0ZXh0dXJlLmZsaXBZID0gdGhpcy5mbGlwWTtcblx0XHR0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IHRoaXMudW5wYWNrQWxpZ25tZW50O1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5cblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN1YmVUZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5pbWFnZXMgPSBpbWFnZXM7XG5cbn07XG5cblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5cblRIUkVFLkN1YmVUZXh0dXJlLmNsb25lID0gZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSgpO1xuXG5cdFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcblxuXHR0ZXh0dXJlLmltYWdlcyA9IHRoaXMuaW1hZ2VzO1xuXG5cdHJldHVybiB0ZXh0dXJlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuXHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuXHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxuXG5cdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG5cdC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcblxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZSA9IGZ1bmN0aW9uICggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG59O1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcblxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL1ZpZGVvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuVmlkZW9UZXh0dXJlID0gZnVuY3Rpb24gKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcblxuXHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA9PT0gdmlkZW8uSEFWRV9FTk9VR0hfREFUQSApIHtcblxuXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0dyb3VwJztcblxufTtcblxuVEhSRUUuR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvUG9pbnRDbG91ZC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZCc7XG5cblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuXHR0aGlzLnNvcnRQYXJ0aWNsZXMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gdGhpcztcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRDbG91ZC50aHJlc2hvbGQ7XG5cblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR2YXIgdGVzdFBvaW50ID0gZnVuY3Rpb24gKCBwb2ludCwgaW5kZXggKSB7XG5cblx0XHRcdHZhciByYXlQb2ludERpc3RhbmNlID0gcmF5LmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcblxuXHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlIDwgbG9jYWxUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0dmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XG5cdFx0XHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHRkaXN0YW5jZVRvUmF5OiByYXlQb2ludERpc3RhbmNlLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSB7XG5cdFx0XHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aCxcblx0XHRcdFx0XHRcdGluZGV4OiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdG9mZnNldHMgPSBbIG9mZnNldCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgb2kgPSAwLCBvbCA9IG9mZnNldHMubGVuZ3RoOyBvaSA8IG9sOyArK29pICkge1xuXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gb2Zmc2V0c1sgb2kgXS5zdGFydDtcblx0XHRcdFx0XHR2YXIgY291bnQgPSBvZmZzZXRzWyBvaSBdLmNvdW50O1xuXHRcdFx0XHRcdHZhciBpbmRleCA9IG9mZnNldHNbIG9pIF0uaW5kZXg7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIHBvaW50Q291bnQgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0KFxuXHRcdFx0XHRcdFx0cG9zaXRpb25zWyAzICogaSBdLFxuXHRcdFx0XHRcdFx0cG9zaXRpb25zWyAzICogaSArIDEgXSxcblx0XHRcdFx0XHRcdHBvc2l0aW9uc1sgMyAqIGkgKyAyIF1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludENsb3VkKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cblx0b2JqZWN0LnNvcnRQYXJ0aWNsZXMgPSB0aGlzLnNvcnRQYXJ0aWNsZXM7XG5cblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludENsb3VkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaW5lJztcblxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cblx0dGhpcy5tb2RlID0gKCBtb2RlICE9PSB1bmRlZmluZWQgKSA/IG1vZGUgOiBUSFJFRS5MaW5lU3RyaXA7XG5cbn07XG5cblRIUkVFLkxpbmVTdHJpcCA9IDA7XG5USFJFRS5MaW5lUGllY2VzID0gMTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHR2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XG5cdFx0dmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHQvKiBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHR9IGVsc2UgKi8gaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXHRcdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHN0ZXAgPSB0aGlzLm1vZGUgPT09IFRIUkVFLkxpbmVTdHJpcCA/IDEgOiAyO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSA9IGkgKyBzdGVwICkge1xuXG5cdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG5cdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLm1vZGUgKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0cmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xuICovXG5cblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2gnO1xuXHRcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG5cdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1vcnBoVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLSAxO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRGb3JjZWRPcmRlciA9IFtdO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcblxuXHR9XG5cblx0Y29uc29sZS5sb2coICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcblxuXHRyZXR1cm4gMDtcblxufTtcblxuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgIHtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRcdHZhciBhLCBiLCBjO1xuXHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5wcmVjaXNpb247XG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0XHRcdHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuXHRcdFx0XHRpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0b2Zmc2V0cyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMubGVuZ3RoLCBpbmRleDogMCB9IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBvaSA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG9pIDwgb2w7ICsrb2kgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBvZmZzZXRzWyBvaSBdLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIG9pIF0uY291bnQ7XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gb2Zmc2V0c1sgb2kgXS5pbmRleDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcblx0XHRcdFx0XHRcdGIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRjID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xuXG5cdFx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblx0XHRcdFx0XHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXHRcdFx0XHRcdFx0dkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGMgKiAzICk7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QSwgdkIsIHZDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHByZWNpc2lvbiB8fCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcblx0XHRcdFx0XHRcdFx0ZmFjZTogbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApLFxuXHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMsIGogKz0gOSApIHtcblxuXHRcdFx0XHRcdGEgPSBpO1xuXHRcdFx0XHRcdGIgPSBpICsgMTtcblx0XHRcdFx0XHRjID0gaSArIDI7XG5cblx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaiApO1xuXHRcdFx0XHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBqICsgMyApO1xuXHRcdFx0XHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBqICsgNiApO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uUG9pbnQgPT09IG51bGwgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCBwcmVjaXNpb24gfHwgZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0aW9uUG9pbnQsXG5cdFx0XHRcdFx0XHRmYWNlOiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICksXG5cdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdHZhciBpc0ZhY2VNYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xuXHRcdFx0dmFyIG9iamVjdE1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gdGhpcy5tYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xuXG5cdFx0XHR2YXIgYSwgYiwgYywgZDtcblx0XHRcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIucHJlY2lzaW9uO1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG9iamVjdE1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiB0aGlzLm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdGIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHRcdGMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdFx0XHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdFx0XHRcdHZBLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdHZDLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdFx0XHR2QS54ICs9ICggdGFyZ2V0c1sgZmFjZS5hIF0ueCAtIGEueCApICogaW5mbHVlbmNlO1xuXHRcdFx0XHRcdFx0dkEueSArPSAoIHRhcmdldHNbIGZhY2UuYSBdLnkgLSBhLnkgKSAqIGluZmx1ZW5jZTtcblx0XHRcdFx0XHRcdHZBLnogKz0gKCB0YXJnZXRzWyBmYWNlLmEgXS56IC0gYS56ICkgKiBpbmZsdWVuY2U7XG5cblx0XHRcdFx0XHRcdHZCLnggKz0gKCB0YXJnZXRzWyBmYWNlLmIgXS54IC0gYi54ICkgKiBpbmZsdWVuY2U7XG5cdFx0XHRcdFx0XHR2Qi55ICs9ICggdGFyZ2V0c1sgZmFjZS5iIF0ueSAtIGIueSApICogaW5mbHVlbmNlO1xuXHRcdFx0XHRcdFx0dkIueiArPSAoIHRhcmdldHNbIGZhY2UuYiBdLnogLSBiLnogKSAqIGluZmx1ZW5jZTtcblxuXHRcdFx0XHRcdFx0dkMueCArPSAoIHRhcmdldHNbIGZhY2UuYyBdLnggLSBjLnggKSAqIGluZmx1ZW5jZTtcblx0XHRcdFx0XHRcdHZDLnkgKz0gKCB0YXJnZXRzWyBmYWNlLmMgXS55IC0gYy55ICkgKiBpbmZsdWVuY2U7XG5cdFx0XHRcdFx0XHR2Qy56ICs9ICggdGFyZ2V0c1sgZmFjZS5jIF0ueiAtIGMueiApICogaW5mbHVlbmNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dkEuYWRkKCBhICk7XG5cdFx0XHRcdFx0dkIuYWRkKCBiICk7XG5cdFx0XHRcdFx0dkMuYWRkKCBjICk7XG5cblx0XHRcdFx0XHRhID0gdkE7XG5cdFx0XHRcdFx0YiA9IHZCO1xuXHRcdFx0XHRcdGMgPSB2QztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0XHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYywgYiwgYSwgdHJ1ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIGEsIGIsIGMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHByZWNpc2lvbiB8fCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcblx0XHRcdFx0XHRmYWNlOiBmYWNlLFxuXHRcdFx0XHRcdGZhY2VJbmRleDogZixcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG59KCkgKTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QsIHJlY3Vyc2l2ZSApO1xuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uICggYmVsb25nc1RvU2tpbiApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5za2luID0gYmVsb25nc1RvU2tpbjtcblxufTtcblxuVEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiAoIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XG5cblx0dGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Ly8gY29weSB0aGUgYm9uZSBhcnJheVxuXG5cdGJvbmVzID0gYm9uZXMgfHwgW107XG5cblx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XG5cblx0Ly8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xuXG5cdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuXHRcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICAoOCAqIDggIC8gNClcblx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICgxNiAqIDE2IC8gNClcblx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICgzMiAqIDMyIC8gNClcblx0XHQvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICg2NCAqIDY0IC8gNClcblxuXHRcdHZhciBzaXplO1xuXG5cdFx0aWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA+IDI1NiApXG5cdFx0XHRzaXplID0gNjQ7XG5cdFx0ZWxzZSBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID4gNjQgKVxuXHRcdFx0c2l6ZSA9IDMyO1xuXHRcdGVsc2UgaWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA+IDE2IClcblx0XHRcdHNpemUgPSAxNjtcblx0XHRlbHNlXG5cdFx0XHRzaXplID0gODtcblxuXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG5cdFx0dGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG5cdFx0dGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XG5cdFx0dGhpcy5ib25lVGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXHRcdHRoaXMuYm9uZVRleHR1cmUubWFnRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLmJvbmVUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdHRoaXMuYm9uZVRleHR1cmUuZmxpcFkgPSBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHRoaXMuYm9uZXMubGVuZ3RoICk7XG5cblx0fVxuXG5cdC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXG5cblx0aWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA9PT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbkludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xuXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgVEhSRUUuTWF0cml4NCgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0dmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0aWYgKCB0aGlzLmJvbmVzWyBiIF0gKSB7XG5cblx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgYm9uZTtcblxuXHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuXHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cblx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdGJvbmUubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuXHRcdGlmICggYm9uZSApIHtcblxuXHRcdFx0aWYgKCBib25lLnBhcmVudCApIHtcblxuXHRcdFx0XHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cblx0XHRcdHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG5cdFx0XHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG5cdFx0XHRvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblx0XHRcblx0fTtcblxufSApKCk7XG5cblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cblx0dGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcblx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Ly8gaW5pdCBib25lc1xuXG5cdC8vIFRPRE86IHJlbW92ZSBib25lIGNyZWF0aW9uIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiAob3RoZXIgdGhhblxuXHQvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXG5cblx0dmFyIGJvbmVzID0gW107XG5cblx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHZhciBib25lLCBnYm9uZSwgcCwgcSwgcztcblxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArK2IgKSB7XG5cblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG5cdFx0XHRwID0gZ2JvbmUucG9zO1xuXHRcdFx0cSA9IGdib25lLnJvdHE7XG5cdFx0XHRzID0gZ2JvbmUuc2NsO1xuXG5cdFx0XHRib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcblx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcblxuXHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcblx0XHRcdGJvbmUucG9zaXRpb24uc2V0KCBwWyAwIF0sIHBbIDEgXSwgcFsgMiBdICk7XG5cdFx0XHRib25lLnF1YXRlcm5pb24uc2V0KCBxWyAwIF0sIHFbIDEgXSwgcVsgMiBdLCBxWyAzIF0gKTtcblxuXHRcdFx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym9uZS5zY2FsZS5zZXQoIHNbIDAgXSwgc1sgMSBdLCBzWyAyIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib25lLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKytiICkge1xuXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuXHRcdFx0aWYgKCBnYm9uZS5wYXJlbnQgIT09IC0gMSApIHtcblxuXHRcdFx0XHRib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgYiBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXHR0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApICk7XG5cbn07XG5cblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cblx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG5cdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0fVxuXG5cdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG5cdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG5cdGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuXHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XG5cblx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRcdHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIHNraW5uaW5nIHdlaWdodHMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIGZvciBUSFJFRS5CdWZmZXJHZW9tZXRyeVxuXG5cdH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24oIGZvcmNlICkge1xuXG5cdFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcblxuXHRpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcblxuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcblxuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVja29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG5cdH1cblxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTW9ycGhBbmltTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy50eXBlID0gJ01vcnBoQW5pbU1lc2gnO1xuXG5cdC8vIEFQSVxuXG5cdHRoaXMuZHVyYXRpb24gPSAxMDAwOyAvLyBtaWxsaXNlY29uZHNcblx0dGhpcy5taXJyb3JlZExvb3AgPSBmYWxzZTtcblx0dGhpcy50aW1lID0gMDtcblxuXHQvLyBpbnRlcm5hbHNcblxuXHR0aGlzLmxhc3RLZXlmcmFtZSA9IDA7XG5cdHRoaXMuY3VycmVudEtleWZyYW1lID0gMDtcblxuXHR0aGlzLmRpcmVjdGlvbiA9IDE7XG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cblx0dGhpcy5zZXRGcmFtZVJhbmdlKCAwLCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggLSAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RnJhbWVSYW5nZSA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHR0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcblx0dGhpcy5lbmRLZXlmcmFtZSA9IGVuZDtcblxuXHR0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcblx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5kaXJlY3Rpb24gPSAtIDE7XG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0aWYgKCAhIGdlb21ldHJ5LmFuaW1hdGlvbnMgKSBnZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cblx0dmFyIGZpcnN0QW5pbWF0aW9uLCBhbmltYXRpb25zID0gZ2VvbWV0cnkuYW5pbWF0aW9ucztcblxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0dmFyIHBhcnRzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG5cdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHR2YXIgbGFiZWwgPSBwYXJ0c1sgMSBdO1xuXHRcdFx0dmFyIG51bSA9IHBhcnRzWyAyIF07XG5cblx0XHRcdGlmICggISBhbmltYXRpb25zWyBsYWJlbCBdICkgYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbIGxhYmVsIF07XG5cblx0XHRcdGlmICggaSA8IGFuaW1hdGlvbi5zdGFydCApIGFuaW1hdGlvbi5zdGFydCA9IGk7XG5cdFx0XHRpZiAoIGkgPiBhbmltYXRpb24uZW5kICkgYW5pbWF0aW9uLmVuZCA9IGk7XG5cblx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbGFiZWw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlb21ldHJ5LmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkxhYmVsID0gZnVuY3Rpb24gKCBsYWJlbCwgc3RhcnQsIGVuZCApIHtcblxuXHRpZiAoICEgdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zICkgdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cblx0dGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIGxhYmVsLCBmcHMgKSB7XG5cblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdHRoaXMuc2V0RnJhbWVSYW5nZSggYW5pbWF0aW9uLnN0YXJ0LCBhbmltYXRpb24uZW5kICk7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IDEwMDAgKiAoICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gZnBzICk7XG5cdFx0dGhpcy50aW1lID0gMDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnYW5pbWF0aW9uWycgKyBsYWJlbCArICddIHVuZGVmaW5lZCcgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cblx0dmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmxlbmd0aDtcblxuXHR0aGlzLnRpbWUgKz0gdGhpcy5kaXJlY3Rpb24gKiBkZWx0YTtcblxuXHRpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xuXG5cdFx0aWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMudGltZSA8IDAgKSB7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uICo9IC0gMTtcblxuXHRcdFx0aWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMudGltZSA8IDAgKSB7XG5cblx0XHRcdFx0dGhpcy50aW1lID0gMDtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLnRpbWUgPSB0aGlzLnRpbWUgJSB0aGlzLmR1cmF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XG5cblx0fVxuXG5cdHZhciBrZXlmcmFtZSA9IHRoaXMuc3RhcnRLZXlmcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIHRoaXMudGltZSAvIGZyYW1lVGltZSApLCAwLCB0aGlzLmxlbmd0aCAtIDEgKTtcblxuXHRpZiAoIGtleWZyYW1lICE9PSB0aGlzLmN1cnJlbnRLZXlmcmFtZSApIHtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMDtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cblx0XHR0aGlzLmxhc3RLZXlmcmFtZSA9IHRoaXMuY3VycmVudEtleWZyYW1lO1xuXHRcdHRoaXMuY3VycmVudEtleWZyYW1lID0ga2V5ZnJhbWU7XG5cblx0fVxuXG5cdHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG5cdGlmICggdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgKSB7XG5cblx0XHRtaXggPSAxIC0gbWl4O1xuXG5cdH1cblxuXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IG1peDtcblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAxIC0gbWl4O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAoIGEsIGIsIHQgKSB7XG5cblx0dmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRpbmZsdWVuY2VzWyBpIF0gPSAwO1xuXG5cdH1cblxuXHRpZiAoIGEgPiAtMSApIGluZmx1ZW5jZXNbIGEgXSA9IDEgLSB0O1xuXHRpZiAoIGIgPiAtMSApIGluZmx1ZW5jZXNbIGIgXSA9IHQ7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cblx0b2JqZWN0LmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcblx0b2JqZWN0Lm1pcnJvcmVkTG9vcCA9IHRoaXMubWlycm9yZWRMb29wO1xuXHRvYmplY3QudGltZSA9IHRoaXMudGltZTtcblxuXHRvYmplY3QubGFzdEtleWZyYW1lID0gdGhpcy5sYXN0S2V5ZnJhbWU7XG5cdG9iamVjdC5jdXJyZW50S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcblxuXHRvYmplY3QuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG5cdG9iamVjdC5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcztcblxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMub2JqZWN0cyA9IFtdO1xuXG59O1xuXG5cblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5hZGRMZXZlbCA9IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcblxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cblx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcblxuXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCB0aGlzLm9iamVjdHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHRoaXMub2JqZWN0c1sgbCBdLmRpc3RhbmNlICkge1xuXG5cdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5vYmplY3RzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIG9iamVjdDogb2JqZWN0IH0gKTtcblx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGlmICggZGlzdGFuY2UgPCB0aGlzLm9iamVjdHNbIGkgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0aGlzLm9iamVjdHNbIGkgLSAxIF0ub2JqZWN0O1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcblxuXHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xuXG5cdFx0XHR0aGlzLm9iamVjdHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMub2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPj0gdGhpcy5vYmplY3RzWyBpIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgICAgIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSgpO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5vYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9iamVjdHNbIGkgXS5vYmplY3QuY2xvbmUoKTtcblx0XHR4LnZpc2libGUgPSBpID09PSAwO1xuXHRcdG9iamVjdC5hZGRMZXZlbCggeCwgdGhpcy5vYmplY3RzWyBpIF0uZGlzdGFuY2UgKTtcblx0fVxuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU3ByaXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMiwgIDAsIDIsIDMgXSApO1xuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0gMC41LCAtIDAuNSwgMCwgICAwLjUsIC0gMC41LCAwLCAgIDAuNSwgMC41LCAwLCAgIC0gMC41LCAwLjUsIDAgXSApO1xuXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAgIDEsIDAsICAgMSwgMSwgICAwLCAxIF0gKTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnaW5kZXgnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XG5cblx0fTtcblxufSApKCk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA+IHRoaXMuc2NhbGUueCApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdHBvaW50OiB0aGlzLnBvc2l0aW9uLFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0fSApO1xuXG5cdH07XG5cbn0oKSApO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIHRoaXMubWF0ZXJpYWwgKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0cmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGVuc0ZsYXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmxlbnNGbGFyZXMgPSBbXTtcblxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuXHRpZiggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuXG4vKlxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XG5cdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcblx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcblx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cblx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcblx0XHR0ZXh0dXJlOiB0ZXh0dXJlLCBcdFx0XHQvLyBUSFJFRS5UZXh0dXJlXG5cdFx0c2l6ZTogc2l6ZSwgXHRcdFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsIFx0XHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG5cdFx0eDogMCwgeTogMCwgejogMCxcdFx0XHQvLyBzY3JlZW4gcG9zaXRpb24gKC0xID0+IDEpIHogPSAwIGlzIG9udG9wIHogPSAxIGlzIGJhY2tcblx0XHRzY2FsZTogMSwgXHRcdFx0XHRcdC8vIHNjYWxlXG5cdFx0cm90YXRpb246IDEsIFx0XHRcdFx0Ly8gcm90YXRpb25cblx0XHRvcGFjaXR5OiBvcGFjaXR5LFx0XHRcdC8vIG9wYWNpdHlcblx0XHRjb2xvcjogY29sb3IsXHRcdFx0XHQvLyBjb2xvclxuXHRcdGJsZW5kaW5nOiBibGVuZGluZ1x0XHRcdC8vIGJsZW5kaW5nXG5cdH0gKTtcblxufTtcblxuLypcbiAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcblx0dmFyIGZsYXJlO1xuXHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcblx0dmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XG5cblx0Zm9yKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0ZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcblxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG5cdFx0ZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcblxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xuXHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuXHR9XG5cbn07XG5cblxuLy8gRmlsZTpzcmMvc2NlbmVzL1NjZW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NjZW5lJztcblxuXHR0aGlzLmZvZyA9IG51bGw7XG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxufTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0aWYgKCB0aGlzLmZvZyAhPT0gbnVsbCApIG9iamVjdC5mb2cgPSB0aGlzLmZvZy5jbG9uZSgpO1xuXHRpZiAoIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIG9iamVjdC5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cblx0b2JqZWN0LmF1dG9VcGRhdGUgPSB0aGlzLmF1dG9VcGRhdGU7XG5cdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdGhpcy5tYXRyaXhBdXRvVXBkYXRlO1xuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiAoIGNvbG9yLCBuZWFyLCBmYXIgKSB7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblxuXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxufTtcblxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nRXhwMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZvZ0V4cDIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZW5zaXR5ICkge1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cdHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcblxufTtcblxuVEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanNcblxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGF0ZXN0X2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIEFMUEhBVEVTVFxcblxcblx0aWYgKCBnbF9GcmFnQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4J10gPSBcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcblxcbiNlbmRpZlxcblxcbnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5mb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxuXHR2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBkaXJWZWN0b3IgKTtcXG5cdHZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0dmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXHRcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblx0XHRcdHZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblx0XHR2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblx0XHRkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0ZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2ssIHdyYXBSR0IgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZW5kaWZcXG5cXG5cdHZMaWdodEZyb250ICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZztcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0dkxpZ2h0QmFjayArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrO1xcblxcblx0I2VuZGlmXFxuXFxufVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcXG5cXG5cdFx0ZmxvYXQgbERpc3RhbmNlID0gMS4wO1xcblx0XHRpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5cdFx0XHRsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5cXG5cdFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgbFZlY3RvciApO1xcblxcblx0XHR2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrID0gdmVjMyggbWF4KCAtZG90UHJvZHVjdCwgMC4wICkgKTtcXG5cXG5cdFx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cdFx0XHRcdHZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHRcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblx0XHRcdHZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxuXHRcdFx0cG9pbnRMaWdodFdlaWdodGluZyA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZywgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcXG5cXG5cdFx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0XHRwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZ0JhY2ssIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1xcblxcblx0XHRcdCNlbmRpZlxcblxcblx0XHQjZW5kaWZcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nICogbERpc3RhbmNlO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrICogbERpc3RhbmNlO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB3b3JsZFBvc2l0aW9uLnh5eiApICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IG1heCggcG93KCBtYXgoIHNwb3RFZmZlY3QsIDAuMCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1xcblxcblx0XHRcdGZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcXG5cdFx0XHRpZiAoIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVxcblx0XHRcdFx0bERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5cXG5cdFx0XHRsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcXG5cdFx0XHR2ZWMzIHNwb3RMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcXG5cXG5cdFx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0XHR2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1xcblxcblx0XHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0XHRcdHZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblxcblx0XHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0XHR2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxuXHRcdFx0XHRzcG90TGlnaHRXZWlnaHRpbmcgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZywgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1xcblxcblx0XHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0XHRzcG90TGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBzcG90TGlnaHRXZWlnaHRpbmdCYWNrLCBzcG90TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1xcblxcblx0XHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0dkxpZ2h0RnJvbnQgKz0gc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RMaWdodFdlaWdodGluZyAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0dkxpZ2h0QmFjayArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdExpZ2h0V2VpZ2h0aW5nQmFjayAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxuXHRcdHZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgPSAtMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG52TGlnaHRGcm9udCA9IHZMaWdodEZyb250ICogZGlmZnVzZSArIGFtYmllbnQgKiBhbWJpZW50TGlnaHRDb2xvciArIGVtaXNzaXZlO1xcblxcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdHZMaWdodEJhY2sgPSB2TGlnaHRCYWNrICogZGlmZnVzZSArIGFtYmllbnQgKiBhbWJpZW50TGlnaHRDb2xvciArIGVtaXNzaXZlO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRfdmVydGV4J10gPSBcInZlYzQgbXZQb3NpdGlvbjtcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVxcblxcblx0bXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiNlbmRpZlxcblxcbiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgISBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcXG5cXG5cdG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5ub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXG5cdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbW9ycGhlZE5vcm1hbCwgMC4wICk7XFxuXFxuXHQjZWxzZVxcblxcblx0dmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50J10gPSBcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxudmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblx0dmVjMyBwb2ludFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cXG5cdFx0ZmxvYXQgbERpc3RhbmNlID0gMS4wO1xcblx0XHRpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5cdFx0XHRsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5cXG5cdFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHRcdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XFxuXFxuXHRcdFx0dmVjMyBwb2ludERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XFxuXFxuXHRcdCNlbHNlXFxuXFxuXHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHRcdHBvaW50RGlmZnVzZSArPSBkaWZmdXNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2U7XFxuXFxuXHRcdFx0XHQvLyBzcGVjdWxhclxcblxcblx0XHR2ZWMzIHBvaW50SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRmbG9hdCBwb2ludERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludEhhbGZWZWN0b3IgKSwgMC4wICk7XFxuXHRcdGZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBwb2ludEhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1xcblx0XHRwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHZlYzMgc3BvdERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG5cdHZlYzMgc3BvdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXFxuXHRcdGZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcXG5cdFx0aWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5cdFx0XHRsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1xcblxcblx0XHRsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IG1heCggcG93KCBtYXgoIHNwb3RFZmZlY3QsIDAuMCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1xcblxcblx0XHRcdFx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XFxuXFxuXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblx0XHRcdFx0ZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cdFx0XHRcdHZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIHNwb3REaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBzcG90RGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblx0XHRcdCNlbHNlXFxuXFxuXHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0c3BvdERpZmZ1c2UgKz0gZGlmZnVzZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0XHRcdC8vIHNwZWN1bGFyXFxuXFxuXHRcdFx0dmVjMyBzcG90SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRcdGZsb2F0IHNwb3REb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICk7XFxuXHRcdFx0ZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXHRcdFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3Rvciwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1xcblx0XHRcdHNwb3RTcGVjdWxhciArPSBzY2hsaWNrICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogc3BvdEVmZmVjdDtcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdHZlYzMgZGlyRGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblx0dmVjMyBkaXJTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxuXHRcdHZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1xcblxcblx0XHRcdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGRpclZlY3RvciApO1xcblxcblx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cdFx0XHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXHRcdFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApO1xcblxcblx0XHRcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblx0XHQjZWxzZVxcblxcblx0XHRcdGZsb2F0IGRpckRpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdFx0ZGlyRGlmZnVzZSArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1xcblxcblx0XHQvLyBzcGVjdWxhclxcblxcblx0XHR2ZWMzIGRpckhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGRpclZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcXG5cdFx0ZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcXG5cXG5cdFx0LypcXG5cdFx0Ly8gZnJlc25lbCB0ZXJtIGZyb20gc2tpbiBzaGFkZXJcXG5cdFx0Y29uc3QgZmxvYXQgRjAgPSAwLjEyODtcXG5cXG5cdFx0ZmxvYXQgYmFzZSA9IDEuMCAtIGRvdCggdmlld1Bvc2l0aW9uLCBkaXJIYWxmVmVjdG9yICk7XFxuXHRcdGZsb2F0IGV4cG9uZW50aWFsID0gcG93KCBiYXNlLCA1LjAgKTtcXG5cXG5cdFx0ZmxvYXQgZnJlc25lbCA9IGV4cG9uZW50aWFsICsgRjAgKiAoIDEuMCAtIGV4cG9uZW50aWFsICk7XFxuXHRcdCovXFxuXFxuXHRcdC8qXFxuXHRcdC8vIGZyZXNuZWwgdGVybSBmcm9tIGZyZXNuZWwgc2hhZGVyXFxuXHRcdGNvbnN0IGZsb2F0IG1GcmVzbmVsQmlhcyA9IDAuMDg7XFxuXHRcdGNvbnN0IGZsb2F0IG1GcmVzbmVsU2NhbGUgPSAwLjM7XFxuXHRcdGNvbnN0IGZsb2F0IG1GcmVzbmVsUG93ZXIgPSA1LjA7XFxuXFxuXHRcdGZsb2F0IGZyZXNuZWwgPSBtRnJlc25lbEJpYXMgKyBtRnJlc25lbFNjYWxlICogcG93KCAxLjAgKyBkb3QoIG5vcm1hbGl6ZSggLXZpZXdQb3NpdGlvbiApLCBub3JtYWwgKSwgbUZyZXNuZWxQb3dlciApO1xcblx0XHQqL1xcblxcblx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblx0XHQvLyBcdFx0ZGlyU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIGZyZXNuZWw7XFxuXFxuXHRcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XFxuXHRcdGRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcXG5cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0dmVjMyBoZW1pRGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblx0dmVjMyBoZW1pU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdGhlbWlEaWZmdXNlICs9IGRpZmZ1c2UgKiBoZW1pQ29sb3I7XFxuXFxuXHRcdC8vIHNwZWN1bGFyIChza3kgbGlnaHQpXFxuXFxuXHRcdHZlYzMgaGVtaUhhbGZWZWN0b3JTa3kgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5cdFx0ZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZTa3kgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JTa3kgKSArIDAuNTtcXG5cdFx0ZmxvYXQgaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBtYXgoIGhlbWlEb3ROb3JtYWxIYWxmU2t5LCAwLjAgKSwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblx0XHQvLyBzcGVjdWxhciAoZ3JvdW5kIGxpZ2h0KVxcblxcblx0XHR2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcXG5cXG5cdFx0dmVjMyBoZW1pSGFsZlZlY3Rvckdyb3VuZCA9IG5vcm1hbGl6ZSggbFZlY3Rvckdyb3VuZCArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRmbG9hdCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApICsgMC41O1xcblx0XHRmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIG1heCggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIDAuMCApLCBzaGluaW5lc3MgKSwgMC4wICk7XFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3RHcm91bmQgPSBkb3QoIG5vcm1hbCwgbFZlY3Rvckdyb3VuZCApO1xcblxcblx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblx0XHR2ZWMzIHNjaGxpY2tTa3kgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCAwLjAgKSwgNS4wICk7XFxuXHRcdHZlYzMgc2NobGlja0dyb3VuZCA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3JHcm91bmQsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICksIDAuMCApLCA1LjAgKTtcXG5cdFx0aGVtaVNwZWN1bGFyICs9IGhlbWlDb2xvciAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqICggc2NobGlja1NreSAqIGhlbWlTcGVjdWxhcldlaWdodFNreSAqIG1heCggZG90UHJvZHVjdCwgMC4wICkgKyBzY2hsaWNrR3JvdW5kICogaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICogbWF4KCBkb3RQcm9kdWN0R3JvdW5kLCAwLjAgKSApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbnZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XFxuXHR0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR0b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XFxuXHR0b3RhbFNwZWN1bGFyICs9IGhlbWlTcGVjdWxhcjtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHRvdGFsRGlmZnVzZSArPSBwb2ludERpZmZ1c2U7XFxuXHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcXG5cdHRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBNRVRBTFxcblxcblx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICsgdG90YWxTcGVjdWxhciApO1xcblxcbiNlbHNlXFxuXFxuXHRnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggZW1pc3NpdmUgKyB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIGFtYmllbnQgKSArIHRvdGFsU3BlY3VsYXI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHZlYzMgbW9ycGhlZE5vcm1hbCA9IHZlYzMoIDAuMCApO1xcblxcblx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRtb3JwaGVkTm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHRtb3JwaGVkTm9ybWFsICs9IG5vcm1hbDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblx0dW5pZm9ybSBpbnQgY29tYmluZTtcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXHRcdFx0Ly8gUGVyLVBpeGVsIFRhbmdlbnQgU3BhY2UgTm9ybWFsIE1hcHBpbmdcXG5cdFx0XHQvLyBodHRwOi8vaGFja3NvZmxpZmUuYmxvZ3Nwb3QuY2gvMjAwOS8xMS9wZXItcGl4ZWwtdGFuZ2VudC1zcGFjZS1ub3JtYWwtbWFwcGluZy5odG1sXFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHR2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3ZlcnRleCddID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG5cXG5cdCNpZmRlZiBHQU1NQV9JTlBVVFxcblxcblx0XHR0ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcXG5cXG5cdCNlbmRpZlxcblxcblx0Z2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dlV2MiA9IHV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0I2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuXHRcdHZDb2xvciA9IGNvbG9yICogY29sb3I7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2Q29sb3IgPSBjb2xvcjtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHQjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcblx0I2Vsc2VcXG5cXG5cdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cdHVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpbmVhcl90b19nYW1tYV9mcmFnbWVudCddID0gXCIjaWZkZWYgR0FNTUFfT1VUUFVUXFxuXFxuXHRnbF9GcmFnQ29sb3IueHl6ID0gc3FydCggZ2xfRnJhZ0NvbG9yLnh5eiApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50O1xcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG5cXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cdHVuaWZvcm0gdmVjMyB3cmFwUkdCO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cdHZlYzMgcmVmbGVjdFZlYztcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cdFx0Ly8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9HTFNMX1Byb2dyYW1taW5nL0FwcGx5aW5nX01hdHJpeF9UcmFuc2Zvcm1hdGlvbnNcXG5cdFx0Ly8gVHJhbnNmb3JtaW5nIE5vcm1hbCBWZWN0b3JzIHdpdGggdGhlIEludmVyc2UgVHJhbnNmb3JtYXRpb25cXG5cXG5cdFx0dmVjMyB3b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSggdmVjMyggdmVjNCggbm9ybWFsLCAwLjAgKSAqIHZpZXdNYXRyaXggKSApO1xcblxcblx0XHRpZiAoIHVzZVJlZnJhY3QgKSB7XFxuXFxuXHRcdFx0cmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXHRcdH0gZWxzZSB7IFxcblxcblx0XHRcdHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG5cdFx0fVxcblxcblx0I2Vsc2VcXG5cXG5cdFx0cmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblx0XHR2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBHQU1NQV9JTlBVVFxcblxcblx0XHRjdWJlQ29sb3IueHl6ICo9IGN1YmVDb2xvci54eXo7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdGlmICggY29tYmluZSA9PSAxICkge1xcblxcblx0XHRnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuXHR9IGVsc2UgaWYgKCBjb21iaW5lID09IDIgKSB7XFxuXFxuXHRcdGdsX0ZyYWdDb2xvci54eXogKz0gY3ViZUNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFxuXHR9IGVsc2Uge1xcblxcblx0XHRnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBnbF9GcmFnQ29sb3IueHl6ICogY3ViZUNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblx0fVxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoMWUtNiwgZ2xfUG9zaXRpb24udyArIDEuMCkpICogbG9nRGVwdGhCdWZGQztcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcbiNlbHNlXFxuXFxuXHRcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcblx0I2Vsc2VcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50J10gPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcblxcbiNlbHNlXFxuXFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdGNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTtcXG5cdFx0ZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7XFxuXHRcdGZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXFxuXHQjZW5kaWZcXG5cdFxcblx0Z2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYnVtcG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdidW1wbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuXHRcdFx0Ly8gRGVyaXZhdGl2ZSBtYXBzIC0gYnVtcCBtYXBwaW5nIHVucGFyYW1ldHJpemVkIHN1cmZhY2VzIGJ5IE1vcnRlbiBNaWtrZWxzZW5cXG5cdFx0XHQvL1x0aHR0cDovL21taWtrZWxzZW4zZC5ibG9nc3BvdC5zay8yMDExLzA3L2Rlcml2YXRpdmUtbWFwcy5odG1sXFxuXFxuXHRcdFx0Ly8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXFxuXFxuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXG5cdFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cdFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXHRcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG5cdH1cXG5cXG5cdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFxuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XHRcdC8vIG5vcm1hbGl6ZWRcXG5cXG5cdFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblx0XHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuXHRcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxuXFxuXHRcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblx0XHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCddID0gXCJ2ZWMzIG9iamVjdE5vcm1hbDtcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRvYmplY3ROb3JtYWwgPSBza2lubmVkTm9ybWFsLnh5ejtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSE5PUk1BTFMgKVxcblxcblx0b2JqZWN0Tm9ybWFsID0gbW9ycGhlZE5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmICEgZGVmaW5lZCggVVNFX01PUlBITk9STUFMUyApXFxuXFxuXHRvYmplY3ROb3JtYWwgPSBub3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIEZMSVBfU0lERURcXG5cXG5cdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHR1bmlmb3JtIHZlYzMgd3JhcFJHQjtcXG5cXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHZlYzQoIHZDb2xvciwgMS4wICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXHR2ZWMzIG1vcnBoZWQgPSB2ZWMzKCAwLjAgKTtcXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXHRtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuXHQjZW5kaWZcXG5cXG5cdG1vcnBoZWQgKz0gcG9zaXRpb247XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2ZWMzIHdvcmxkTm9ybWFsID0gbWF0MyggbW9kZWxNYXRyaXhbIDAgXS54eXosIG1vZGVsTWF0cml4WyAxIF0ueHl6LCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICogb2JqZWN0Tm9ybWFsO1xcblx0d29ybGROb3JtYWwgPSBub3JtYWxpemUoIHdvcmxkTm9ybWFsICk7XFxuXFxuXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXHRpZiAoIHVzZVJlZnJhY3QgKSB7XFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdH0gZWxzZSB7XFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdHZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1swXSA9IHZlYzMoIDEuMCwgMC41LCAwLjAgKTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1sxXSA9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1syXSA9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuXHRcdGludCBpbkZydXN0dW1Db3VudCA9IDA7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdGZsb2F0IGZEZXB0aDtcXG5cdHZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgc2hhZG93Q29vcmQgPSB2U2hhZG93Q29vcmRbIGkgXS54eXogLyB2U2hhZG93Q29vcmRbIGkgXS53O1xcblxcblx0XHRcdFx0Ly8gaWYgKCBzb21ldGhpbmcgJiYgc29tZXRoaW5nICkgYnJlYWtzIEFUSSBPcGVuR0wgc2hhZGVyIGNvbXBpbGVyXFxuXHRcdFx0XHQvLyBpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApIHVzaW5nIHRoaXMgaW5zdGVhZFxcblxcblx0XHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG5cdFx0XHRcdC8vIGRvbid0IHNoYWRvdyBwaXhlbHMgb3V0c2lkZSBvZiBsaWdodCBmcnVzdHVtXFxuXHRcdFx0XHQvLyB1c2UganVzdCBmaXJzdCBmcnVzdHVtIChmb3IgY2FzY2FkZXMpXFxuXHRcdFx0XHQvLyBkb24ndCBzaGFkb3cgcGl4ZWxzIGJlaGluZCBmYXIgcGxhbmUgb2YgbGlnaHQgZnJ1c3R1bVxcblxcblx0XHQjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcXG5cXG5cdFx0XHRpbkZydXN0dW1Db3VudCArPSBpbnQoIGluRnJ1c3R1bSApO1xcblx0XHRcdGJ2ZWMzIGZydXN0dW1UZXN0VmVjID0gYnZlYzMoIGluRnJ1c3R1bSwgaW5GcnVzdHVtQ291bnQgPT0gMSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXG5cdFx0I2Vsc2VcXG5cXG5cdFx0XHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0XHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcblx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcblx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcblx0XHRcdFx0XHRcdC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXFxuXHRcdFx0XHRcdFx0Ly8gKDkgcGl4ZWwga2VybmVsKVxcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cXG5cXG5cdFx0XHRcdGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG5cdFx0LypcXG5cdFx0XHRcdFx0XHQvLyBuZXN0ZWQgbG9vcHMgYnJlYWtzIHNoYWRlciBjb21waWxlciAvIHZhbGlkYXRvciBvbiBzb21lIEFUSSBjYXJkcyB3aGVuIHVzaW5nIE9wZW5HTFxcblx0XHRcdFx0XHRcdC8vIG11c3QgZW5yb2xsIGxvb3AgbWFudWFsbHlcXG5cXG5cdFx0XHRcdGZvciAoIGZsb2F0IHkgPSAtMS4yNTsgeSA8PSAxLjI1OyB5ICs9IDEuMjUgKVxcblx0XHRcdFx0XHRmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblxcblx0XHRcdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcXG5cXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIHRleHR1cmUyRCBsb29rdXBcXG5cdFx0XHRcdFx0XHRcdFx0Ly92ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRFByb2ooIHNoYWRvd01hcFsgaSBdLCB2ZWM0KCB2U2hhZG93Q29vcmRbIGkgXS53ICogKCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApLCAwLjA1LCB2U2hhZG93Q29vcmRbIGkgXS53ICkgKTtcXG5cXG5cdFx0XHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cdFx0XHRcdFx0XHRcdHNoYWRvdyArPSAxLjA7XFxuXFxuXHRcdFx0XHR9XFxuXFxuXHRcdFx0XHRzaGFkb3cgLz0gOS4wO1xcblxcblx0XHQqL1xcblxcblx0XHRcdFx0Y29uc3QgZmxvYXQgc2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcblx0XHRcdFx0ZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG5cdFx0XHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXFxuXHRcdFx0XHRcdFx0Ly8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcblx0XHRcdFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuXHRcdFx0XHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0xLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtMS4wICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0bWF0MyBzaGFkb3dLZXJuZWw7XFxuXHRcdFx0XHRtYXQzIGRlcHRoS2VybmVsO1xcblxcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMF1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzBdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFswXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMV1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsyXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMl1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuXHRcdFx0XHR2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMF0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzBdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzBdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzFdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzFdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzJdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHR2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbaV0ueHkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gPSBtaXgoIHNoYWRvd0tlcm5lbFsyXSwgc2hhZG93S2VybmVsWzFdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblxcblx0XHRcdFx0dmVjNCBzaGFkb3dWYWx1ZXM7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueSA9IG1peCggc2hhZG93S2VybmVsWzBdWzJdLCBzaGFkb3dLZXJuZWxbMF1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWzFdWzFdLCBzaGFkb3dLZXJuZWxbMV1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1xcblxcblx0XHRcdCNlbHNlXFxuXFxuXHRcdFx0XHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblxcblx0XHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBpcyBkYXJrZXJcXG5cXG5cdFx0XHRcdFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cdFx0Ly8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaGFzIHRoZSBzYW1lIGNvbG9yIGFzIHNpbmdsZSBzaGFkb3cgc3BvdFxcblxcblx0XHQvLyBcdFx0XHRcdFx0c2hhZG93Q29sb3IgPSBtaW4oIHNoYWRvd0NvbG9yLCB2ZWMzKCBzaGFkb3dEYXJrbmVzc1sgaSBdICkgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0fVxcblxcblxcblx0XHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdFx0I2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuXHRcdFx0XHRpZiAoIGluRnJ1c3R1bSAmJiBpbkZydXN0dW1Db3VudCA9PSAxICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuXHRcdFx0I2Vsc2VcXG5cXG5cdFx0XHRcdGlmICggaW5GcnVzdHVtICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcblx0I2lmZGVmIEdBTU1BX09VVFBVVFxcblxcblx0XHRzaGFkb3dDb2xvciAqPSBzaGFkb3dDb2xvcjtcXG5cXG5cdCNlbmRpZlxcblxcblx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBzaGFkb3dDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFxuXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZiAhIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0ZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1xcblx0XHRyZXR1cm4gZGVwdGg7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ19wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXG5cdCNpZmRlZiBCT05FX1RFWFRVUkVcXG5cXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXHRcdFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblx0XHRcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXG5cdFx0XHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXHRcdFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXG5cdFx0XHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG5cdFx0XHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2Vsc2VcXG5cXG5cdFx0dW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cdFx0XHRtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcblx0XHRcdHJldHVybiBib25lO1xcblxcblx0XHR9XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHQjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcblx0Z2xfRnJhZ0NvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qc1xuXG4vKipcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcblxuXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcblxuXHRcdHZhciBtZXJnZWQgPSB7fTtcblxuXHRcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuXHRcdFx0Zm9yICggdmFyIHAgaW4gdG1wICkge1xuXG5cdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtZXJnZWQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cblx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cblx0XHRcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5pZm9ybXNfZHN0O1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNMaWIuanNcblxuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cblRIUkVFLlVuaWZvcm1zTGliID0ge1xuXG5cdGNvbW1vbjoge1xuXG5cdFx0XCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cblx0XHRcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwic3BlY3VsYXJNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJhbHBoYU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuXHRcdFwiZW52TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwiZmxpcEVudk1hcFwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9LFxuXHRcdFwidXNlUmVmcmFjdFwiIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwicmVmcmFjdGlvblJhdGlvXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9LFxuXHRcdFwiY29tYmluZVwiIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblxuXHRcdFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9XG5cblx0fSxcblxuXHRidW1wOiB7XG5cblx0XHRcImJ1bXBNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJidW1wU2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cblxuXHR9LFxuXG5cdG5vcm1hbG1hcDoge1xuXG5cdFx0XCJub3JtYWxNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJub3JtYWxTY2FsZVwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH1cblx0fSxcblxuXHRmb2cgOiB7XG5cblx0XHRcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXG5cdFx0XCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXHRcdFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxuXHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxuXG5cdH0sXG5cblx0bGlnaHRzOiB7XG5cblx0XHRcImFtYmllbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cblx0XHRcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcImRpcmVjdGlvbmFsTGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcImhlbWlzcGhlcmVMaWdodFNreUNvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJwb2ludExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcInBvaW50TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwicG9pbnRMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJzcG90TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic3BvdExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcInNwb3RMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic3BvdExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJzcG90TGlnaHRBbmdsZUNvc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcblx0XHRcInNwb3RMaWdodEV4cG9uZW50XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9XG5cblx0fSxcblxuXHRwYXJ0aWNsZToge1xuXG5cdFx0XCJwc0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcblx0XHRcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdHNoYWRvd21hcDoge1xuXG5cdFx0XCJzaGFkb3dNYXBcIjogeyB0eXBlOiBcInR2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic2hhZG93TWFwU2l6ZVwiOiB7IHR5cGU6IFwidjJ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJzaGFkb3dCaWFzXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic2hhZG93RGFya25lc3NcIjogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcblxuXHRcdFwic2hhZG93TWF0cml4XCIgOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIuanNcblxuLyoqXG4gKiBXZWJnbCBTaGFkZXIgTGlicmFyeSBmb3IgdGhyZWUuanNcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuXG5USFJFRS5TaGFkZXJMaWIgPSB7XG5cblx0J2Jhc2ljJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXG5cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfRU5WTUFQXCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIilcblxuXHR9LFxuXG5cdCdsYW1iZXJ0Jzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0e1xuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgTEFNQkVSVFwiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBET1VCTEVfU0lERURcIixcblxuXHRcdFx0XHRcdC8vXCJmbG9hdCBpc0Zyb250ID0gZmxvYXQoIGdsX0Zyb250RmFjaW5nICk7XCIsXG5cdFx0XHRcdFx0Ly9cImdsX0ZyYWdDb2xvci54eXogKj0gaXNGcm9udCAqIHZMaWdodEZyb250ICsgKCAxLjAgLSBpc0Zyb250ICkgKiB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcIlx0XHRpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRGcm9udDtcIixcblx0XHRcdFwiXHRcdGVsc2VcIixcblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRGcm9udDtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J3Bob25nJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibm9ybWFsbWFwXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0e1xuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0XCJzcGVjdWxhclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuXHRcdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgUEhPTkdcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHR2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgUEhPTkdcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBhbWJpZW50O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J3BhcnRpY2xlX2Jhc2ljJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwicGFydGljbGVcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxuXG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaXplO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcblx0XHRcdFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXG5cdFx0XHRcIlx0I2Vsc2VcIixcblx0XHRcdFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcHNDb2xvcjtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J2Rhc2hlZCc6IHtcblxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXG5cdFx0XHR7XG5cdFx0XHRcdFwic2NhbGVcIiAgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcdFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG5cdFx0XHRcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXG5cblx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXG5cblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XHRcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwiXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcblxuXHRcdFx0XCJcdFx0ZGlzY2FyZDtcIixcblxuXHRcdFx0XCJcdH1cIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J2RlcHRoJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XCJtTmVhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XHRcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cblx0XHRcdFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cblx0XHRcdFwiXHQjZWxzZVwiLFxuXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdGZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XCIsXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0fSxcblxuXHQnbm9ybWFsJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIilcblxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdE5vcm1hbCBtYXAgc2hhZGVyXG5cdC8vXHRcdC0gQmxpbm4tUGhvbmdcblx0Ly9cdFx0LSBub3JtYWwgKyBkaWZmdXNlICsgc3BlY3VsYXIgKyBBTyArIGRpc3BsYWNlbWVudCArIHJlZmxlY3Rpb24gKyBzaGFkb3cgbWFwc1xuXHQvL1x0XHQtIHBvaW50IGFuZCBkaXJlY3Rpb25hbCBsaWdodHMgKHVzZSB3aXRoIFwibGlnaHRzOiB0cnVlXCIgbWF0ZXJpYWwgb3B0aW9uKVxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdCdub3JtYWxtYXAnIDoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG5cdFx0XHR7XG5cblx0XHRcdFwiZW5hYmxlQU9cIiAgICAgICAgICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XHRcImVuYWJsZURpZmZ1c2VcIiAgICAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFx0XCJlbmFibGVTcGVjdWxhclwiICAgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcdFwiZW5hYmxlUmVmbGVjdGlvblwiICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XHRcImVuYWJsZURpc3BsYWNlbWVudFwiOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXG5cdFx0XHRcInREaXNwbGFjZW1lbnRcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSwgLy8gbXVzdCBnbyBmaXJzdCBhcyB0aGlzIGlzIHZlcnRleCB0ZXh0dXJlXG5cdFx0XHRcInREaWZmdXNlXCIgICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwidEN1YmVcIiAgICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJ0Tm9ybWFsXCIgICAgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcInRTcGVjdWxhclwiICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwidEFPXCIgICAgICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0XHRcInVOb3JtYWxTY2FsZVwiOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfSxcblxuXHRcdFx0XCJ1RGlzcGxhY2VtZW50Qmlhc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wIH0sXG5cdFx0XHRcInVEaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcdFwiZGlmZnVzZVwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcInNwZWN1bGFyXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcblx0XHRcdFwiYW1iaWVudFwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcblx0XHRcdFwib3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG5cdFx0XHRcInVzZVJlZnJhY3RcIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcdFwicmVmcmFjdGlvblJhdGlvXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH0sXG5cdFx0XHRcInJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cblx0XHRcdFwidU9mZnNldFwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApIH0sXG5cdFx0XHRcInVSZXBlYXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LFxuXG5cdFx0XHRcIndyYXBSR0JcIiA6IHsgdHlwZTogXCJ2M1wiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSB9XG5cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpZmZ1c2U7XCIsXG5cdFx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVTcGVjdWxhcjtcIixcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZUFPO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlUmVmbGVjdGlvbjtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdE5vcm1hbDtcIixcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdFNwZWN1bGFyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0QU87XCIsXG5cblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU5vcm1hbFNjYWxlO1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZUYW5nZW50O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXG5cblx0XHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFwiXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgd3JhcFJHQjtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFwiXHR2ZWMzIHNwZWN1bGFyVGV4ID0gdmVjMyggMS4wICk7XCIsXG5cblx0XHRcdFwiXHR2ZWMzIG5vcm1hbFRleCA9IHRleHR1cmUyRCggdE5vcm1hbCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxuXHRcdFx0XCJcdG5vcm1hbFRleC54eSAqPSB1Tm9ybWFsU2NhbGU7XCIsXG5cdFx0XHRcIlx0bm9ybWFsVGV4ID0gbm9ybWFsaXplKCBub3JtYWxUZXggKTtcIixcblxuXHRcdFx0XCJcdGlmKCBlbmFibGVEaWZmdXNlICkge1wiLFxuXG5cdFx0XHRcIlx0XHQjaWZkZWYgR0FNTUFfSU5QVVRcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblx0XHRcdFwiXHRcdFx0dGV4ZWxDb2xvci54eXogKj0gdGV4ZWxDb2xvci54eXo7XCIsXG5cblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4ZWxDb2xvcjtcIixcblxuXHRcdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblxuXHRcdFx0XCJcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHR9XCIsXG5cblx0XHRcdFwiXHRpZiggZW5hYmxlQU8gKSB7XCIsXG5cblx0XHRcdFwiXHRcdCNpZmRlZiBHQU1NQV9JTlBVVFwiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzQgYW9Db2xvciA9IHRleHR1cmUyRCggdEFPLCB2VXYgKTtcIixcblx0XHRcdFwiXHRcdFx0YW9Db2xvci54eXogKj0gYW9Db2xvci54eXo7XCIsXG5cblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBhb0NvbG9yLnh5ejtcIixcblxuXHRcdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIHRleHR1cmUyRCggdEFPLCB2VXYgKS54eXo7XCIsXG5cblx0XHRcdFwiXHRcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0fVwiLFxuXHRcdFx0XG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIlx0aWYoIGVuYWJsZVNwZWN1bGFyIClcIixcblx0XHRcdFwiXHRcdHNwZWN1bGFyVGV4ID0gdGV4dHVyZTJEKCB0U3BlY3VsYXIsIHZVdiApLnh5ejtcIixcblxuXHRcdFx0XCJcdG1hdDMgdHNiID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaW5vcm1hbCApLCBub3JtYWxpemUoIHZOb3JtYWwgKSApO1wiLFxuXHRcdFx0XCJcdHZlYzMgZmluYWxOb3JtYWwgPSB0c2IgKiBub3JtYWxUZXg7XCIsXG5cblx0XHRcdFwiXHQjaWZkZWYgRkxJUF9TSURFRFwiLFxuXG5cdFx0XHRcIlx0XHRmaW5hbE5vcm1hbCA9IC1maW5hbE5vcm1hbDtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGZpbmFsTm9ybWFsICk7XCIsXG5cdFx0XHRcIlx0dmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcblxuXHRcdFx0XHQvLyBwb2ludCBsaWdodHNcblxuXHRcdFx0XCJcdCNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0XHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0dmVjMyBwb2ludFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHR2ZWMzIHBvaW50VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcIlx0XHRcdGZsb2F0IHBvaW50RGlzdGFuY2UgPSAxLjA7XCIsXG5cdFx0XHRcIlx0XHRcdGlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxuXHRcdFx0XCJcdFx0XHRcdHBvaW50RGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBwb2ludFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0cG9pbnRWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICk7XCIsXG5cblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcblxuXHRcdFx0XCJcdFx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcIixcblxuXHRcdFx0XCJcdFx0XHRcdGZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSArIDAuNSwgMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHR2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcblxuXHRcdFx0XCJcdFx0XHQjZWxzZVwiLFxuXG5cdFx0XHRcIlx0XHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSwgMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRcdFx0cG9pbnREaWZmdXNlICs9IHBvaW50RGlzdGFuY2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIGRpZmZ1c2UgKiBwb2ludERpZmZ1c2VXZWlnaHQ7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyXG5cblx0XHRcdFwiXHRcdFx0dmVjMyBwb2ludEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0ZmxvYXQgcG9pbnRTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggcG9pbnREb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0ZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAgKSAvIDguMDtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBwb2ludFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcdFwiXHRcdFx0cG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogcG9pbnREaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcblxuXHRcdFx0XCJcdFx0fVwiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0Ly8gc3BvdCBsaWdodHNcblxuXHRcdFx0XCJcdCNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHZlYzMgc3BvdERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdHZlYzMgc3BvdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0dmVjMyBzcG90VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcIlx0XHRcdGZsb2F0IHNwb3REaXN0YW5jZSA9IDEuMDtcIixcblx0XHRcdFwiXHRcdFx0aWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcblx0XHRcdFwiXHRcdFx0XHRzcG90RGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBzcG90VmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHNwb3RWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gdldvcmxkUG9zaXRpb24gKSApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHRzcG90RWZmZWN0ID0gbWF4KCBwb3coIG1heCggc3BvdEVmZmVjdCwgMC4wICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gZGlmZnVzZVxuXG5cdFx0XHRcIlx0XHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90KCBub3JtYWwsIHNwb3RWZWN0b3IgKSwgMC4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBzcG90VmVjdG9yICkgKyAwLjUsIDAuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdFx0XHR2ZWMzIHNwb3REaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0XHRcdFx0c3BvdERpZmZ1c2UgKz0gc3BvdERpc3RhbmNlICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIGRpZmZ1c2UgKiBzcG90RGlmZnVzZVdlaWdodCAqIHNwb3RFZmZlY3Q7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcblxuXHRcdFx0XCJcdFx0XHRcdHZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBzcG90RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHNwb3RIYWxmVmVjdG9yICksIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHRcdGZsb2F0IHNwb3RTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggc3BvdERvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBzcG90VmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdFx0c3BvdFNwZWN1bGFyICs9IHNjaGxpY2sgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiBzcG90RWZmZWN0O1wiLFxuXG5cdFx0XHRcIlx0XHRcdH1cIixcblxuXHRcdFx0XCJcdFx0fVwiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0Ly8gZGlyZWN0aW9uYWwgbGlnaHRzXG5cblx0XHRcdFwiXHQjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHZlYzMgZGlyRGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0dmVjMyBkaXJTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpKysgKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdHZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBkaWZmdXNlXG5cblx0XHRcdFwiXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nRnVsbCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIGRpclZlY3RvciApICsgMC41LCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0Z1bGwgKSwgdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgKSwgd3JhcFJHQiApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICksIDAuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0XHRcdGRpckRpZmZ1c2UgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaWZmdXNlICogZGlyRGlmZnVzZVdlaWdodDtcIixcblxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGRpckhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGRpclZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxuXHRcdFx0XCJcdFx0XHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0ZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdGRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcblxuXHRcdFx0XCJcdFx0fVwiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0Ly8gaGVtaXNwaGVyZSBsaWdodHNcblxuXHRcdFx0XCJcdCNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHZlYzMgaGVtaURpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdHZlYzMgaGVtaVNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIgLFxuXG5cdFx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHR2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXG5cblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcIixcblx0XHRcdFwiXHRcdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzMgaGVtaUNvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdGhlbWlEaWZmdXNlICs9IGRpZmZ1c2UgKiBoZW1pQ29sb3I7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyIChza3kgbGlnaHQpXG5cblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGhlbWlIYWxmVmVjdG9yU2t5ID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmU2t5ID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yU2t5ICkgKyAwLjU7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlTcGVjdWxhcldlaWdodFNreSA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggbWF4KCBoZW1pRG90Tm9ybWFsSGFsZlNreSwgMC4wICksIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXIgKGdyb3VuZCBsaWdodClcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGhlbWlIYWxmVmVjdG9yR3JvdW5kID0gbm9ybWFsaXplKCBsVmVjdG9yR3JvdW5kICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmR3JvdW5kID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICkgKyAwLjU7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggbWF4KCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCwgMC4wICksIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBkb3RQcm9kdWN0R3JvdW5kID0gZG90KCBub3JtYWwsIGxWZWN0b3JHcm91bmQgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzMgc2NobGlja1NreSA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3IsIGhlbWlIYWxmVmVjdG9yU2t5ICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcdFwiXHRcdFx0dmVjMyBzY2hsaWNrR3JvdW5kID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgMC4wICksIDUuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHRoZW1pU3BlY3VsYXIgKz0gaGVtaUNvbG9yICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogKCBzY2hsaWNrU2t5ICogaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ICogbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSArIHNjaGxpY2tHcm91bmQgKiBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKiBtYXgoIGRvdFByb2R1Y3RHcm91bmQsIDAuMCApICk7XCIsXG5cblx0XHRcdFwiXHRcdH1cIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdC8vIGFsbCBsaWdodHMgY29udHJpYnV0aW9uIHN1bW1hdGlvblxuXG5cdFx0XHRcIlx0dmVjMyB0b3RhbERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHR2ZWMzIHRvdGFsU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdCNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XCJcdFx0dG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XCIsXG5cdFx0XHRcIlx0XHR0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1wiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHQjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0XHR0b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XCIsXG5cdFx0XHRcIlx0XHR0b3RhbFNwZWN1bGFyICs9IGhlbWlTcGVjdWxhcjtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0I2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHRvdGFsRGlmZnVzZSArPSBwb2ludERpZmZ1c2U7XCIsXG5cdFx0XHRcIlx0XHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdCNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcIixcblx0XHRcdFwiXHRcdHRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1wiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHQjaWZkZWYgTUVUQUxcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogYW1iaWVudCArIHRvdGFsU3BlY3VsYXIgKTtcIixcblxuXHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdGdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogKCB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIGFtYmllbnQgKSArIHRvdGFsU3BlY3VsYXI7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdGlmICggZW5hYmxlUmVmbGVjdGlvbiApIHtcIixcblxuXHRcdFx0XCJcdFx0dmVjMyB2UmVmbGVjdDtcIixcblx0XHRcdFwiXHRcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcIixcblxuXHRcdFx0XCJcdFx0aWYgKCB1c2VSZWZyYWN0ICkge1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XCIsXG5cblx0XHRcdFwiXHRcdH0gZWxzZSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsICk7XCIsXG5cblx0XHRcdFwiXHRcdH1cIixcblxuXHRcdFx0XCJcdFx0dmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIC12UmVmbGVjdC54LCB2UmVmbGVjdC55eiApICk7XCIsXG5cblx0XHRcdFwiXHRcdCNpZmRlZiBHQU1NQV9JTlBVVFwiLFxuXG5cdFx0XHRcIlx0XHRcdGN1YmVDb2xvci54eXogKj0gY3ViZUNvbG9yLnh5ejtcIixcblxuXHRcdFx0XCJcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRcdGdsX0ZyYWdDb2xvci54eXogPSBtaXgoIGdsX0ZyYWdDb2xvci54eXosIGN1YmVDb2xvci54eXosIHNwZWN1bGFyVGV4LnIgKiByZWZsZWN0aXZpdHkgKTtcIixcblxuXHRcdFx0XCJcdH1cIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwiYXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU9mZnNldDtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHVSZXBlYXQ7XCIsXG5cblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpc3BsYWNlbWVudDtcIixcblxuXHRcdFx0XCIjaWZkZWYgVkVSVEVYX1RFWFRVUkVTXCIsXG5cblx0XHRcdFwiXHR1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcGxhY2VtZW50O1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudFNjYWxlO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudEJpYXM7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZUYW5nZW50O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0Ly8gbm9ybWFsLCB0YW5nZW50IGFuZCBiaW5vcm1hbCB2ZWN0b3JzXG5cblx0XHRcdFwiXHQjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXG5cblx0XHRcdFwiXHRcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWROb3JtYWwueHl6ICk7XCIsXG5cblx0XHRcdFwiXHRcdHZlYzQgc2tpbm5lZFRhbmdlbnQgPSBza2luTWF0cml4ICogdmVjNCggdGFuZ2VudC54eXosIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0dlRhbmdlbnQgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWRUYW5nZW50Lnh5eiApO1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXG5cdFx0XHRcIlx0XHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogdGFuZ2VudC54eXogKTtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0dkJpbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1wiLFxuXG5cdFx0XHRcIlx0dlV2ID0gdXYgKiB1UmVwZWF0ICsgdU9mZnNldDtcIixcblxuXHRcdFx0XHQvLyBkaXNwbGFjZW1lbnQgbWFwcGluZ1xuXG5cdFx0XHRcIlx0dmVjMyBkaXNwbGFjZWRQb3NpdGlvbjtcIixcblxuXHRcdFx0XCJcdCNpZmRlZiBWRVJURVhfVEVYVFVSRVNcIixcblxuXHRcdFx0XCJcdFx0aWYgKCBlbmFibGVEaXNwbGFjZW1lbnQgKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dmVjMyBkdiA9IHRleHR1cmUyRCggdERpc3BsYWNlbWVudCwgdXYgKS54eXo7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGRmID0gdURpc3BsYWNlbWVudFNjYWxlICogZHYueCArIHVEaXNwbGFjZW1lbnRCaWFzO1wiLFxuXHRcdFx0XCJcdFx0XHRkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgbm9ybWFsaXplKCBub3JtYWwgKSAqIGRmO1wiLFxuXG5cdFx0XHRcIlx0XHR9IGVsc2Uge1wiLFxuXG5cdFx0XHRcIlx0XHRcdCNpZmRlZiBVU0VfU0tJTk5JTkdcIixcblxuXHRcdFx0XCJcdFx0XHRcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcIixcblxuXHRcdFx0XCJcdFx0XHRcdGRpc3BsYWNlZFBvc2l0aW9uID0gc2tpbm5lZC54eXo7XCIsXG5cblx0XHRcdFwiXHRcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRcdGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXG5cblx0XHRcdFwiXHRcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRcdH1cIixcblxuXHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdCNpZmRlZiBVU0VfU0tJTk5JTkdcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcblx0XHRcdFwiXHRcdFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XCIsXG5cdFx0XHRcIlx0XHRcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1wiLFxuXHRcdFx0XCJcdFx0XHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcIixcblx0XHRcdFwiXHRcdFx0c2tpbm5lZCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQ7XCIsXG5cblx0XHRcdFwiXHRcdFx0ZGlzcGxhY2VkUG9zaXRpb24gPSBza2lubmVkLnh5ejtcIixcblxuXHRcdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcIlx0XHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XHRcIlx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXG5cdFx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcIixcblxuXHRcdFx0XHQvLyBzaGFkb3dzXG5cblx0XHRcdFwiXHQjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxuXG5cdFx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcIlx0XHR9XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0J2N1YmUnOiB7XG5cblx0XHR1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0fSxcblxuXHQvKiBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxuXHQgKlxuXHQgKiBiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGV4YW1wbGVcblx0ICogaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XG5cdCAqXG5cdCAqIG9yaWdpbmFsbHkgZnJvbVxuXHQgKiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxuXHQgKlxuXHQgKiBzZWUgYWxzb1xuXHQgKiBodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cblx0ICovXG5cblx0J2RlcHRoUkdCQSc6IHtcblxuXHRcdHVuaWZvcm1zOiB7fSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG5cblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X21hc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcblx0XHRcdFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLCAvLyBcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcblx0XHRcdFwiXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcblx0XHRcdFwiXHRyZXR1cm4gcmVzO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdEZXB0aEVYVCApO1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcblx0XHRcdFx0Ly9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcblx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cblx0X3ByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXG5cblx0X2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxuXHRfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcblx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcblx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblx0X2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlLFxuXG5cdF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxuXHRfY2xlYXJBbHBoYSA9IDA7XG5cblx0dmFyIGxpZ2h0cyA9IFtdO1xuXG5cdHZhciBfd2ViZ2xPYmplY3RzID0ge307XG5cdHZhciBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlID0gW107XG5cblx0dmFyIG9wYXF1ZU9iamVjdHMgPSBbXTtcblx0dmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IFtdO1xuXG5cdHZhciBzcHJpdGVzID0gW107XG5cdHZhciBsZW5zRmxhcmVzID0gW107XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHR0aGlzLmNvbnRleHQgPSBudWxsO1xuXHR0aGlzLmRldmljZVBpeGVsUmF0aW8gPSBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQgPyBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW9cblx0XHRcdFx0IDogc2VsZi5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQgPyBzZWxmLmRldmljZVBpeGVsUmF0aW9cblx0XHRcdFx0XHQgOiAxO1xuXG5cdC8vIGNsZWFyaW5nXG5cblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcblx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0Ly8gc2NlbmUgZ3JhcGhcblxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHR0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcblx0dGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xuXG5cdC8vIHNoYWRvdyBtYXBcblxuXHR0aGlzLnNoYWRvd01hcEVuYWJsZWQgPSBmYWxzZTtcblx0dGhpcy5zaGFkb3dNYXBUeXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xuXHR0aGlzLnNoYWRvd01hcEN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcblx0dGhpcy5zaGFkb3dNYXBEZWJ1ZyA9IGZhbHNlO1xuXHR0aGlzLnNoYWRvd01hcENhc2NhZGUgPSBmYWxzZTtcblxuXHQvLyBtb3JwaHNcblxuXHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XG5cdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcblxuXHQvLyBmbGFnc1xuXG5cdHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xuXG5cdC8vIGluZm9cblxuXHR0aGlzLmluZm8gPSB7XG5cblx0XHRtZW1vcnk6IHtcblxuXHRcdFx0cHJvZ3JhbXM6IDAsXG5cdFx0XHRnZW9tZXRyaWVzOiAwLFxuXHRcdFx0dGV4dHVyZXM6IDBcblxuXHRcdH0sXG5cblx0XHRyZW5kZXI6IHtcblxuXHRcdFx0Y2FsbHM6IDAsXG5cdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdGZhY2VzOiAwLFxuXHRcdFx0cG9pbnRzOiAwXG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cblx0dmFyIF90aGlzID0gdGhpcyxcblxuXHRfcHJvZ3JhbXMgPSBbXSxcblxuXHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxuXG5cdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXG5cdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxuXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDEsXG5cdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtIDEsXG5cdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcblxuXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXG5cblx0Ly8gR0wgc3RhdGUgY2FjaGVcblxuXHRfb2xkRG91YmxlU2lkZWQgPSAtIDEsXG5cdF9vbGRGbGlwU2lkZWQgPSAtIDEsXG5cblx0X29sZEJsZW5kaW5nID0gLSAxLFxuXG5cdF9vbGRCbGVuZEVxdWF0aW9uID0gLSAxLFxuXHRfb2xkQmxlbmRTcmMgPSAtIDEsXG5cdF9vbGRCbGVuZERzdCA9IC0gMSxcblxuXHRfb2xkRGVwdGhUZXN0ID0gLSAxLFxuXHRfb2xkRGVwdGhXcml0ZSA9IC0gMSxcblxuXHRfb2xkUG9seWdvbk9mZnNldCA9IG51bGwsXG5cdF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbCxcblx0X29sZFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGwsXG5cblx0X29sZExpbmVXaWR0aCA9IG51bGwsXG5cblx0X3ZpZXdwb3J0WCA9IDAsXG5cdF92aWV3cG9ydFkgPSAwLFxuXHRfdmlld3BvcnRXaWR0aCA9IF9jYW52YXMud2lkdGgsXG5cdF92aWV3cG9ydEhlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXHRfY3VycmVudFdpZHRoID0gMCxcblx0X2N1cnJlbnRIZWlnaHQgPSAwLFxuXG5cdF9uZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICksXG5cdF9lbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApLFxuXG5cdC8vIGZydXN0dW1cblxuXHRfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXG5cblx0IC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxuXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblx0X3Byb2pTY3JlZW5NYXRyaXhQUyA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG5cdF9kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcblxuXHRfbGlnaHRzID0ge1xuXG5cdFx0YW1iaWVudDogWyAwLCAwLCAwIF0sXG5cdFx0ZGlyZWN0aW9uYWw6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6W10sIHBvc2l0aW9uczogW10gfSxcblx0XHRwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10gfSxcblx0XHRzcG90OiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSwgZGlzdGFuY2VzOiBbXSwgZGlyZWN0aW9uczogW10sIGFuZ2xlc0NvczogW10sIGV4cG9uZW50czogW10gfSxcblx0XHRoZW1pOiB7IGxlbmd0aDogMCwgc2t5Q29sb3JzOiBbXSwgZ3JvdW5kQ29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9XG5cblx0fTtcblxuXHQvLyBpbml0aWFsaXplXG5cblx0dmFyIF9nbDtcblxuXHR0cnkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHRhbHBoYTogX2FscGhhLFxuXHRcdFx0ZGVwdGg6IF9kZXB0aCxcblx0XHRcdHN0ZW5jaWw6IF9zdGVuY2lsLFxuXHRcdFx0YW50aWFsaWFzOiBfYW50aWFsaWFzLFxuXHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXG5cdFx0fTtcblxuXHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcblxuXHRcdGlmICggX2dsID09PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJykgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuXHR9XG5cblx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQncmFuZ2VNaW4nOiAxLFxuXHRcdFx0XHQncmFuZ2VNYXgnOiAxLFxuXHRcdFx0XHQncHJlY2lzaW9uJzogMVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0dmFyIGV4dGVuc2lvbnMgPSBuZXcgVEhSRUUuV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cblx0aWYgKCBfbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gc2V0RGVmYXVsdEdMU3RhdGUoKSB7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuXHRcdF9nbC5jbGVhckRlcHRoKCAxICk7XG5cdFx0X2dsLmNsZWFyU3RlbmNpbCggMCApO1xuXG5cdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcblx0XHRfZ2wuZGVwdGhGdW5jKCBfZ2wuTEVRVUFMICk7XG5cblx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcblx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG5cdFx0X2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuXHR9XG5cblx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuXHR0aGlzLmNvbnRleHQgPSBfZ2w7XG5cblx0Ly8gR1BVIGNhcGFiaWxpdGllc1xuXG5cdHZhciBfbWF4VGV4dHVyZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblx0dmFyIF9tYXhWZXJ0ZXhUZXh0dXJlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblx0dmFyIF9tYXhUZXh0dXJlU2l6ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVEVYVFVSRV9TSVpFICk7XG5cdHZhciBfbWF4Q3ViZW1hcFNpemUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xuXG5cdHZhciBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IF9tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG5cdHZhciBfc3VwcG9ydHNCb25lVGV4dHVyZXMgPSBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXG5cdC8vXG5cblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5ISUdIX0ZMT0FUICk7XG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25Mb3dwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkxPV19GTE9BVCApO1xuXG5cdHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLkhJR0hfRkxPQVQgKTtcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkxvd3BGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5MT1dfRkxPQVQgKTtcblxuXHR2YXIgZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYXJyYXk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIGFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGFycmF5ID0gW107XG5cblx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSApIHtcblxuXHRcdFx0XHR2YXIgZm9ybWF0cyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICl7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHQvLyBjbGFtcCBwcmVjaXNpb24gdG8gbWF4aW11bSBhdmFpbGFibGVcblxuXHR2YXIgaGlnaHBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdC5wcmVjaXNpb24gPiAwICYmIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQucHJlY2lzaW9uID4gMDtcblx0dmFyIG1lZGl1bXBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDA7XG5cblx0aWYgKCBfcHJlY2lzaW9uID09PSAnaGlnaHAnICYmICEgaGlnaHBBdmFpbGFibGUgKSB7XG5cblx0XHRpZiAoIG1lZGl1bXBBdmFpbGFibGUgKSB7XG5cblx0XHRcdF9wcmVjaXNpb24gPSAnbWVkaXVtcCc7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBoaWdocCBub3Qgc3VwcG9ydGVkLCB1c2luZyBtZWRpdW1wLicgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9wcmVjaXNpb24gPSAnbG93cCc7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBoaWdocCBhbmQgbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWYgKCBfcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgJiYgISBtZWRpdW1wQXZhaWxhYmxlICkge1xuXG5cdFx0X3ByZWNpc2lvbiA9ICdsb3dwJztcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3AuJyApO1xuXG5cdH1cblxuXHQvLyBQbHVnaW5zXG5cblx0dmFyIHNoYWRvd01hcFBsdWdpbiA9IG5ldyBUSFJFRS5TaGFkb3dNYXBQbHVnaW4oIHRoaXMsIGxpZ2h0cywgX3dlYmdsT2JqZWN0cywgX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSApO1xuXG5cdHZhciBzcHJpdGVQbHVnaW4gPSBuZXcgVEhSRUUuU3ByaXRlUGx1Z2luKCB0aGlzLCBzcHJpdGVzICk7XG5cdHZhciBsZW5zRmxhcmVQbHVnaW4gPSBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCB0aGlzLCBsZW5zRmxhcmVzICk7XG5cblx0Ly8gQVBJXG5cblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9nbDtcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcztcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cblx0fTtcblxuXHR0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG5cdH07XG5cblx0dGhpcy5zdXBwb3J0c0JsZW5kTWluTWF4ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0TWF4QW5pc290cm9weSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdHZhbHVlID0gZXh0ZW5zaW9uICE9PSBudWxsID8gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApIDogMDtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0gKSgpO1xuXG5cdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9wcmVjaXNpb247XG5cblx0fTtcblxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG5cdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xuXG5cdFx0aWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0X3ZpZXdwb3J0WCA9IHggKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XG5cdFx0X3ZpZXdwb3J0WSA9IHkgKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XG5cblx0XHRfdmlld3BvcnRXaWR0aCA9IHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdF92aWV3cG9ydEhlaWdodCA9IGhlaWdodCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcblxuXHRcdF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG5cdH07XG5cblx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0X2dsLnNjaXNzb3IoXG5cdFx0XHR4ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvLFxuXHRcdFx0eSAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyxcblx0XHRcdHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvLFxuXHRcdFx0aGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvXG5cdFx0KTtcblxuXHR9O1xuXG5cdHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGVuYWJsZSApIHtcblxuXHRcdGVuYWJsZSA/IF9nbC5lbmFibGUoIF9nbC5TQ0lTU09SX1RFU1QgKSA6IF9nbC5kaXNhYmxlKCBfZ2wuU0NJU1NPUl9URVNUICk7XG5cblx0fTtcblxuXHQvLyBDbGVhcmluZ1xuXG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG5cdFx0X2NsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xuXHRcdF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcblxuXHRcdF9nbC5jbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG5cdH07XG5cblx0dGhpcy5zZXRDbGVhckNvbG9ySGV4ID0gZnVuY3Rpb24gKCBoZXgsIGFscGhhICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldENsZWFyQ29sb3JIZXgoKSBpcyBiZWluZyByZW1vdmVkLiBVc2UgLnNldENsZWFyQ29sb3IoKSBpbnN0ZWFkLicgKTtcblx0XHR0aGlzLnNldENsZWFyQ29sb3IoIGhleCwgYWxwaGEgKTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfY2xlYXJDb2xvcjtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfY2xlYXJBbHBoYTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdHZhciBiaXRzID0gMDtcblxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG5cdFx0X2dsLmNsZWFyKCBiaXRzICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfZ2wuY2xlYXIoIF9nbC5DT0xPUl9CVUZGRVJfQklUICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfZ2wuY2xlYXIoIF9nbC5ERVBUSF9CVUZGRVJfQklUICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdF9nbC5jbGVhciggX2dsLlNURU5DSUxfQlVGRkVSX0JJVCApO1xuXG5cdH07XG5cblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cblx0fTtcblxuXHQvLyBSZXNldFxuXG5cdHRoaXMucmVzZXRHTFN0YXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcblx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XG5cblx0XHRfb2xkQmxlbmRpbmcgPSAtIDE7XG5cdFx0X29sZERlcHRoVGVzdCA9IC0gMTtcblx0XHRfb2xkRGVwdGhXcml0ZSA9IC0gMTtcblx0XHRfb2xkRG91YmxlU2lkZWQgPSAtIDE7XG5cdFx0X29sZEZsaXBTaWRlZCA9IC0gMTtcblx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gLSAxO1xuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcblxuXHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBhbGxvY2F0aW9uXG5cblx0ZnVuY3Rpb24gY3JlYXRlUGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnkgKSB7XG5cblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVMaW5lQnVmZmVycyAoIGdlb21ldHJ5ICkge1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAgKSB7XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVVYyQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHR2YXIgbSwgbWw7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzID0gW107XG5cblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycy5wdXNoKCBfZ2wuY3JlYXRlQnVmZmVyKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVycyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnMucHVzaCggX2dsLmNyZWF0ZUJ1ZmZlcigpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHQvLyBFdmVudHNcblxuXHR2YXIgb25PYmplY3RSZW1vdmVkID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciBvYmplY3QgPSBldmVudC50YXJnZXQ7XG5cblx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGNoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZW1vdmUnLCBvbk9iamVjdFJlbW92ZWQgKTtcblxuXHRcdFx0cmVtb3ZlT2JqZWN0KCBjaGlsZCApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0dmFyIG9uR2VvbWV0cnlEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHR9O1xuXG5cdHZhciBvblRleHR1cmVEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcblxuXG5cdH07XG5cblx0dmFyIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cdH07XG5cblx0dmFyIG9uTWF0ZXJpYWxEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuXHR2YXIgZGVsZXRlQnVmZmVycyA9IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cdFxuXHRcdHZhciBidWZmZXJzID0gW1xuXHRcdFx0J19fd2ViZ2xWZXJ0ZXhCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xOb3JtYWxCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xUYW5nZW50QnVmZmVyJyxcblx0XHRcdCdfX3dlYmdsQ29sb3JCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xVVkJ1ZmZlcicsXG5cdFx0XHQnX193ZWJnbFVWMkJ1ZmZlcicsXG5cdFx0XHRcblx0XHRcdCdfX3dlYmdsU2tpbkluZGljZXNCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlcicsXG5cdFx0XHRcblx0XHRcdCdfX3dlYmdsRmFjZUJ1ZmZlcicsXG5cdFx0XHQnX193ZWJnbExpbmVCdWZmZXInLFxuXHRcdFx0XG5cdFx0XHQnX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlcidcblx0XHRdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbmFtZSA9IGJ1ZmZlcnNbIGkgXTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlbIG5hbWUgXSApO1xuXG5cdFx0XHRcdGRlbGV0ZSBnZW9tZXRyeVsgbmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjdXN0b20gYXR0cmlidXRlc1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFsgbmFtZSBdLmJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Q7XG5cblx0XHR9XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xuXG5cdH07XG5cblx0dmFyIGRlYWxsb2NhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRkZWxldGUgZ2VvbWV0cnkuX193ZWJnbEluaXQ7XG5cblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5idWZmZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGF0dHJpYnV0ZS5idWZmZXIgKTtcblxuXHRcdFx0XHRcdGRlbGV0ZSBhdHRyaWJ1dGUuYnVmZmVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5R3JvdXBzTGlzdCA9IGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXBzTGlzdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCxsID0gZ2VvbWV0cnlHcm91cHNMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5R3JvdXBzTGlzdFsgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBtIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgbSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWxldGVCdWZmZXJzKCBnZW9tZXRyeUdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3Vwc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWxldGVCdWZmZXJzKCBnZW9tZXRyeSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBUT0ZJWDogV29ya2Fyb3VuZCBmb3IgZGVsZXRlZCBnZW9tZXRyeSBiZWluZyBjdXJyZW50bHkgYm91bmRcblxuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtIDE7XG5cblx0fTtcblxuXHR2YXIgZGVhbGxvY2F0ZVRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdC8vIGN1YmUgdGV4dHVyZVxuXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0ZGVsZXRlIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gMkQgdGV4dHVyZVxuXG5cdFx0XHRpZiAoIHRleHR1cmUuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdFx0ZGVsZXRlIHRleHR1cmUuX193ZWJnbFRleHR1cmU7XG5cdFx0XHRkZWxldGUgdGV4dHVyZS5fX3dlYmdsSW5pdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHZhciBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0IHx8IHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0ZGVsZXRlIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XG5cdFx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXI7XG5cdFx0ZGVsZXRlIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyO1xuXG5cdH07XG5cblx0dmFyIGRlYWxsb2NhdGVNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW0ucHJvZ3JhbTtcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuXHRcdC8vIG9ubHkgZGVhbGxvY2F0ZSBHTCBwcm9ncmFtIGlmIHRoaXMgd2FzIHRoZSBsYXN0IHVzZSBvZiBzaGFyZWQgcHJvZ3JhbVxuXHRcdC8vIGFzc3VtZWQgdGhlcmUgaXMgb25seSBzaW5nbGUgY29weSBvZiBhbnkgcHJvZ3JhbSBpbiB0aGUgX3Byb2dyYW1zIGxpc3Rcblx0XHQvLyAodGhhdCdzIGhvdyBpdCdzIGNvbnN0cnVjdGVkKVxuXG5cdFx0dmFyIGksIGlsLCBwcm9ncmFtSW5mbztcblx0XHR2YXIgZGVsZXRlUHJvZ3JhbSA9IGZhbHNlO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gX3Byb2dyYW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvLnByb2dyYW0gPT09IHByb2dyYW0gKSB7XG5cblx0XHRcdFx0cHJvZ3JhbUluZm8udXNlZFRpbWVzIC0tO1xuXG5cdFx0XHRcdGlmICggcHJvZ3JhbUluZm8udXNlZFRpbWVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0ZGVsZXRlUHJvZ3JhbSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRlbGV0ZVByb2dyYW0gPT09IHRydWUgKSB7XG5cblx0XHRcdC8vIGF2b2lkIHVzaW5nIGFycmF5LnNwbGljZSwgdGhpcyBpcyBjb3N0bGllciB0aGFuIGNyZWF0aW5nIG5ldyBhcnJheSBmcm9tIHNjcmF0Y2hcblxuXHRcdFx0dmFyIG5ld1Byb2dyYW1zID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IF9wcm9ncmFtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggcHJvZ3JhbUluZm8ucHJvZ3JhbSAhPT0gcHJvZ3JhbSApIHtcblxuXHRcdFx0XHRcdG5ld1Byb2dyYW1zLnB1c2goIHByb2dyYW1JbmZvICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9wcm9ncmFtcyA9IG5ld1Byb2dyYW1zO1xuXG5cdFx0XHRfZ2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS5wcm9ncmFtcyAtLTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBpbml0aWFsaXphdGlvblxuXG5cdGZ1bmN0aW9uIGluaXRDdXN0b21BdHRyaWJ1dGVzICggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gbWF0ZXJpYWwuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdGlmICggISBhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkIHx8IGF0dHJpYnV0ZS5jcmVhdGVVbmlxdWVCdWZmZXJzICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdFx0XHR2YXIgc2l6ZSA9IDE7ICAgLy8gXCJmXCIgYW5kIFwiaVwiXG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjInICkgc2l6ZSA9IDI7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjMnICkgc2l6ZSA9IDM7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjQnICkgc2l6ZSA9IDQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAnYycgICkgc2l6ZSA9IDM7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2l6ZSA9IHNpemU7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gbmFtZTtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdFBhcnRpY2xlQnVmZmVycyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XG5cblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0Z2VvbWV0cnkuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcblx0XHRnZW9tZXRyeS5fX2NvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cblx0XHRnZW9tZXRyeS5fX3NvcnRBcnJheSA9IFtdO1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFBhcnRpY2xlQ291bnQgPSBudmVydGljZXM7XG5cblx0XHRpbml0Q3VzdG9tQXR0cmlidXRlcyggb2JqZWN0ICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBpbml0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgb2JqZWN0ICkge1xuXG5cdFx0dmFyIG52ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdGdlb21ldHJ5Ll9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cdFx0Z2VvbWV0cnkuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5Ll9fbGluZURpc3RhbmNlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAxICk7XG5cblx0XHRnZW9tZXRyeS5fX3dlYmdsTGluZUNvdW50ID0gbnZlcnRpY2VzO1xuXG5cdFx0aW5pdEN1c3RvbUF0dHJpYnV0ZXMoIG9iamVjdCApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdE1lc2hCdWZmZXJzICggZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LFxuXHRcdFx0ZmFjZXMzID0gZ2VvbWV0cnlHcm91cC5mYWNlczMsXG5cblx0XHRcdG52ZXJ0aWNlcyA9IGZhY2VzMy5sZW5ndGggKiAzLFxuXHRcdFx0bnRyaXMgICAgID0gZmFjZXMzLmxlbmd0aCAqIDEsXG5cdFx0XHRubGluZXMgICAgPSBmYWNlczMubGVuZ3RoICogMyxcblxuXHRcdFx0bWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeUdyb3VwICk7XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5R3JvdXAuX191dkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMiApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX191djJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuaGFzVGFuZ2VudHMgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiA0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggJiYgb2JqZWN0Lmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCApIHtcblxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5XZWlnaHRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcblxuXHRcdH1cblxuXHRcdHZhciBVaW50QXJyYXkgPSBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgIT09IG51bGwgJiYgbnRyaXMgPiAyMTg0NSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7IC8vIDY1NTM1IC8gM1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3R5cGVBcnJheSA9IFVpbnRBcnJheTtcblx0XHRnZW9tZXRyeUdyb3VwLl9fZmFjZUFycmF5ID0gbmV3IFVpbnRBcnJheSggbnRyaXMgKiAzICk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX2xpbmVBcnJheSA9IG5ldyBVaW50QXJyYXkoIG5saW5lcyAqIDIgKTtcblxuXHRcdHZhciBtLCBtbDtcblxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzLnB1c2goIG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzID0gW107XG5cblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX21vcnBoTm9ybWFsc0FycmF5cy5wdXNoKCBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50ID0gbnRyaXMgKiAzO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCA9IG5saW5lcyAqIDI7XG5cblxuXHRcdC8vIGN1c3RvbSBhdHRyaWJ1dGVzXG5cblx0XHRpZiAoIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gRG8gYSBzaGFsbG93IGNvcHkgb2YgdGhlIGF0dHJpYnV0ZSBvYmplY3Qgc28gZGlmZmVyZW50IGdlb21ldHJ5R3JvdXAgY2h1bmtzIHVzZSBkaWZmZXJlbnRcblx0XHRcdFx0Ly8gYXR0cmlidXRlIGJ1ZmZlcnMgd2hpY2ggYXJlIGNvcnJlY3RseSBpbmRleGVkIGluIHRoZSBzZXRNZXNoQnVmZmVycyBmdW5jdGlvblxuXG5cdFx0XHRcdHZhciBvcmlnaW5hbEF0dHJpYnV0ZSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIHByb3BlcnR5IGluIG9yaWdpbmFsQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlWyBwcm9wZXJ0eSBdID0gb3JpZ2luYWxBdHRyaWJ1dGVbIHByb3BlcnR5IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISBhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkIHx8IGF0dHJpYnV0ZS5jcmVhdGVVbmlxdWVCdWZmZXJzICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdFx0XHR2YXIgc2l6ZSA9IDE7ICAgLy8gXCJmXCIgYW5kIFwiaVwiXG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjInICkgc2l6ZSA9IDI7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjMnICkgc2l6ZSA9IDM7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjQnICkgc2l6ZSA9IDQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAnYycgICkgc2l6ZSA9IDM7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2l6ZSA9IHNpemU7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gbmFtZTtcblxuXHRcdFx0XHRcdG9yaWdpbmFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUuX19vcmlnaW5hbCA9IG9yaWdpbmFsQXR0cmlidXRlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXMgPSB0cnVlO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnlHcm91cCApIHtcblxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXG5cdFx0XHQgPyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyBnZW9tZXRyeUdyb3VwLm1hdGVyaWFsSW5kZXggXVxuXHRcdFx0IDogb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMgKCBtYXRlcmlhbCApIHtcblxuXHRcdHJldHVybiBtYXRlcmlhbCAmJiBtYXRlcmlhbC5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBzZXR0aW5nXG5cblx0ZnVuY3Rpb24gc2V0UGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnksIGhpbnQsIG9iamVjdCApIHtcblxuXHRcdHZhciB2LCBjLCB2ZXJ0ZXgsIG9mZnNldCwgaW5kZXgsIGNvbG9yLFxuXG5cdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcblxuXHRcdGNvbG9ycyA9IGdlb21ldHJ5LmNvbG9ycyxcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXG5cblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5Ll9fdmVydGV4QXJyYXksXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcblxuXHRcdHNvcnRBcnJheSA9IGdlb21ldHJ5Ll9fc29ydEFycmF5LFxuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlLFxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcblxuXHRcdGN1c3RvbUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsXG5cdFx0aSwgaWwsXG5cdFx0YSwgY2EsIGNhbCwgdmFsdWUsXG5cdFx0Y3VzdG9tQXR0cmlidXRlO1xuXG5cdFx0aWYgKCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5jb3B5KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5tdWx0aXBseSggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHYgXTtcblxuXHRcdFx0XHRfdmVjdG9yMy5jb3B5KCB2ZXJ0ZXggKTtcblx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeFBTICk7XG5cblx0XHRcdFx0c29ydEFycmF5WyB2IF0gPSBbIF92ZWN0b3IzLnosIHYgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzb3J0QXJyYXkuc29ydCggbnVtZXJpY2FsU29ydCApO1xuXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBzb3J0QXJyYXlbIHYgXVsgMSBdIF07XG5cblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xuXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xuXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBzb3J0QXJyYXlbIGMgXVsgMSBdIF07XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3Iucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggISAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICd2ZXJ0aWNlcycgKSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcblxuXHRcdFx0XHRcdGNhbCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZS5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgID0gdmFsdWUueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gJ2MnICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgICAgPSB2YWx1ZS5yO1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUuZztcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiAgXSA9IHZhbHVlLno7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcblxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHYgXTtcblxuXHRcdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xuXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xuXHRcdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxIF0gPSB2ZXJ0ZXgueTtcblx0XHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGlydHlDb2xvcnMgKSB7XG5cblx0XHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XG5cblx0XHRcdFx0XHRvZmZzZXQgPSBjICogMztcblxuXHRcdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XG5cdFx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXG5cdFx0XHRcdFx0XHQgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0XHRcdCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ3ZlcnRpY2VzJyApICkge1xuXG5cdFx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSAwO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBjYSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSAnYycgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUubmVlZHNVcGRhdGUgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCApIHtcblxuXHRcdHZhciB2LCBjLCBkLCB2ZXJ0ZXgsIG9mZnNldCwgY29sb3IsXG5cblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuXHRcdGNvbG9ycyA9IGdlb21ldHJ5LmNvbG9ycyxcblx0XHRsaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlcyxcblxuXHRcdHZsID0gdmVydGljZXMubGVuZ3RoLFxuXHRcdGNsID0gY29sb3JzLmxlbmd0aCxcblx0XHRkbCA9IGxpbmVEaXN0YW5jZXMubGVuZ3RoLFxuXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXG5cdFx0bGluZURpc3RhbmNlQXJyYXkgPSBnZW9tZXRyeS5fX2xpbmVEaXN0YW5jZUFycmF5LFxuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eUNvbG9ycyA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUsXG5cdFx0ZGlydHlMaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUsXG5cblx0XHRjdXN0b21BdHRyaWJ1dGVzID0gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxuXG5cdFx0aSwgaWwsXG5cdFx0YSwgY2EsIGNhbCwgdmFsdWUsXG5cdFx0Y3VzdG9tQXR0cmlidXRlO1xuXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xuXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XG5cblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xuXG5cdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xuXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XG5cblx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3Iucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3JBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUxpbmVEaXN0YW5jZXMgKSB7XG5cblx0XHRcdGZvciAoIGQgPSAwOyBkIDwgZGw7IGQgKysgKSB7XG5cblx0XHRcdFx0bGluZURpc3RhbmNlQXJyYXlbIGQgXSA9IGxpbmVEaXN0YW5jZXNbIGQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGxpbmVEaXN0YW5jZUFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXG5cdFx0XHRcdFx0ICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdFx0IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSAndmVydGljZXMnICkgKSB7XG5cblx0XHRcdFx0XHRvZmZzZXQgPSAwO1xuXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnR5cGUgPT09ICdjJyApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgID0gdmFsdWUucjtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgID0gdmFsdWUueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIGhpbnQsIGRpc3Bvc2UsIG1hdGVyaWFsICkge1xuXG5cdFx0aWYgKCAhIGdlb21ldHJ5R3JvdXAuX19pbml0dGVkQXJyYXlzICkge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgbmVlZHNTbW9vdGhOb3JtYWxzID0gbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMoIG1hdGVyaWFsICk7XG5cblx0XHR2YXIgZiwgZmwsIGZpLCBmYWNlLFxuXHRcdHZlcnRleE5vcm1hbHMsIGZhY2VOb3JtYWwsIG5vcm1hbCxcblx0XHR2ZXJ0ZXhDb2xvcnMsIGZhY2VDb2xvcixcblx0XHR2ZXJ0ZXhUYW5nZW50cyxcblx0XHR1diwgdXYyLCB2MSwgdjIsIHYzLCB2NCwgdDEsIHQyLCB0MywgdDQsIG4xLCBuMiwgbjMsIG40LFxuXHRcdGMxLCBjMiwgYzMsXG5cdFx0c3cxLCBzdzIsIHN3Mywgc3c0LFxuXHRcdHNpMSwgc2kyLCBzaTMsIHNpNCxcblx0XHRzYTEsIHNhMiwgc2EzLCBzYTQsXG5cdFx0c2IxLCBzYjIsIHNiMywgc2I0LFxuXHRcdG0sIG1sLCBpLCBpbCxcblx0XHR2biwgdXZpLCB1djJpLFxuXHRcdHZrLCB2a2wsIHZrYSxcblx0XHRua2EsIGNoZiwgZmFjZVZlcnRleE5vcm1hbHMsXG5cdFx0YSxcblxuXHRcdHZlcnRleEluZGV4ID0gMCxcblxuXHRcdG9mZnNldCA9IDAsXG5cdFx0b2Zmc2V0X3V2ID0gMCxcblx0XHRvZmZzZXRfdXYyID0gMCxcblx0XHRvZmZzZXRfZmFjZSA9IDAsXG5cdFx0b2Zmc2V0X25vcm1hbCA9IDAsXG5cdFx0b2Zmc2V0X3RhbmdlbnQgPSAwLFxuXHRcdG9mZnNldF9saW5lID0gMCxcblx0XHRvZmZzZXRfY29sb3IgPSAwLFxuXHRcdG9mZnNldF9za2luID0gMCxcblx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgPSAwLFxuXHRcdG9mZnNldF9jdXN0b20gPSAwLFxuXHRcdG9mZnNldF9jdXN0b21TcmMgPSAwLFxuXG5cdFx0dmFsdWUsXG5cblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheSxcblx0XHR1dkFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXksXG5cdFx0dXYyQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdXYyQXJyYXksXG5cdFx0bm9ybWFsQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fbm9ybWFsQXJyYXksXG5cdFx0dGFuZ2VudEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheSxcblx0XHRjb2xvckFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXksXG5cblx0XHRza2luSW5kZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luSW5kZXhBcnJheSxcblx0XHRza2luV2VpZ2h0QXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fc2tpbldlaWdodEFycmF5LFxuXG5cdFx0bW9ycGhUYXJnZXRzQXJyYXlzID0gZ2VvbWV0cnlHcm91cC5fX21vcnBoVGFyZ2V0c0FycmF5cyxcblx0XHRtb3JwaE5vcm1hbHNBcnJheXMgPSBnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzLFxuXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxuXHRcdGN1c3RvbUF0dHJpYnV0ZSxcblxuXHRcdGZhY2VBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXksXG5cdFx0bGluZUFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2xpbmVBcnJheSxcblxuXHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LCAvLyB0aGlzIGlzIHNoYXJlZCBmb3IgYWxsIGNodW5rc1xuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlLFxuXHRcdGRpcnR5VXZzID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eU5vcm1hbHMgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eVRhbmdlbnRzID0gZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlLFxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c05lZWRVcGRhdGUsXG5cblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuXHRcdGNodW5rX2ZhY2VzMyA9IGdlb21ldHJ5R3JvdXAuZmFjZXMzLFxuXHRcdG9ial9mYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxuXG5cdFx0b2JqX3V2cyAgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0b2JqX3V2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAxIF0sXG5cblx0XHRvYmpfY29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxuXG5cdFx0b2JqX3NraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXMsXG5cdFx0b2JqX3NraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHMsXG5cblx0XHRtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMsXG5cdFx0bW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xuXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHR2MSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0djIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHRcdHYzID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2MS54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdjEueTtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHYxLno7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDMgXSA9IHYyLng7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA0IF0gPSB2Mi55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNSBdID0gdjIuejtcblxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNiBdID0gdjMueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDcgXSA9IHYzLnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA4IF0gPSB2My56O1xuXG5cdFx0XHRcdG9mZnNldCArPSA5O1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eU1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0Zm9yICggdmsgPSAwLCB2a2wgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB2ayA8IHZrbDsgdmsgKysgKSB7XG5cblx0XHRcdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ID0gMDtcblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRjaGYgPSBjaHVua19mYWNlczNbIGYgXTtcblx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaGYgXTtcblxuXHRcdFx0XHRcdC8vIG1vcnBoIHBvc2l0aW9uc1xuXG5cdFx0XHRcdFx0djEgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdHYyID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0XHR2MyA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0XHR2a2EgPSBtb3JwaFRhcmdldHNBcnJheXNbIHZrIF07XG5cblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCBdICAgICA9IHYxLng7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxIF0gPSB2MS55O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMiBdID0gdjEuejtcblxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gdjIueDtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDQgXSA9IHYyLnk7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSB2Mi56O1xuXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSB2My54O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNyBdID0gdjMueTtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDggXSA9IHYzLno7XG5cblx0XHRcdFx0XHQvLyBtb3JwaCBub3JtYWxzXG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1Ntb290aE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHNbIHZrIF0udmVydGV4Tm9ybWFsc1sgY2hmIF07XG5cblx0XHRcdFx0XHRcdFx0bjEgPSBmYWNlVmVydGV4Tm9ybWFscy5hO1xuXHRcdFx0XHRcdFx0XHRuMiA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmI7XG5cdFx0XHRcdFx0XHRcdG4zID0gZmFjZVZlcnRleE5vcm1hbHMuYztcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRuMSA9IG1vcnBoTm9ybWFsc1sgdmsgXS5mYWNlTm9ybWFsc1sgY2hmIF07XG5cdFx0XHRcdFx0XHRcdG4yID0gbjE7XG5cdFx0XHRcdFx0XHRcdG4zID0gbjE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bmthID0gbW9ycGhOb3JtYWxzQXJyYXlzWyB2ayBdO1xuXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCBdICAgICA9IG4xLng7XG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IG4xLnk7XG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IG4xLno7XG5cblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gbjIueDtcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gbjIueTtcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNSBdID0gbjIuejtcblxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSBuMy54O1xuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA3IF0gPSBuMy55O1xuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSBuMy56O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9cblxuXHRcdFx0XHRcdG9mZnNldF9tb3JwaFRhcmdldCArPSA5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgdmsgXSApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbW9ycGhUYXJnZXRzQXJyYXlzWyB2ayBdLCBoaW50ICk7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgdmsgXSApO1xuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBtb3JwaE5vcm1hbHNBcnJheXNbIHZrIF0sIGhpbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqX3NraW5XZWlnaHRzLmxlbmd0aCApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0Ly8gd2VpZ2h0c1xuXG5cdFx0XHRcdHN3MSA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5hIF07XG5cdFx0XHRcdHN3MiA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5iIF07XG5cdFx0XHRcdHN3MyA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5jIF07XG5cblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHN3MS54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc3cxLnk7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzdzEuejtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHN3MS53O1xuXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzdzIueDtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHN3Mi55O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc3cyLno7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzdzIudztcblxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOCBdICA9IHN3My54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHN3My55O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHN3My56O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTEgXSA9IHN3My53O1xuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHRzaTEgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHRzaTIgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHRzaTMgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHNpMS54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzaTEueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc2kxLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHNpMS53O1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNpMi54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA1IF0gPSBzaTIueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc2kyLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHNpMi53O1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzaTMueDtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNpMy55O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc2kzLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzaTMudztcblxuXHRcdFx0XHRvZmZzZXRfc2tpbiArPSAxMjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF9za2luID4gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHNraW5JbmRleEFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luV2VpZ2h0QXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRcdGZhY2VDb2xvciA9IGZhY2UuY29sb3I7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICYmIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gVEhSRUUuVmVydGV4Q29sb3JzICkge1xuXG5cdFx0XHRcdFx0YzEgPSB2ZXJ0ZXhDb2xvcnNbIDAgXTtcblx0XHRcdFx0XHRjMiA9IHZlcnRleENvbG9yc1sgMSBdO1xuXHRcdFx0XHRcdGMzID0gdmVydGV4Q29sb3JzWyAyIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGMxID0gZmFjZUNvbG9yO1xuXHRcdFx0XHRcdGMyID0gZmFjZUNvbG9yO1xuXHRcdFx0XHRcdGMzID0gZmFjZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgXSAgICAgPSBjMS5yO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxIF0gPSBjMS5nO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAyIF0gPSBjMS5iO1xuXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDMgXSA9IGMyLnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDQgXSA9IGMyLmc7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDUgXSA9IGMyLmI7XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNiBdID0gYzMucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNyBdID0gYzMuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOCBdID0gYzMuYjtcblxuXHRcdFx0XHRvZmZzZXRfY29sb3IgKz0gOTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF9jb2xvciA+IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvckFycmF5LCBoaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlUYW5nZW50cyAmJiBnZW9tZXRyeS5oYXNUYW5nZW50cyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4VGFuZ2VudHMgPSBmYWNlLnZlcnRleFRhbmdlbnRzO1xuXG5cdFx0XHRcdHQxID0gdmVydGV4VGFuZ2VudHNbIDAgXTtcblx0XHRcdFx0dDIgPSB2ZXJ0ZXhUYW5nZW50c1sgMSBdO1xuXHRcdFx0XHR0MyA9IHZlcnRleFRhbmdlbnRzWyAyIF07XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCBdICAgICA9IHQxLng7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxIF0gPSB0MS55O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMiBdID0gdDEuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDMgXSA9IHQxLnc7XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDQgXSA9IHQyLng7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA1IF0gPSB0Mi55O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgNiBdID0gdDIuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDcgXSA9IHQyLnc7XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDggXSAgPSB0My54O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOSBdICA9IHQzLnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMCBdID0gdDMuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDExIF0gPSB0My53O1xuXG5cdFx0XHRcdG9mZnNldF90YW5nZW50ICs9IDEyO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudEFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5Tm9ybWFscyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgJiYgbmVlZHNTbW9vdGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2biA9IHZlcnRleE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSB2bi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSB2bi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSB2bi56O1xuXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSBmYWNlTm9ybWFsLng7XG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDEgXSA9IGZhY2VOb3JtYWwueTtcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gZmFjZU5vcm1hbC56O1xuXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWxBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmkgPSBjaHVua19mYWNlczNbIGYgXTtcblxuXHRcdFx0XHR1diA9IG9ial91dnNbIGZpIF07XG5cblx0XHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dXZpID0gdXZbIGkgXTtcblxuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diBdICAgICA9IHV2aS54O1xuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diArIDEgXSA9IHV2aS55O1xuXG5cdFx0XHRcdFx0b2Zmc2V0X3V2ICs9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2Zmc2V0X3V2ID4gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHV2QXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzMiApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXMzWyBmIF07XG5cblx0XHRcdFx0dXYyID0gb2JqX3V2czJbIGZpIF07XG5cblx0XHRcdFx0aWYgKCB1djIgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdHV2MmkgPSB1djJbIGkgXTtcblxuXHRcdFx0XHRcdHV2MkFycmF5WyBvZmZzZXRfdXYyIF0gICAgID0gdXYyaS54O1xuXHRcdFx0XHRcdHV2MkFycmF5WyBvZmZzZXRfdXYyICsgMSBdID0gdXYyaS55O1xuXG5cdFx0XHRcdFx0b2Zmc2V0X3V2MiArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF91djIgPiAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHV2MkFycmF5LCBoaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlFbGVtZW50cyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgXSAgID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAyIF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cblx0XHRcdFx0b2Zmc2V0X2ZhY2UgKz0gMztcblxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lIF0gICAgID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDIgXSA9IHZlcnRleEluZGV4O1xuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMyBdID0gdmVydGV4SW5kZXggKyAyO1xuXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA0IF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA1IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cblx0XHRcdFx0b2Zmc2V0X2xpbmUgKz0gNjtcblxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCArPSAzO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VBcnJheSwgaGludCApO1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBsaW5lQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCAhIGN1c3RvbUF0dHJpYnV0ZS5fX29yaWdpbmFsLm5lZWRzVXBkYXRlICkgY29udGludWU7XG5cblx0XHRcdFx0b2Zmc2V0X2N1c3RvbSA9IDA7XG5cdFx0XHRcdG9mZnNldF9jdXN0b21TcmMgPSAwO1xuXG5cdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICd2ZXJ0aWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ2ZhY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICd2ZXJ0aWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdFx0XHR2MyA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gICAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA2O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ2ZhY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gICAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA2O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgcHA7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSAnYycgKSB7XG5cblx0XHRcdFx0XHRcdHBwID0gWyAncicsICdnJywgJ2InIF07XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwcCA9IFsgJ3gnLCAneScsICd6JyBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSAndmVydGljZXMnICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IHYxWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjJbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4IF0gPSB2M1sgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICdmYWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IHYxWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjJbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4IF0gPSB2M1sgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICdmYWNlVmVydGljZXMnICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZVsgMCBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlWyAxIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWVbIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSAgICAgPSB2MVsgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MVsgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2MVsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYyWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYyWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjNbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyBdID0gdjNbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCBdID0gdjNbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ3ZlcnRpY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gICA9IHYxLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICdmYWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ2ZhY2VWZXJ0aWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlWyAwIF07XG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVbIDEgXTtcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZVsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXNwb3NlICkge1xuXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXM7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2MkFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3ZlcnRleEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHR2YXIgYXR0cmlidXRlc0tleXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzS2V5cztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZXNLZXlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBrZXkgPSBhdHRyaWJ1dGVzS2V5c1sgaSBdO1xuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5idWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlLm5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciBidWZmZXJUeXBlID0gKCBrZXkgPT09ICdpbmRleCcgKSA/IF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IF9nbC5BUlJBWV9CVUZGRVI7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZS5hcnJheSwgX2dsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG5cdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyAmJiAhIG9iamVjdC5fX3dlYmdsVmVydGV4QnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciApIG9iamVjdC5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcgKSB7XG5cblx0XHRcdFx0dmFyIG54LCBueSwgbnosXG5cdFx0XHRcdFx0bmF4LCBuYngsIG5jeCwgbmF5LCBuYnksIG5jeSwgbmF6LCBuYnosIG5jeixcblx0XHRcdFx0XHRub3JtYWxBcnJheSxcblx0XHRcdFx0XHRpLCBpbCA9IG9iamVjdC5jb3VudCAqIDM7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArPSA5ICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XG5cblx0XHRcdFx0XHRuYXggID0gbm9ybWFsQXJyYXlbIGkgXTtcblx0XHRcdFx0XHRuYXkgID0gbm9ybWFsQXJyYXlbIGkgKyAxIF07XG5cdFx0XHRcdFx0bmF6ICA9IG5vcm1hbEFycmF5WyBpICsgMiBdO1xuXG5cdFx0XHRcdFx0bmJ4ICA9IG5vcm1hbEFycmF5WyBpICsgMyBdO1xuXHRcdFx0XHRcdG5ieSAgPSBub3JtYWxBcnJheVsgaSArIDQgXTtcblx0XHRcdFx0XHRuYnogID0gbm9ybWFsQXJyYXlbIGkgKyA1IF07XG5cblx0XHRcdFx0XHRuY3ggID0gbm9ybWFsQXJyYXlbIGkgKyA2IF07XG5cdFx0XHRcdFx0bmN5ICA9IG5vcm1hbEFycmF5WyBpICsgNyBdO1xuXHRcdFx0XHRcdG5jeiAgPSBub3JtYWxBcnJheVsgaSArIDggXTtcblxuXHRcdFx0XHRcdG54ID0gKCBuYXggKyBuYnggKyBuY3ggKSAvIDM7XG5cdFx0XHRcdFx0bnkgPSAoIG5heSArIG5ieSArIG5jeSApIC8gMztcblx0XHRcdFx0XHRueiA9ICggbmF6ICsgbmJ6ICsgbmN6ICkgLyAzO1xuXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgXSAgID0gbng7XG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyAxIF0gPSBueTtcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDIgXSA9IG56O1xuXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyAzIF0gPSBueDtcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDQgXSA9IG55O1xuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNSBdID0gbno7XG5cblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDYgXSA9IG54O1xuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNyBdID0gbnk7XG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA4IF0gPSBuejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbS5hdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtLmF0dHJpYnV0ZXMudXYgKTtcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW0uYXR0cmlidXRlcy5jb2xvciApO1xuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuXHRcdG9iamVjdC5jb3VudCA9IDA7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcblxuXHRcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBwcm9ncmFtQXR0cmlidXRlc0tleXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXNLZXlzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcHJvZ3JhbUF0dHJpYnV0ZXNLZXlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBrZXkgPSBwcm9ncmFtQXR0cmlidXRlc0tleXNbIGkgXTtcblx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlBdHRyaWJ1dGUuYnVmZmVyICk7XG5cblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sga2V5IF0ubGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMmZ2KCBwcm9ncmFtQXR0cmlidXRlLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBrZXkgXSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sga2V5IF0ubGVuZ3RoID09PSAzICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBrZXkgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHR9XG5cblx0dGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBnZW9tZXRyeSwgb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZSxcblx0XHRcdHdpcmVmcmFtZUJpdCA9IG1hdGVyaWFsLndpcmVmcmFtZSA/IDEgOiAwLFxuXHRcdFx0Z2VvbWV0cnlIYXNoID0gKCBnZW9tZXRyeS5pZCAqIDB4ZmZmZmZmICkgKyAoIHByb2dyYW0uaWQgKiAyICkgKyB3aXJlZnJhbWVCaXQ7XG5cblx0XHRpZiAoIGdlb21ldHJ5SGFzaCAhPT0gX2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCApIHtcblxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IGdlb21ldHJ5SGFzaDtcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG5cdFx0XHRpbml0QXR0cmlidXRlcygpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIG1lc2hcblxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0dmFyIG1vZGUgPSBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgPyBfZ2wuTElORVMgOiBfZ2wuVFJJQU5HTEVTO1xuXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4O1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdC8vIGluZGV4ZWQgdHJpYW5nbGVzXG5cblx0XHRcdFx0dmFyIHR5cGUsIHNpemU7XG5cblx0XHRcdFx0aWYgKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdFx0XHRcdHNpemUgPSA0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0XHRcdHNpemUgPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwICk7XG5cblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBpbmRleC5hcnJheS5sZW5ndGg7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gaW5kZXguYXJyYXkubGVuZ3RoIC8gMztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIDEgY2h1bmtcblx0XHRcdFx0XHQvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXG5cdFx0XHRcdFx0Ly8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcblxuXHRcdFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzdGFydEluZGV4ID0gb2Zmc2V0c1sgaSBdLmluZGV4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKTtcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcmVuZGVyIGluZGV4ZWQgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIG9mZnNldHNbIGkgXS5jb3VudCwgdHlwZSwgb2Zmc2V0c1sgaSBdLnN0YXJ0ICogc2l6ZSApO1xuXG5cdFx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcblx0XHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudCAvIDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXTtcblxuXHRcdFx0XHQvLyByZW5kZXIgbm9uLWluZGV4ZWQgdHJpYW5nbGVzXG5cblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDMgKTtcblxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gOTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCApIHtcblxuXHRcdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xuXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHQvLyByZW5kZXIgcGFydGljbGVzXG5cblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuUE9JTlRTLCAwLCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzICk7XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHR2YXIgbW9kZSA9ICggb2JqZWN0Lm1vZGUgPT09IFRIUkVFLkxpbmVTdHJpcCApID8gX2dsLkxJTkVfU1RSSVAgOiBfZ2wuTElORVM7XG5cblx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwubGluZXdpZHRoICk7XG5cblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXg7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0Ly8gaW5kZXhlZCBsaW5lc1xuXG5cdFx0XHRcdHZhciB0eXBlLCBzaXplO1xuXG5cdFx0XHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdFx0XHRcdHNpemUgPSA0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0XHRcdHNpemUgPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XG5cblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBpbmRleC5hcnJheS5sZW5ndGg7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxIGNodW5rXG5cdFx0XHRcdFx0Ly8gbXVzdCBzZXQgYXR0cmlidXRlIHBvaW50ZXJzIHRvIHVzZSBuZXcgb2Zmc2V0cyBmb3IgZWFjaCBjaHVua1xuXHRcdFx0XHRcdC8vIGV2ZW4gaWYgZ2VvbWV0cnkgYW5kIG1hdGVyaWFscyBkaWRuJ3QgY2hhbmdlXG5cblx0XHRcdFx0XHRpZiAoIG9mZnNldHMubGVuZ3RoID4gMSApIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzdGFydEluZGV4ID0gb2Zmc2V0c1sgaSBdLmluZGV4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKTtcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcmVuZGVyIGluZGV4ZWQgbGluZXNcblxuXHRcdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgb2Zmc2V0c1sgaSBdLmNvdW50LCB0eXBlLCBvZmZzZXRzWyBpIF0uc3RhcnQgKiBzaXplICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XG5cblx0XHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50OyAvLyBub3QgcmVhbGx5IHRydWUsIGhlcmUgdmVydGljZXMgY2FuIGJlIHNoYXJlZFxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBsaW5lc1xuXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDMgKTtcblxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMucmVuZGVyQnVmZmVyID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlLFxuXHRcdFx0d2lyZWZyYW1lQml0ID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gMSA6IDAsXG5cdFx0XHRnZW9tZXRyeUdyb3VwSGFzaCA9ICggZ2VvbWV0cnlHcm91cC5pZCAqIDB4ZmZmZmZmICkgKyAoIHByb2dyYW0uaWQgKiAyICkgKyB3aXJlZnJhbWVCaXQ7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXBIYXNoICE9PSBfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoICkge1xuXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gZ2VvbWV0cnlHcm91cEhhc2g7XG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdH1cblxuXHRcdC8vIHZlcnRpY2VzXG5cblx0XHRpZiAoICEgbWF0ZXJpYWwubW9ycGhUYXJnZXRzICYmIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIHtcblxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSApIHtcblxuXHRcdFx0XHRzZXR1cE1vcnBoVGFyZ2V0cyggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0Ly8gY3VzdG9tIGF0dHJpYnV0ZXNcblxuXHRcdFx0Ly8gVXNlIHRoZSBwZXItZ2VvbWV0cnlHcm91cCBjdXN0b20gYXR0cmlidXRlIGFycmF5cyB3aGljaCBhcmUgc2V0dXAgaW4gaW5pdE1lc2hCdWZmZXJzXG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0WyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSApO1xuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0sIGF0dHJpYnV0ZS5zaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gY29sb3JzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwIHx8IG9iamVjdC5nZW9tZXRyeS5mYWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyICk7XG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIGF0dHJpYnV0ZXMuY29sb3IsIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMuY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID49IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRhbmdlbnRzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy50YW5nZW50ID49IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnRhbmdlbnQgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudGFuZ2VudCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2c1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgPj0gMCApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0gKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggYXR0cmlidXRlcy51diwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy51diApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYyID49IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMSBdICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApO1xuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51djIgKTtcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51djIsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIGF0dHJpYnV0ZXMudXYyLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLnV2MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICYmXG5cdFx0XHRcdCBhdHRyaWJ1dGVzLnNraW5JbmRleCA+PSAwICYmIGF0dHJpYnV0ZXMuc2tpbldlaWdodCA+PSAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciApO1xuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuc2tpbkluZGV4ICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnNraW5JbmRleCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuc2tpbldlaWdodCApO1xuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5za2luV2VpZ2h0LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbGluZSBkaXN0YW5jZXNcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSA+PSAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgKTtcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSApO1xuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5saW5lRGlzdGFuY2UsIDEsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdC8vIHJlbmRlciBtZXNoXG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdHZhciB0eXBlID0gZ2VvbWV0cnlHcm91cC5fX3R5cGVBcnJheSA9PT0gVWludDMyQXJyYXkgPyBfZ2wuVU5TSUdORURfSU5UIDogX2dsLlVOU0lHTkVEX1NIT1JUO1xuXG5cdFx0XHQvLyB3aXJlZnJhbWVcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgKSB7XG5cblx0XHRcdFx0c2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKTtcblx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUJ1ZmZlciApO1xuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuTElORVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCwgdHlwZSwgMCApO1xuXG5cdFx0XHQvLyB0cmlhbmdsZXNcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIF9nbC5UUklBTkdMRVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudCwgdHlwZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50O1xuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50IC8gMztcblxuXHRcdC8vIHJlbmRlciBsaW5lc1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuXHRcdFx0dmFyIG1vZGUgPSAoIG9iamVjdC5tb2RlID09PSBUSFJFRS5MaW5lU3RyaXAgKSA/IF9nbC5MSU5FX1NUUklQIDogX2dsLkxJTkVTO1xuXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xuXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggbW9kZSwgMCwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUNvdW50ICk7XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXG5cdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCApIHtcblxuXHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5QT0lOVFMsIDAsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFBhcnRpY2xlQ291bnQgKTtcblxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsUGFydGljbGVDb3VudDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gX25ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X25ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0X25ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdGlmICggX2VuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcblx0XHRcdF9lbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IF9lbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIF9lbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBfbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG5cdFx0XHRcdF9nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcblx0XHRcdFx0X2VuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwTW9ycGhUYXJnZXRzICggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcblxuXHRcdC8vIHNldCBiYXNlXG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLnByb2dyYW0uYXR0cmlidXRlcztcblxuXHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSAhPT0gLSAxICYmIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG9iamVjdC5tb3JwaFRhcmdldEJhc2UgXSApO1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEZvcmNlZE9yZGVyLmxlbmd0aCApIHtcblxuXHRcdFx0Ly8gc2V0IGZvcmNlZCBvcmRlclxuXG5cdFx0XHR2YXIgbSA9IDA7XG5cdFx0XHR2YXIgb3JkZXIgPSBvYmplY3QubW9ycGhUYXJnZXRGb3JjZWRPcmRlcjtcblx0XHRcdHZhciBpbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICYmIG0gPCBvcmRlci5sZW5ndGggKSB7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgbSBdID49IDAgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgb3JkZXJbIG0gXSBdICk7XG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgbSBdICk7XG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdID49IDAgJiYgbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbIG9yZGVyWyBtIF0gXSApO1xuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIG0gXSApO1xuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBtIF0gPSBpbmZsdWVuY2VzWyBvcmRlclsgbSBdIF07XG5cblx0XHRcdFx0bSArKztcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGZpbmQgdGhlIG1vc3QgaW5mbHVlbmNpbmdcblxuXHRcdFx0dmFyIGluZmx1ZW5jZSwgYWN0aXZlSW5mbHVlbmNlSW5kaWNlcyA9IFtdO1xuXHRcdFx0dmFyIGluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXHRcdFx0dmFyIGksIGlsID0gaW5mbHVlbmNlcy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlID4gMCApIHtcblxuXHRcdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID4gbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLmxlbmd0aCA9IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cztcblxuXHRcdFx0fSBlbHNlIGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5sZW5ndGggPiBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMucHVzaCggWyAwLCAwIF0gKTtcblxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGluZmx1ZW5jZUluZGV4LCBtID0gMDtcblxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlc1sgbSBdICkge1xuXG5cdFx0XHRcdFx0aW5mbHVlbmNlSW5kZXggPSBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzWyBtIF1bIDEgXTtcblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIG0gXSA+PSAwICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgaW5mbHVlbmNlSW5kZXggXSApO1xuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgbSBdICk7XG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdID49IDAgJiYgbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgaW5mbHVlbmNlSW5kZXggXSApO1xuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdICk7XG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gaW5mbHVlbmNlc1sgaW5mbHVlbmNlSW5kZXggXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCovXG5cblx0XHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bSArKztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbG9hZCB1cGRhdGVkIGluZmx1ZW5jZXMgdW5pZm9ybVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm0xZnYoIG1hdGVyaWFsLnByb2dyYW0udW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBTb3J0aW5nXG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xuXG5cdFx0XHRyZXR1cm4gYi5tYXRlcmlhbC5pZCAtIGEubWF0ZXJpYWwuaWQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuXHRcdGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBhLnogLSBiLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQgKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGJbIDAgXSAtIGFbIDAgXTtcblxuXHR9XG5cblx0Ly8gUmVuZGVyaW5nXG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuXHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG5cdFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxuXG5cdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IC0gMTtcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG5cdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuXHRcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gdW5kZWZpbmVkICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHQvLyB1cGRhdGUgU2tlbGV0b24gb2JqZWN0c1xuXG5cdFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xuXHRcdG9wYXF1ZU9iamVjdHMubGVuZ3RoID0gMDtcblx0XHR0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gMDtcblxuXHRcdHNwcml0ZXMubGVuZ3RoID0gMDtcblx0XHRsZW5zRmxhcmVzLmxlbmd0aCA9IDA7XG5cblx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgc2NlbmUgKTtcblxuXHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRcdHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocHJlIHBhc3MpXG5cblx0XHRzaGFkb3dNYXBQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHQvL1xuXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgPSAwO1xuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcblx0XHRfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyA9IDA7XG5cdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzID0gMDtcblxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0dGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHR9XG5cblx0XHQvLyBzZXQgbWF0cmljZXMgZm9yIGltbWVkaWF0ZSBvYmplY3RzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZVsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0XHRzZXR1cE1hdHJpY2VzKCBvYmplY3QsIGNhbWVyYSApO1xuXG5cdFx0XHRcdHVucm9sbEltbWVkaWF0ZUJ1ZmZlck1hdGVyaWFsKCB3ZWJnbE9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdHRoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblx0XHRcdHRoaXMuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcblx0XHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHRydWUsIG1hdGVyaWFsICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHRydWUsIG1hdGVyaWFsICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCAnJywgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UsIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBudWxsO1xuXG5cdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuXHRcdFx0dGhpcy5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcblx0XHRcdHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIF93ZWJnbE9iamVjdHNJbW1lZGlhdGUsICdvcGFxdWUnLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB0cnVlLCBtYXRlcmlhbCApO1xuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgJ3RyYW5zcGFyZW50JywgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxuXG5cdFx0c3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXHRcdGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XG5cblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuXHRcdFx0dXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cblx0XHR0aGlzLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuXHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xuXG5cdFx0Ly8gX2dsLmZpbmlzaCgpO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdCggc2NlbmUsIG9iamVjdCApIHtcblxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Hcm91cCApIHtcblxuXHRcdFx0Ly8gc2tpcFxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aW5pdE9iamVjdCggb2JqZWN0LCBzY2VuZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xuXG5cdFx0XHRcdGxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xuXG5cdFx0XHRcdHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcblxuXHRcdFx0XHRsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciB3ZWJnbE9iamVjdHMgPSBfd2ViZ2xPYmplY3RzWyBvYmplY3QuaWQgXTtcblxuXHRcdFx0XHRpZiAoIHdlYmdsT2JqZWN0cyAmJiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlT2JqZWN0KCBvYmplY3QsIHNjZW5lICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB3ZWJnbE9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gd2ViZ2xPYmplY3RzW2ldO1xuXG5cdFx0XHRcdFx0XHR1bnJvbGxCdWZmZXJNYXRlcmlhbCggd2ViZ2xPYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5yZW5kZXJEZXB0aCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QueiA9IF92ZWN0b3IzLno7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIG9iamVjdC5jaGlsZHJlblsgaSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHVzZUJsZW5kaW5nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0dmFyIG1hdGVyaWFsO1xuXG5cdFx0Zm9yICggdmFyIGkgPSByZW5kZXJMaXN0Lmxlbmd0aCAtIDE7IGkgIT09IC0gMTsgaSAtLSApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXHRcdFx0dmFyIGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcblxuXHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEgKTtcblxuXHRcdFx0aWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IHdlYmdsT2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggISBtYXRlcmlhbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggdXNlQmxlbmRpbmcgKSBfdGhpcy5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuXG5cdFx0XHRcdF90aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRcdF90aGlzLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcblxuXHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlciggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSAoIHJlbmRlckxpc3QsIG1hdGVyaWFsVHlwZSwgY2FtZXJhLCBsaWdodHMsIGZvZywgdXNlQmxlbmRpbmcsIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWw7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gd2ViZ2xPYmplY3RbIG1hdGVyaWFsVHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgX3RoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblxuXHRcdFx0XHRcdF90aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRcdFx0X3RoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdFx0XHRcdHNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLnJlbmRlckltbWVkaWF0ZU9iamVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IC0gMTtcblxuXHRcdF90aGlzLnNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoIG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcblxuXHRcdFx0b2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKCBwcm9ncmFtLCBfZ2wsIF9mcnVzdHVtICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHsgX3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7IH0gKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVucm9sbEltbWVkaWF0ZUJ1ZmZlck1hdGVyaWFsICggZ2xvYmplY3QgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gZ2xvYmplY3Qub2JqZWN0LFxuXHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRnbG9iamVjdC50cmFuc3BhcmVudCA9IG1hdGVyaWFsO1xuXHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbnVsbDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsb2JqZWN0Lm9wYXF1ZSA9IG1hdGVyaWFsO1xuXHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1bnJvbGxCdWZmZXJNYXRlcmlhbCAoIGdsb2JqZWN0ICkge1xuXG5cdFx0dmFyIG9iamVjdCA9IGdsb2JqZWN0Lm9iamVjdDtcblx0XHR2YXIgYnVmZmVyID0gZ2xvYmplY3QuYnVmZmVyO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPyAwIDogYnVmZmVyLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWwubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdGdsb2JqZWN0Lm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cblx0XHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzLnB1c2goIGdsb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b3BhcXVlT2JqZWN0cy5wdXNoKCBnbG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0Z2xvYmplY3QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHR0cmFuc3BhcmVudE9iamVjdHMucHVzaCggZ2xvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvcGFxdWVPYmplY3RzLnB1c2goIGdsb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdE9iamVjdCggb2JqZWN0LCBzY2VuZSApIHtcblxuXHRcdGlmICggb2JqZWN0Ll9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG9iamVjdC5fX3dlYmdsSW5pdCA9IHRydWU7XG5cdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0XHRvYmplY3QuX25vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cblx0XHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyKCAncmVtb3ZlZCcsIG9uT2JqZWN0UmVtb3ZlZCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBJbW1lZGlhdGVSZW5kZXJPYmplY3RcblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xJbml0ID0gdHJ1ZTtcblx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdFx0aW5pdEdlb21ldHJ5R3JvdXBzKCBzY2VuZSwgb2JqZWN0LCBnZW9tZXRyeSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y3JlYXRlTGluZUJ1ZmZlcnMoIGdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0aW5pdExpbmVCdWZmZXJzKCBnZW9tZXRyeSwgb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjcmVhdGVQYXJ0aWNsZUJ1ZmZlcnMoIGdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0aW5pdFBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnksIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Ll9fd2ViZ2xBY3RpdmUgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRvYmplY3QuX193ZWJnbEFjdGl2ZSA9IHRydWU7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRhZGRCdWZmZXIoIF93ZWJnbE9iamVjdHMsIGdlb21ldHJ5LCBvYmplY3QgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5R3JvdXBzTGlzdCA9IGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLGwgPSBnZW9tZXRyeUdyb3Vwc0xpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0YWRkQnVmZmVyKCBfd2ViZ2xPYmplY3RzLCBnZW9tZXRyeUdyb3Vwc0xpc3RbIGkgXSwgb2JqZWN0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgKSB7XG5cblx0XHRcdFx0YWRkQnVmZmVyKCBfd2ViZ2xPYmplY3RzLCBnZW9tZXRyeSwgb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCB8fCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0YWRkQnVmZmVySW1tZWRpYXRlKCBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBHZW9tZXRyeSBzcGxpdHRpbmdcblxuXHR2YXIgZ2VvbWV0cnlHcm91cHMgPSB7fTtcblx0dmFyIGdlb21ldHJ5R3JvdXBDb3VudGVyID0gMDtcblxuXHRmdW5jdGlvbiBtYWtlR3JvdXBzKCBnZW9tZXRyeSwgdXNlc0ZhY2VNYXRlcmlhbCApIHtcblxuXHRcdHZhciBtYXhWZXJ0aWNlc0luR3JvdXAgPSBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgPyA0Mjk0OTY3Mjk2IDogNjU1MzU7XG5cblx0XHR2YXIgZ3JvdXBIYXNoLCBoYXNoX21hcCA9IHt9O1xuXG5cdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cdFx0dmFyIG51bU1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscy5sZW5ndGg7XG5cblx0XHR2YXIgZ3JvdXA7XG5cdFx0dmFyIGdyb3VwcyA9IHt9O1xuXHRcdHZhciBncm91cHNMaXN0ID0gW107XG5cblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcblx0XHRcdHZhciBtYXRlcmlhbEluZGV4ID0gdXNlc0ZhY2VNYXRlcmlhbCA/IGZhY2UubWF0ZXJpYWxJbmRleCA6IDA7XG5cblx0XHRcdGlmICggISAoIG1hdGVyaWFsSW5kZXggaW4gaGFzaF9tYXAgKSApIHtcblxuXHRcdFx0XHRoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdID0geyBoYXNoOiBtYXRlcmlhbEluZGV4LCBjb3VudGVyOiAwIH07XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5oYXNoICsgJ18nICsgaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyO1xuXG5cdFx0XHRpZiAoICEgKCBncm91cEhhc2ggaW4gZ3JvdXBzICkgKSB7XG5cblx0XHRcdFx0Z3JvdXAgPSB7XG5cdFx0XHRcdFx0aWQ6IGdlb21ldHJ5R3JvdXBDb3VudGVyICsrLFxuXHRcdFx0XHRcdGZhY2VzMzogW10sXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCxcblx0XHRcdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdFx0XHRudW1Nb3JwaFRhcmdldHM6IG51bU1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0XHRudW1Nb3JwaE5vcm1hbHM6IG51bU1vcnBoTm9ybWFsc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Z3JvdXBzWyBncm91cEhhc2ggXSA9IGdyb3VwO1xuXHRcdFx0XHRncm91cHNMaXN0LnB1c2goIGdyb3VwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBncm91cHNbIGdyb3VwSGFzaCBdLnZlcnRpY2VzICsgMyA+IG1heFZlcnRpY2VzSW5Hcm91cCApIHtcblxuXHRcdFx0XHRoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmNvdW50ZXIgKz0gMTtcblx0XHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5oYXNoICsgJ18nICsgaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyO1xuXG5cdFx0XHRcdGlmICggISAoIGdyb3VwSGFzaCBpbiBncm91cHMgKSApIHtcblxuXHRcdFx0XHRcdGdyb3VwID0ge1xuXHRcdFx0XHRcdFx0aWQ6IGdlb21ldHJ5R3JvdXBDb3VudGVyICsrLFxuXHRcdFx0XHRcdFx0ZmFjZXMzOiBbXSxcblx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXgsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdFx0XHRcdG51bU1vcnBoVGFyZ2V0czogbnVtTW9ycGhUYXJnZXRzLFxuXHRcdFx0XHRcdFx0bnVtTW9ycGhOb3JtYWxzOiBudW1Nb3JwaE5vcm1hbHNcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGdyb3Vwc1sgZ3JvdXBIYXNoIF0gPSBncm91cDtcblx0XHRcdFx0XHRncm91cHNMaXN0LnB1c2goIGdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdyb3Vwc1sgZ3JvdXBIYXNoIF0uZmFjZXMzLnB1c2goIGYgKTtcblx0XHRcdGdyb3Vwc1sgZ3JvdXBIYXNoIF0udmVydGljZXMgKz0gMztcblxuXHRcdH1cblxuXHRcdHJldHVybiBncm91cHNMaXN0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpbml0R2VvbWV0cnlHcm91cHMoIHNjZW5lLCBvYmplY3QsIGdlb21ldHJ5ICkge1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsLCBhZGRCdWZmZXJzID0gZmFsc2U7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdID09PSB1bmRlZmluZWQgfHwgZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0ZGVsZXRlIF93ZWJnbE9iamVjdHNbIG9iamVjdC5pZCBdO1xuXG5cdFx0XHRnZW9tZXRyeUdyb3Vwc1sgZ2VvbWV0cnkuaWQgXSA9IG1ha2VHcm91cHMoIGdlb21ldHJ5LCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKTtcblxuXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdlb21ldHJ5R3JvdXBzTGlzdCA9IGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0Ly8gY3JlYXRlIHNlcGFyYXRlIFZCT3MgcGVyIGdlb21ldHJ5IGNodW5rXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnlHcm91cHNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5R3JvdXBzTGlzdFsgaSBdO1xuXG5cdFx0XHQvLyBpbml0aWFsaXNlIFZCTyBvbiB0aGUgZmlyc3QgYWNjZXNzXG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y3JlYXRlTWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAgKTtcblx0XHRcdFx0aW5pdE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0YWRkQnVmZmVycyA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YWRkQnVmZmVycyA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYWRkQnVmZmVycyB8fCBvYmplY3QuX193ZWJnbEFjdGl2ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGFkZEJ1ZmZlciggX3dlYmdsT2JqZWN0cywgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdG9iamVjdC5fX3dlYmdsQWN0aXZlID0gdHJ1ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQnVmZmVyKCBvYmpsaXN0LCBidWZmZXIsIG9iamVjdCApIHtcblxuXHRcdHZhciBpZCA9IG9iamVjdC5pZDtcblx0XHRvYmpsaXN0W2lkXSA9IG9iamxpc3RbaWRdIHx8IFtdO1xuXHRcdG9iamxpc3RbaWRdLnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRtYXRlcmlhbDogbnVsbCxcblx0XHRcdFx0ejogMFxuXHRcdFx0fVxuXHRcdCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBhZGRCdWZmZXJJbW1lZGlhdGUoIG9iamxpc3QsIG9iamVjdCApIHtcblxuXHRcdG9iamxpc3QucHVzaChcblx0XHRcdHtcblx0XHRcdFx0aWQ6IG51bGwsXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRvcGFxdWU6IG51bGwsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiBudWxsLFxuXHRcdFx0XHR6OiAwXG5cdFx0XHR9XG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIE9iamVjdHMgdXBkYXRlc1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZU9iamVjdCggb2JqZWN0LCBzY2VuZSApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeSwgY3VzdG9tQXR0cmlidXRlc0RpcnR5LCBtYXRlcmlhbDtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0c2V0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdC8vIGNoZWNrIGFsbCBnZW9tZXRyeSBncm91cHNcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGluaXRHZW9tZXRyeUdyb3Vwcyggc2NlbmUsIG9iamVjdCwgZ2VvbWV0cnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZ2VvbWV0cnlHcm91cHNMaXN0ID0gZ2VvbWV0cnlHcm91cHNbIGdlb21ldHJ5LmlkIF07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeUdyb3Vwc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5R3JvdXAgPSBnZW9tZXRyeUdyb3Vwc0xpc3RbIGkgXTtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRpbml0TWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGVzRGlydHkgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGFyZUN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSB8fFxuXHRcdFx0XHRcdCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlIHx8XG5cdFx0XHRcdFx0IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRcdHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIF9nbC5EWU5BTUlDX0RSQVcsICEgZ2VvbWV0cnkuZHluYW1pYywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5ICk7XG5cblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRzZXRMaW5lQnVmZmVycyggZ2VvbWV0cnksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xuXG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkICkge1xuXG5cdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5ICk7XG5cblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IG9iamVjdC5zb3J0UGFydGljbGVzIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRzZXRQYXJ0aWNsZUJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIE9iamVjdHMgdXBkYXRlcyAtIGN1c3RvbSBhdHRyaWJ1dGVzIGNoZWNrXG5cblx0ZnVuY3Rpb24gYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApIHtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlc1sgbmFtZSBdLm5lZWRzVXBkYXRlICkgcmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyQ3VzdG9tQXR0cmlidXRlcyggbWF0ZXJpYWwgKSB7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRtYXRlcmlhbC5hdHRyaWJ1dGVzWyBuYW1lIF0ubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gT2JqZWN0cyByZW1vdmFsXG5cblx0ZnVuY3Rpb24gcmVtb3ZlT2JqZWN0KCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggIHx8XG5cdFx0XHQgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCB8fFxuXHRcdFx0IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdGRlbGV0ZSBfd2ViZ2xPYmplY3RzWyBvYmplY3QuaWQgXTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCB8fCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XG5cblx0XHRcdHJlbW92ZUluc3RhbmNlcyggX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRkZWxldGUgb2JqZWN0Ll9fd2ViZ2xJbml0O1xuXHRcdGRlbGV0ZSBvYmplY3QuX21vZGVsVmlld01hdHJpeDtcblx0XHRkZWxldGUgb2JqZWN0Ll9ub3JtYWxNYXRyaXg7XG5cblx0XHRkZWxldGUgb2JqZWN0Ll9fd2ViZ2xBY3RpdmU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZUluc3RhbmNlcyggb2JqbGlzdCwgb2JqZWN0ICkge1xuXG5cdFx0Zm9yICggdmFyIG8gPSBvYmpsaXN0Lmxlbmd0aCAtIDE7IG8gPj0gMDsgbyAtLSApIHtcblxuXHRcdFx0aWYgKCBvYmpsaXN0WyBvIF0ub2JqZWN0ID09PSBvYmplY3QgKSB7XG5cblx0XHRcdFx0b2JqbGlzdC5zcGxpY2UoIG8sIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBNYXRlcmlhbHNcblxuXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xuXG5cdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0dmFyIHNoYWRlcklEO1xuXG5cdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdkZXB0aCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnbm9ybWFsJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHNoYWRlcklEID0gJ2Jhc2ljJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnbGFtYmVydCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdwaG9uZyc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdiYXNpYyc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnZGFzaGVkJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdwYXJ0aWNsZV9iYXNpYyc7XG5cblx0XHR9XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHR2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBzaGFkZXJJRCBdO1xuXG5cdFx0XHRtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0ge1xuXHRcdFx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IHtcblx0XHRcdFx0dW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxuXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cblx0XHR2YXIgbWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcblx0XHR2YXIgbWF4U2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XG5cdFx0dmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHtcblxuXHRcdFx0cHJlY2lzaW9uOiBfcHJlY2lzaW9uLFxuXHRcdFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMsXG5cblx0XHRcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxuXHRcdFx0ZW52TWFwOiAhISBtYXRlcmlhbC5lbnZNYXAsXG5cdFx0XHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuXHRcdFx0bm9ybWFsTWFwOiAhISBtYXRlcmlhbC5ub3JtYWxNYXAsXG5cdFx0XHRzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG5cdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXG5cblx0XHRcdHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXG5cdFx0XHRmb2c6IGZvZyxcblx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuXHRcdFx0Zm9nRXhwOiBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLFxuXG5cdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcblx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IF9sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG5cdFx0XHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXG5cdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXG5cdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBfc3VwcG9ydHNCb25lVGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcblxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXG5cdFx0XHRtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcblx0XHRcdG1heE1vcnBoVGFyZ2V0czogX3RoaXMubWF4TW9ycGhUYXJnZXRzLFxuXHRcdFx0bWF4TW9ycGhOb3JtYWxzOiBfdGhpcy5tYXhNb3JwaE5vcm1hbHMsXG5cblx0XHRcdG1heERpckxpZ2h0czogbWF4TGlnaHRDb3VudC5kaXJlY3Rpb25hbCxcblx0XHRcdG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxuXHRcdFx0bWF4U3BvdExpZ2h0czogbWF4TGlnaHRDb3VudC5zcG90LFxuXHRcdFx0bWF4SGVtaUxpZ2h0czogbWF4TGlnaHRDb3VudC5oZW1pLFxuXG5cdFx0XHRtYXhTaGFkb3dzOiBtYXhTaGFkb3dzLFxuXHRcdFx0c2hhZG93TWFwRW5hYmxlZDogX3RoaXMuc2hhZG93TWFwRW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBtYXhTaGFkb3dzID4gMCxcblx0XHRcdHNoYWRvd01hcFR5cGU6IF90aGlzLnNoYWRvd01hcFR5cGUsXG5cdFx0XHRzaGFkb3dNYXBEZWJ1ZzogX3RoaXMuc2hhZG93TWFwRGVidWcsXG5cdFx0XHRzaGFkb3dNYXBDYXNjYWRlOiBfdGhpcy5zaGFkb3dNYXBDYXNjYWRlLFxuXG5cdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcblx0XHRcdG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcblx0XHRcdHdyYXBBcm91bmQ6IG1hdGVyaWFsLndyYXBBcm91bmQsXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcblx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcblxuXHRcdH07XG5cblx0XHQvLyBHZW5lcmF0ZSBjb2RlXG5cblx0XHR2YXIgY2h1bmtzID0gW107XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHRjaHVua3MucHVzaCggc2hhZGVySUQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNodW5rcy5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xuXHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XG5cblx0XHRcdFx0Y2h1bmtzLnB1c2goIG5hbWUgKTtcblx0XHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRjaHVua3MucHVzaCggbmFtZSApO1xuXHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIG5hbWUgXSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGNvZGUgPSBjaHVua3Muam9pbigpO1xuXG5cdFx0dmFyIHByb2dyYW07XG5cblx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcblxuXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRcdHZhciBwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgcCBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuXHRcdFx0XHRwcm9ncmFtLnVzZWRUaW1lcyArKztcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW0gPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtKCBfdGhpcywgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblx0XHRcdF9wcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zID0gX3Byb2dyYW1zLmxlbmd0aDtcblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuXHRcdFx0dmFyIGlkLCBiYXNlID0gJ21vcnBoVGFyZ2V0JztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRcdGlkID0gYmFzZSArIGk7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBpZCBdID49IDAgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcblxuXHRcdFx0dmFyIGlkLCBiYXNlID0gJ21vcnBoTm9ybWFsJztcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0aWQgPSBiYXNlICsgaTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGlkIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsLnVuaWZvcm1zTGlzdCA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIHUgaW4gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci51bmlmb3JtcyApIHtcblxuXHRcdFx0dmFyIGxvY2F0aW9uID0gbWF0ZXJpYWwucHJvZ3JhbS51bmlmb3Jtc1sgdSBdO1xuXG5cdFx0XHRpZiAoIGxvY2F0aW9uICkge1xuXHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zWyB1IF0sIGxvY2F0aW9uIF0gKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcblxuXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwucHJvZ3JhbSApIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0aW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRpZiAoICEgb2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBfdGhpcy5tYXhNb3JwaFRhcmdldHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW0sXG5cdFx0XHRwX3VuaWZvcm1zID0gcHJvZ3JhbS51bmlmb3Jtcyxcblx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuXG5cdFx0aWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XG5cblx0XHRcdF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW0uaWQ7XG5cblx0XHRcdHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcblx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuXHRcdFx0aWYgKCBfY3VycmVudE1hdGVyaWFsSWQgPT09IC0xICkgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblxuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRcdGlmICggX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXHRcdFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2Vcblx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UgJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcblxuXHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuXHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0ZvZyggbV91bmlmb3JtcywgZm9nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuXHRcdFx0XHRpZiAoIF9saWdodHNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cdFx0XHRcdFx0c2V0dXBMaWdodHMoIGxpZ2h0cyApO1xuXHRcdFx0XHRcdF9saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHJlZnJlc2hMaWdodHMgKSB7XG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG5cdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHRydWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgZmFsc2UgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcblx0XHRcdFx0bV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICEgbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xuXG5cdFx0XHRsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbC51bmlmb3Jtc0xpc3QgKTtcblxuXHRcdH1cblxuXHRcdGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcblxuXHRcdGlmICggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCAhPT0gbnVsbCApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH1cblxuXHQvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0Ly8gIDEuIGNvbG9yIG1hcFxuXHRcdC8vICAyLiBzcGVjdWxhciBtYXBcblx0XHQvLyAgMy4gbm9ybWFsIG1hcFxuXHRcdC8vICA0LiBidW1wIG1hcFxuXHRcdC8vICA1LiBhbHBoYSBtYXBcblxuXHRcdHZhciB1dlNjYWxlTWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcblx0XHRcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcblxuXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuXHRcdH1cblxuXHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcblx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtIDE7XG5cblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdC8vdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5ICogbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXHRcdHVuaWZvcm1zLmNvbWJpbmUudmFsdWUgPSBtYXRlcmlhbC5jb21iaW5lO1xuXHRcdHVuaWZvcm1zLnVzZVJlZnJhY3QudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2ggKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2cgKCB1bmlmb3JtcywgZm9nICkge1xuXG5cdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XG5cblx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuXHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuXHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblxuXHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGluaW5lc3M7XG5cblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmFtYmllbnQgKTtcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLnNwZWN1bGFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlID0gbWF0ZXJpYWwuYW1iaWVudDtcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC53cmFwQXJvdW5kICkge1xuXG5cdFx0XHR1bmlmb3Jtcy53cmFwUkdCLnZhbHVlLmNvcHkoIG1hdGVyaWFsLndyYXBSR0IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuYW1iaWVudCApO1xuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmVtaXNzaXZlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlID0gbWF0ZXJpYWwuYW1iaWVudDtcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLndyYXBBcm91bmQgKSB7XG5cblx0XHRcdHVuaWZvcm1zLndyYXBSR0IudmFsdWUuY29weSggbWF0ZXJpYWwud3JhcFJHQiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaWdodHMgKCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG5cdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuYW1iaWVudDtcblxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnM7XG5cblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5wb2ludC5wb3NpdGlvbnM7XG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnBvaW50LmRpc3RhbmNlcztcblxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnNwb3QuY29sb3JzO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlzdGFuY2VzO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpcmVjdGlvbnM7XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQudmFsdWUgPSBsaWdodHMuc3BvdC5leHBvbmVudHM7XG5cblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycztcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuaGVtaS5wb3NpdGlvbnM7XG5cblx0fVxuXG5cdC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuXHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSAoIHVuaWZvcm1zLCBib29sZWFuICkge1xuXG5cdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IGJvb2xlYW47XG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IGJvb2xlYW47XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IGJvb2xlYW47XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG5cdFx0aWYgKCB1bmlmb3Jtcy5zaGFkb3dNYXRyaXggKSB7XG5cblx0XHRcdHZhciBqID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgfHwgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXAudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hcDtcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXBTaXplO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWF0cml4LnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXRyaXg7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93RGFya25lc3M7XG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93QmlhcztcblxuXHRcdFx0XHRcdGogKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcblxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XG5cblx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xuXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9ub3JtYWxNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4dHVyZVVuaXQoKSB7XG5cblx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcblxuXHRcdGlmICggdGV4dHVyZVVuaXQgPj0gX21heFRleHR1cmVzICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0cnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBfbWF4VGV4dHVyZXMgKTtcblxuXHRcdH1cblxuXHRcdF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XG5cblx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMgKCB1bmlmb3JtcyApIHtcblxuXHRcdHZhciB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgb2Zmc2V0O1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcblxuXHRcdFx0Ly8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cblx0XHRcdGlmICggdW5pZm9ybS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XG5cdFx0XHR2YXIgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0dmFyIGxvY2F0aW9uID0gdW5pZm9ybXNbIGogXVsgMSBdO1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJzFpJzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICcxZic6XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMmYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2YnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnNGYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdLCB2YWx1ZVsgMyBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMWl2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2l2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMWZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMmZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2Z2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnNGZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTWF0cml4M2Z2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDRmdic6XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdGNhc2UgJ2knOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGludGVnZXJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2YnOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGZsb2F0XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2Mic6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yMlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2Myc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2NCc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56LCB2YWx1ZS53ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjJzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5Db2xvclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS5yLCB2YWx1ZS5nLCB2YWx1ZS5iICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpdjEnOlxuXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaXYnOlxuXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2Z2MSc6XG5cblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZnYnOlxuXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBmbG9hdHMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2MnYnOlxuXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yMlxuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDIgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDI7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgXSAgID0gdmFsdWVbIGkgXS54O1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Yzdic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBpICogMztcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZVsgaSBdLng7XG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Y0dic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3I0XG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBpICogNDtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZVsgaSBdLng7XG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAzIF0gPSB2YWx1ZVsgaSBdLnc7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtMyc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4M1xuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtM3YnOlxuXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuTWF0cml4M1xuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiA5ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbTQnOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLk1hdHJpeDRcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbTR2JzpcblxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDRcblxuXHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndCc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcblxuXHRcdFx0XHRcdHRleHR1cmUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdGlmICggISB0ZXh0dXJlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5DdWJlVGV4dHVyZSB8fFxuXHRcdFx0XHRcdCAgICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7IC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cblx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuXHRcdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3R2JzpcblxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkKVxuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpIF0gPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSB1bmlmb3JtLnZhbHVlWyBpIF07XG5cdFx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IHVuaWZvcm0uX2FycmF5WyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggISB0ZXh0dXJlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB0eXBlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBNYXRyaWNlcyAoIG9iamVjdCwgY2FtZXJhICkge1xuXG5cdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0b2JqZWN0Ll9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QuX21vZGVsVmlld01hdHJpeCApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNldENvbG9yR2FtbWEoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHlTcSApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yICogY29sb3IuciAqIGludGVuc2l0eVNxO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogY29sb3IuZyAqIGludGVuc2l0eVNxO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogY29sb3IuYiAqIGludGVuc2l0eVNxO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDb2xvckxpbmVhciggYXJyYXksIG9mZnNldCwgY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yICogaW50ZW5zaXR5O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogaW50ZW5zaXR5O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogaW50ZW5zaXR5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyAoIGxpZ2h0cyApIHtcblxuXHRcdHZhciBsLCBsbCwgbGlnaHQsIG4sXG5cdFx0ciA9IDAsIGcgPSAwLCBiID0gMCxcblx0XHRjb2xvciwgc2t5Q29sb3IsIGdyb3VuZENvbG9yLFxuXHRcdGludGVuc2l0eSwgIGludGVuc2l0eVNxLFxuXHRcdHBvc2l0aW9uLFxuXHRcdGRpc3RhbmNlLFxuXG5cdFx0emxpZ2h0cyA9IF9saWdodHMsXG5cblx0XHRkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcblx0XHRkaXJQb3NpdGlvbnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxcblxuXHRcdHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXG5cdFx0cG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcblx0XHRwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxuXG5cdFx0c3BvdENvbG9ycyA9IHpsaWdodHMuc3BvdC5jb2xvcnMsXG5cdFx0c3BvdFBvc2l0aW9ucyA9IHpsaWdodHMuc3BvdC5wb3NpdGlvbnMsXG5cdFx0c3BvdERpc3RhbmNlcyA9IHpsaWdodHMuc3BvdC5kaXN0YW5jZXMsXG5cdFx0c3BvdERpcmVjdGlvbnMgPSB6bGlnaHRzLnNwb3QuZGlyZWN0aW9ucyxcblx0XHRzcG90QW5nbGVzQ29zID0gemxpZ2h0cy5zcG90LmFuZ2xlc0Nvcyxcblx0XHRzcG90RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmV4cG9uZW50cyxcblxuXHRcdGhlbWlTa3lDb2xvcnMgPSB6bGlnaHRzLmhlbWkuc2t5Q29sb3JzLFxuXHRcdGhlbWlHcm91bmRDb2xvcnMgPSB6bGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzLFxuXHRcdGhlbWlQb3NpdGlvbnMgPSB6bGlnaHRzLmhlbWkucG9zaXRpb25zLFxuXG5cdFx0ZGlyTGVuZ3RoID0gMCxcblx0XHRwb2ludExlbmd0aCA9IDAsXG5cdFx0c3BvdExlbmd0aCA9IDAsXG5cdFx0aGVtaUxlbmd0aCA9IDAsXG5cblx0XHRkaXJDb3VudCA9IDAsXG5cdFx0cG9pbnRDb3VudCA9IDAsXG5cdFx0c3BvdENvdW50ID0gMCxcblx0XHRoZW1pQ291bnQgPSAwLFxuXG5cdFx0ZGlyT2Zmc2V0ID0gMCxcblx0XHRwb2ludE9mZnNldCA9IDAsXG5cdFx0c3BvdE9mZnNldCA9IDAsXG5cdFx0aGVtaU9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cblx0XHRcdGlmICggbGlnaHQub25seVNoYWRvdyApIGNvbnRpbnVlO1xuXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0aW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuXHRcdFx0ZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0XHRcdHIgKz0gY29sb3IuciAqIGNvbG9yLnI7XG5cdFx0XHRcdFx0ZyArPSBjb2xvci5nICogY29sb3IuZztcblx0XHRcdFx0XHRiICs9IGNvbG9yLmIgKiBjb2xvci5iO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyICs9IGNvbG9yLnI7XG5cdFx0XHRcdFx0ZyArPSBjb2xvci5nO1xuXHRcdFx0XHRcdGIgKz0gY29sb3IuYjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRkaXJDb3VudCArPSAxO1xuXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuXHRcdFx0XHRfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGRpck9mZnNldCA9IGRpckxlbmd0aCAqIDM7XG5cblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XG5cdFx0XHRcdGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSAqIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggZGlyQ29sb3JzLCBkaXJPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlyTGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRwb2ludENvdW50ICs9IDE7XG5cblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRwb2ludE9mZnNldCA9IHBvaW50TGVuZ3RoICogMztcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBwb2ludENvbG9ycywgcG9pbnRPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0IF0gICAgID0gX3ZlY3RvcjMueDtcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcblxuXHRcdFx0XHRwb2ludERpc3RhbmNlc1sgcG9pbnRMZW5ndGggXSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdHBvaW50TGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xuXG5cdFx0XHRcdHNwb3RDb3VudCArPSAxO1xuXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0c3BvdE9mZnNldCA9IHNwb3RMZW5ndGggKiAzO1xuXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuXHRcdFx0XHRzcG90RGlzdGFuY2VzWyBzcG90TGVuZ3RoIF0gPSBkaXN0YW5jZTtcblxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcblx0XHRcdFx0X2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcblx0XHRcdFx0c3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG5cdFx0XHRcdHNwb3RBbmdsZXNDb3NbIHNwb3RMZW5ndGggXSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xuXHRcdFx0XHRzcG90RXhwb25lbnRzWyBzcG90TGVuZ3RoIF0gPSBsaWdodC5leHBvbmVudDtcblxuXHRcdFx0XHRzcG90TGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG5cdFx0XHRcdGhlbWlDb3VudCArPSAxO1xuXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0aGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xuXG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cblx0XHRcdFx0c2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcblx0XHRcdFx0Z3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvcjtcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRpbnRlbnNpdHlTcSA9IGludGVuc2l0eSAqIGludGVuc2l0eTtcblxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGhlbWlTa3lDb2xvcnMsIGhlbWlPZmZzZXQsIHNreUNvbG9yLCBpbnRlbnNpdHlTcSApO1xuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGhlbWlHcm91bmRDb2xvcnMsIGhlbWlPZmZzZXQsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHlTcSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhlbWlMZW5ndGggKz0gMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbnVsbCBldmVudHVhbCByZW1haW5zIGZyb20gcmVtb3ZlZCBsaWdodHNcblx0XHQvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXG5cblx0XHRmb3IgKCBsID0gZGlyTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggZGlyQ29sb3JzLmxlbmd0aCwgZGlyQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGRpckNvbG9yc1sgbCBdID0gMC4wO1xuXHRcdGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlTa3lDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlTa3lDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcblxuXHRcdHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xuXHRcdHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0emxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG5cdFx0emxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cblx0XHR6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG5cdFx0emxpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuXHRcdHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuXHR9XG5cblx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xuXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cblx0XHRpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XG5cblx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcblxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldE1hdGVyaWFsRmFjZXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG5cdFx0dmFyIGRvdWJsZVNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZTtcblx0XHR2YXIgZmxpcFNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGU7XG5cblx0XHRpZiAoIF9vbGREb3VibGVTaWRlZCAhPT0gZG91YmxlU2lkZWQgKSB7XG5cblx0XHRcdGlmICggZG91YmxlU2lkZWQgKSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZERvdWJsZVNpZGVkID0gZG91YmxlU2lkZWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9vbGRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuXHRcdFx0aWYgKCBmbGlwU2lkZWQgKSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vbGRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xuXG5cdFx0aWYgKCBfb2xkRGVwdGhUZXN0ICE9PSBkZXB0aFRlc3QgKSB7XG5cblx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZERlcHRoVGVzdCA9IGRlcHRoVGVzdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcblxuXHRcdGlmICggX29sZERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XG5cblx0XHRcdF9nbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldExpbmVXaWR0aCAoIHdpZHRoICkge1xuXG5cdFx0aWYgKCB3aWR0aCAhPT0gX29sZExpbmVXaWR0aCApIHtcblxuXHRcdFx0X2dsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuXHRcdFx0X29sZExpbmVXaWR0aCA9IHdpZHRoO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0ICggcG9seWdvbm9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuXHRcdGlmICggX29sZFBvbHlnb25PZmZzZXQgIT09IHBvbHlnb25vZmZzZXQgKSB7XG5cblx0XHRcdGlmICggcG9seWdvbm9mZnNldCApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vbGRQb2x5Z29uT2Zmc2V0ID0gcG9seWdvbm9mZnNldDtcblxuXHRcdH1cblxuXHRcdGlmICggcG9seWdvbm9mZnNldCAmJiAoIF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgX29sZFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSApIHtcblxuXHRcdFx0X2dsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcblxuXHRcdFx0X29sZFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRfb2xkUG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuc2V0QmxlbmRpbmcgPSBmdW5jdGlvbiAoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QgKSB7XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBfb2xkQmxlbmRpbmcgKSB7XG5cblx0XHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk5vQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nICkge1xuXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuWkVSTywgX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0Ly8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5aRVJPLCBfZ2wuU1JDX0NPTE9SICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggX2dsLkZVTkNfQURELCBfZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRnVuY1NlcGFyYXRlKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgX2dsLk9ORSwgX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfb2xkQmxlbmRpbmcgPSBibGVuZGluZztcblxuXHRcdH1cblxuXHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG5cdFx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IF9vbGRCbGVuZEVxdWF0aW9uICkge1xuXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApICk7XG5cblx0XHRcdFx0X29sZEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYmxlbmRTcmMgIT09IF9vbGRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gX29sZEJsZW5kRHN0ICkge1xuXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSApO1xuXG5cdFx0XHRcdF9vbGRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuXHRcdFx0XHRfb2xkQmxlbmREc3QgPSBibGVuZERzdDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X29sZEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHRcdFx0X29sZEJsZW5kU3JjID0gbnVsbDtcblx0XHRcdF9vbGRCbGVuZERzdCA9IG51bGw7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBUZXh0dXJlc1xuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG5cdFx0dmFyIGV4dGVuc2lvbjtcblxuXHRcdGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHR9XG5cblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uICYmIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuRmxvYXRUeXBlICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgdGV4dHVyZS5fX29sZEFuaXNvdHJvcHkgKSB7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF90aGlzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG5cdFx0XHRcdHRleHR1cmUuX19vbGRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMudXBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZS5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdFx0dGV4dHVyZS5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0fVxuXG5cdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblxuXHRcdHRleHR1cmUuaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgX21heFRleHR1cmVTaXplICk7XG5cblx0XHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlLFxuXHRcdGlzSW1hZ2VQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApLFxuXHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG5cdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xuXG5cdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xuXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRcIiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgeyAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSgpO1xuXG5cdH07XG5cblx0dGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0X3RoaXMudXBsb2FkVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUgKCBpbWFnZSwgbWF4U2l6ZSApIHtcblxuXHRcdGlmICggaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUgKSB7XG5cblx0XHRcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXG5cdFx0XHQvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxuXG5cdFx0XHR2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0XHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogc2NhbGUgKTtcblxuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIGltYWdlLCAnaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQgKyAnLicgKTtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmUgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdGlmICggISB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cblx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcblx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcblxuXHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIF9tYXhDdWJlbWFwU2l6ZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcblx0XHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXG5cdFx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGogXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdFwiICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyAoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuXHR9XG5cblx0Ly8gUmVuZGVyIHRhcmdldHNcblxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcblxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlVGFyZ2V0LCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUsIDAgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXIgKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCAgKSB7XG5cblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHQvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cblx0XHR9IGVsc2UgaWYgKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLlNURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cdFx0Ki9cblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0XHQvLyBTZXR1cCB0ZXh0dXJlLCBjcmVhdGUgcmVuZGVyIGFuZCBmcmFtZSBidWZmZXJzXG5cblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKSxcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLFxuXHRcdFx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnR5cGUgKTtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVsZWFzZSBldmVyeXRoaW5nXG5cblx0XHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0d2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXG5cdFx0XHR2eCA9IDA7XG5cdFx0XHR2eSA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmcmFtZWJ1ZmZlciA9IG51bGw7XG5cblx0XHRcdHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XG5cdFx0XHRoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdHZ4ID0gX3ZpZXdwb3J0WDtcblx0XHRcdHZ5ID0gX3ZpZXdwb3J0WTtcblxuXHRcdH1cblxuXHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRcdF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdF9jdXJyZW50V2lkdGggPSB3aWR0aDtcblx0XHRfY3VycmVudEhlaWdodCA9IGhlaWdodDtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcblxuXHRcdGlmICggZiA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblxuXHR9XG5cblx0Ly8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcblxuXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5TdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1NVQlRSQUNUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcblxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuXHRcdH1cblxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cblx0fVxuXG5cdC8vIEFsbG9jYXRpb25zXG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcblxuXHRcdGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdHJldHVybiAxMDI0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlclxuXHRcdFx0Ly8gICB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXG5cdFx0XHQvL1xuXHRcdFx0Ly8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcblx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuXHRcdFx0Ly8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxuXG5cdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XG5cdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXhCb25lcztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApIHtcblxuXHRcdHZhciBkaXJMaWdodHMgPSAwO1xuXHRcdHZhciBwb2ludExpZ2h0cyA9IDA7XG5cdFx0dmFyIHNwb3RMaWdodHMgPSAwO1xuXHRcdHZhciBoZW1pTGlnaHRzID0gMDtcblxuXHRcdGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG5cdFx0XHRpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgfHwgbGlnaHQudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMgKys7XG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzICsrO1xuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHNwb3RMaWdodHMgKys7XG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cyArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiB7ICdkaXJlY3Rpb25hbCc6IGRpckxpZ2h0cywgJ3BvaW50JzogcG9pbnRMaWdodHMsICdzcG90Jzogc3BvdExpZ2h0cywgJ2hlbWknOiBoZW1pTGlnaHRzIH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICkge1xuXG5cdFx0dmFyIG1heFNoYWRvd3MgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuXHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cblx0XHRcdGlmICggISBsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBtYXhTaGFkb3dzICsrO1xuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgbWF4U2hhZG93cyArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXhTaGFkb3dzO1xuXG5cdH1cblxuXHQvLyBERVBSRUNBVEVEXG5cdFxuXHR0aGlzLmluaXRNYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9O1xuXG5cdHRoaXMuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH07XG5cblx0dGhpcy5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlU2hhZG93TWFwID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cblx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHR0aGlzLndyYXBTID0gb3B0aW9ucy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdHRoaXMud3JhcFQgPSBvcHRpb25zLndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHR0aGlzLm1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0dGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0dGhpcy5hbmlzb3Ryb3B5ID0gb3B0aW9ucy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaXNvdHJvcHkgOiAxO1xuXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG5cdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcblx0dGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcblx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuXHR0aGlzLnNoYXJlRGVwdGhGcm9tID0gbnVsbDtcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxcblxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRtcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQgKTtcblxuXHRcdHRtcC53cmFwUyA9IHRoaXMud3JhcFM7XG5cdFx0dG1wLndyYXBUID0gdGhpcy53cmFwVDtcblxuXHRcdHRtcC5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcblx0XHR0bXAubWluRmlsdGVyID0gdGhpcy5taW5GaWx0ZXI7XG5cblx0XHR0bXAuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcblxuXHRcdHRtcC5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcblx0XHR0bXAucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cblx0XHR0bXAuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG5cdFx0dG1wLnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHR0bXAuZGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoQnVmZmVyO1xuXHRcdHRtcC5zdGVuY2lsQnVmZmVyID0gdGhpcy5zdGVuY2lsQnVmZmVyO1xuXG5cdFx0dG1wLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0dG1wLnNoYXJlRGVwdGhGcm9tID0gdGhpcy5zaGFyZURlcHRoRnJvbTtcblxuXHRcdHJldHVybiB0bXA7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXRDdWJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuXHRUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cblx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzXG5cblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XG5cblx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuXHR0aGlzLmdldCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XG5cblx0XHR9XG5cblx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0c3dpdGNoICggbmFtZSApIHtcblx0XHRcblx0XHRcdGNhc2UgJ09FU190ZXh0dXJlX2Zsb2F0Jzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPRVNfZWxlbWVudF9pbmRleF91aW50Jzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0VYVF9ibGVuZF9taW5tYXgnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnRVhUX2ZyYWdfZGVwdGgnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfZnJhZ19kZXB0aCcgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtLmpzXG5cblRIUkVFLldlYkdMUHJvZ3JhbSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBwcm9ncmFtSWRDb3VudCA9IDA7XG5cblx0dmFyIGdlbmVyYXRlRGVmaW5lcyA9IGZ1bmN0aW9uICggZGVmaW5lcyApIHtcblxuXHRcdHZhciB2YWx1ZSwgY2h1bmssIGNodW5rcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGQgaW4gZGVmaW5lcyApIHtcblxuXHRcdFx0dmFsdWUgPSBkZWZpbmVzWyBkIF07XG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRjaHVuayA9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIHZhbHVlO1xuXHRcdFx0Y2h1bmtzLnB1c2goIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2h1bmtzLmpvaW4oIFwiXFxuXCIgKTtcblxuXHR9O1xuXG5cdHZhciBjYWNoZVVuaWZvcm1Mb2NhdGlvbnMgPSBmdW5jdGlvbiAoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuXHRcdHZhciB1bmlmb3JtcyA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaWRlbnRpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGlkID0gaWRlbnRpZmllcnNbIGkgXTtcblx0XHRcdHVuaWZvcm1zWyBpZCBdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBpZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuaWZvcm1zO1xuXG5cdH07XG5cblx0dmFyIGNhY2hlQXR0cmlidXRlTG9jYXRpb25zID0gZnVuY3Rpb24gKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaWRlbnRpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGlkID0gaWRlbnRpZmllcnNbIGkgXTtcblx0XHRcdGF0dHJpYnV0ZXNbIGlkIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgaWQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzO1xuXG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0dmFyIF90aGlzID0gcmVuZGVyZXI7XG5cdFx0dmFyIF9nbCA9IF90aGlzLmNvbnRleHQ7XG5cblx0XHR2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XG5cdFx0dmFyIHVuaWZvcm1zID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci51bmlmb3Jtcztcblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuXHRcdHZhciBpbmRleDBBdHRyaWJ1dGVOYW1lID0gbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZTtcblxuXHRcdGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSA9PT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblxuXHRcdFx0aW5kZXgwQXR0cmlidXRlTmFtZSA9ICdwb3NpdGlvbic7XG5cblx0XHR9XG5cblx0XHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9IFwiU0hBRE9XTUFQX1RZUEVfQkFTSUNcIjtcblxuXHRcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XG5cblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSBcIlNIQURPV01BUF9UWVBFX1BDRlwiO1xuXG5cdFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVFwiO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS5sb2coIFwiYnVpbGRpbmcgbmV3IHByb2dyYW0gXCIgKTtcblxuXHRcdC8vXG5cblx0XHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBwcm9ncmFtID0gX2dsLmNyZWF0ZVByb2dyYW0oKTtcblxuXHRcdHZhciBwcmVmaXhfdmVydGV4LCBwcmVmaXhfZnJhZ21lbnQ7XG5cblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHByZWZpeF92ZXJ0ZXggPSAnJztcblx0XHRcdHByZWZpeF9mcmFnbWVudCA9ICcnO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cHJlZml4X3ZlcnRleCA9IFtcblxuXHRcdFx0XHRcInByZWNpc2lvbiBcIiArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIsXG5cdFx0XHRcdFwicHJlY2lzaW9uIFwiICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyBcIiBpbnQ7XCIsXG5cblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyBcIiNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTXCIgOiBcIlwiLFxuXG5cdFx0XHRcdF90aGlzLmdhbW1hSW5wdXQgPyBcIiNkZWZpbmUgR0FNTUFfSU5QVVRcIiA6IFwiXCIsXG5cdFx0XHRcdF90aGlzLmdhbW1hT3V0cHV0ID8gXCIjZGVmaW5lIEdBTU1BX09VVFBVVFwiIDogXCJcIixcblxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcblx0XHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG5cdFx0XHRcdFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIiArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0JPTkVTIFwiICsgcGFyYW1ldGVycy5tYXhCb25lcyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/IFwiI2RlZmluZSBVU0VfQUxQSEFNQVBcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNraW5uaW5nID8gXCIjZGVmaW5lIFVTRV9TS0lOTklOR1wiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gXCIjZGVmaW5lIEJPTkVfVEVYVFVSRVwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/IFwiI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyA/IFwiI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgXCIgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/IFwiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/IFwiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/IFwiI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OXCIgOiBcIlwiLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/IFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZcIiA6IFwiXCIsXG5cdFx0XHRcdC8vX3RoaXMuX2dsRXh0ZW5zaW9uRnJhZ0RlcHRoID8gXCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFRcIiA6IFwiXCIsXG5cblxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2MjtcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcblxuXHRcdFx0XHRcIlx0YXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXG5cblx0XHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXG5cblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDtcIixcblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTtcIixcblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjtcIixcblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MztcIixcblxuXHRcdFx0XHRcIlx0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcblxuXHRcdFx0XHRcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7XCIsXG5cdFx0XHRcdFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTtcIixcblx0XHRcdFx0XCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyO1wiLFxuXHRcdFx0XHRcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7XCIsXG5cblx0XHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFx0XCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0O1wiLFxuXHRcdFx0XHRcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7XCIsXG5cdFx0XHRcdFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIixcblx0XHRcdFx0XCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3O1wiLFxuXG5cdFx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxuXG5cdFx0XHRcdFwiXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XCIsXG5cdFx0XHRcdFwiXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0O1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJcIlxuXG5cdFx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRcdHByZWZpeF9mcmFnbWVudCA9IFtcblxuXHRcdFx0XHRcInByZWNpc2lvbiBcIiArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIsXG5cdFx0XHRcdFwicHJlY2lzaW9uIFwiICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyBcIiBpbnQ7XCIsXG5cblx0XHRcdFx0KCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgKSA/IFwiI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcIiA6IFwiXCIsXG5cblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcblx0XHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG5cdFx0XHRcdFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIiArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhVGVzdCA/IFwiI2RlZmluZSBBTFBIQVRFU1QgXCIgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdDogXCJcIixcblxuXHRcdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxuXHRcdFx0XHRfdGhpcy5nYW1tYU91dHB1dCA/IFwiI2RlZmluZSBHQU1NQV9PVVRQVVRcIiA6IFwiXCIsXG5cblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gXCIjZGVmaW5lIFVTRV9GT0dcIiA6IFwiXCIsXG5cdFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/IFwiI2RlZmluZSBGT0dfRVhQMlwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/IFwiI2RlZmluZSBVU0VfQUxQSEFNQVBcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1ldGFsID8gXCIjZGVmaW5lIE1FVEFMXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgXCIgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/IFwiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/IFwiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyBcIiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGXCIgOiBcIlwiLFxuXHRcdFx0XHQvL190aGlzLl9nbEV4dGVuc2lvbkZyYWdEZXB0aCA/IFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUXCIgOiBcIlwiLFxuXG5cdFx0XHRcdFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcIlwiXG5cblx0XHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdHZhciBnbFZlcnRleFNoYWRlciA9IG5ldyBUSFJFRS5XZWJHTFNoYWRlciggX2dsLCBfZ2wuVkVSVEVYX1NIQURFUiwgcHJlZml4X3ZlcnRleCArIHZlcnRleFNoYWRlciApO1xuXHRcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gbmV3IFRIUkVFLldlYkdMU2hhZGVyKCBfZ2wsIF9nbC5GUkFHTUVOVF9TSEFERVIsIHByZWZpeF9mcmFnbWVudCArIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cdFx0XHQvLyBiZWNhdXNlIHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBlbXVsYXRpb24gaXMgZG9uZSBieSBicm93c2VyIGlmIGF0dHJpYnV0ZSAwIGlzIGRpc2FibGVkLlxuXHRcdFx0Ly8gQW5kLCBjb2xvciwgZm9yIGV4YW1wbGUgaXMgb2Z0ZW4gYXV0b21hdGljYWxseSBib3VuZCB0byBpbmRleCAwIHNvIGRpc2FibGluZyBpdFxuXG5cdFx0XHRfZ2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBpbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cblx0XHR9XG5cblx0XHRfZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdGlmICggX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIF9nbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQ291bGQgbm90IGluaXRpYWxpc2Ugc2hhZGVyLicgKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdnbC5WQUxJREFURV9TVEFUVVMnLCBfZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgX2dsLlZBTElEQVRFX1NUQVRVUyApICk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnZ2wuZ2V0RXJyb3IoKScsIF9nbC5nZXRFcnJvcigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9nbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApICE9PSAnJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgX2dsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNsZWFuIHVwXG5cblx0XHRfZ2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuXHRcdF9nbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdC8vIGNhY2hlIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHR2YXIgaWRlbnRpZmllcnMgPSBbXG5cblx0XHRcdCd2aWV3TWF0cml4JywgJ21vZGVsVmlld01hdHJpeCcsICdwcm9qZWN0aW9uTWF0cml4JywgJ25vcm1hbE1hdHJpeCcsICdtb2RlbE1hdHJpeCcsICdjYW1lcmFQb3NpdGlvbicsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCAnYmluZE1hdHJpeCcsICdiaW5kTWF0cml4SW52ZXJzZSdcblxuXHRcdF07XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVUZXh0dXJlJyApO1xuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVUZXh0dXJlV2lkdGgnICk7XG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCAnYm9uZVRleHR1cmVIZWlnaHQnICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCAnYm9uZUdsb2JhbE1hdHJpY2VzJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdGlkZW50aWZpZXJzLnB1c2goJ2xvZ0RlcHRoQnVmRkMnKTtcblxuXHRcdH1cblxuXG5cdFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXMgKSB7XG5cblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIHUgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudW5pZm9ybXMgPSBjYWNoZVVuaWZvcm1Mb2NhdGlvbnMoIF9nbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcblxuXHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgbG9jYXRpb25zXG5cblx0XHRpZGVudGlmaWVycyA9IFtcblxuXHRcdFx0XCJwb3NpdGlvblwiLCBcIm5vcm1hbFwiLCBcInV2XCIsIFwidXYyXCIsIFwidGFuZ2VudFwiLCBcImNvbG9yXCIsXG5cdFx0XHRcInNraW5JbmRleFwiLCBcInNraW5XZWlnaHRcIiwgXCJsaW5lRGlzdGFuY2VcIlxuXG5cdFx0XTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCBcIm1vcnBoVGFyZ2V0XCIgKyBpICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcblxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggXCJtb3JwaE5vcm1hbFwiICsgaSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGEgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggYSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMoIF9nbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcblx0XHR0aGlzLmF0dHJpYnV0ZXNLZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuYXR0cmlidXRlcyApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdHRoaXMudXNlZFRpbWVzID0gMTtcblx0XHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZGVyLmpzXG5cblRIUkVFLldlYkdMU2hhZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGFkZExpbmVOdW1iZXJzID0gZnVuY3Rpb24gKCBzdHJpbmcgKSB7XG5cblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZ2wsIHR5cGUsIHN0cmluZyApIHtcblxuXHRcdHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTsgXG5cblx0XHRnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cblx0XHRpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgKTtcblx0XHRcdGNvbnNvbGUud2FybiggYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cblx0XHR9XG5cblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuXHRcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0XHRyZXR1cm4gc2hhZGVyO1xuXG5cdH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmVQbHVnaW4gPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBmbGFyZXMgKSB7XG5cblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cdHZhciBoYXNWZXJ0ZXhUZXh0dXJlO1xuXG5cdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblx0XHRcdC0xLCAtMSwgIDAsIDAsXG5cdFx0XHQgMSwgLTEsICAxLCAwLFxuXHRcdFx0IDEsICAxLCAgMSwgMSxcblx0XHRcdC0xLCAgMSwgIDAsIDFcblx0XHRdICk7XG5cblx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcblx0XHRcdDAsIDEsIDIsXG5cdFx0XHQwLCAyLCAzXG5cdFx0XSApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0dmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGVsZW1lbnRCdWZmZXIgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0Ly8gdGV4dHVyZXNcblxuXHRcdHRlbXBUZXh0dXJlICAgICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDE2LCAxNiwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdGhhc1ZlcnRleFRleHR1cmUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApID4gMDtcblxuXHRcdHZhciBzaGFkZXI7XG5cblx0XHRpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdHNoYWRlciA9IHtcblxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG5cblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXG5cblx0XHRcdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcIixcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuXHRcdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXG5cblx0XHRcdFx0XHRcdFwiaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyByZXN0b3JlXG5cblx0XHRcdFx0XHRcdFwifSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cblx0XHRcdFx0XHRcdC8vIGZsYXJlXG5cblx0XHRcdFx0XHRcdFwifSBlbHNlIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzaGFkZXIgPSB7XG5cblx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHRcInZVViA9IHV2O1wiLFxuXG5cdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cblx0XHRcdFx0XHRcdFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cdFx0XHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuXHRcdFx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxuXG5cdFx0XHRcdFx0XHRcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxuXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBmbGFyZVxuXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgPSAoIDEuMCAtIHZpc2liaWxpdHkgLyA0LjAgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XCIsXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcblxuXHRcdGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHR1djogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJ1dlwiIClcblx0XHR9XG5cblx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdHJlbmRlclR5cGU6ICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicmVuZGVyVHlwZVwiICksXG5cdFx0XHRtYXA6ICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm1hcFwiICksXG5cdFx0XHRvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXG5cdFx0XHRvcGFjaXR5OiAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9wYWNpdHlcIiApLFxuXHRcdFx0Y29sb3I6ICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJjb2xvclwiICksXG5cdFx0XHRzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcblx0XHRcdHJvdGF0aW9uOiAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicm90YXRpb25cIiApLFxuXHRcdFx0c2NyZWVuUG9zaXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY3JlZW5Qb3NpdGlvblwiIClcblx0XHR9O1xuXG5cdH07XG5cblx0Lypcblx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXG5cdCAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXG5cdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXG5cdCAqL1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcblxuXHRcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlld3BvcnRXaWR0aCxcblx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcblx0XHRcdGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0ICogMC41O1xuXG5cdFx0dmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0LFxuXHRcdFx0c2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG5cdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbml0KCk7XG5cblx0XHR9XG5cblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy51diApO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcblx0XHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmZvcm1zXG5cblx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuXHRcdGdsLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdGdsLmRlcHRoTWFzayggZmFsc2UgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcblx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG5cdFx0XHQvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cblxuXHRcdFx0dmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XG5cdFx0XHRcblx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTNdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF0gKTtcblxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xuXG5cdFx0XHRzY3JlZW5Qb3NpdGlvbi5jb3B5KCB0ZW1wUG9zaXRpb24gKVxuXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcblxuXHRcdFx0Ly8gc2NyZWVuIGN1bGxcblxuXHRcdFx0aWYgKCBoYXNWZXJ0ZXhUZXh0dXJlIHx8IChcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0V2lkdGggJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA+IDAgJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XG5cblx0XHRcdFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcblxuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcblx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHJlbmRlciBwaW5rIHF1YWRcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuXHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG5cblx0XHRcdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRcdFx0Z2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuXHRcdFx0XHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcblxuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuXHRcdFx0XHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcblx0XHRcdFx0Z2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuXHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cblx0XHRcdFx0ZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKVxuXG5cdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0XHRmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZW5kZXIgZmxhcmVzXG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XG5cdFx0XHRcdGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XG5cblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcblxuXHRcdFx0XHRcdFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdFx0XHRcdHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xuXHRcdFx0XHRcdFx0c2NhbGUueSA9IHNpemU7XG5cblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xuXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XG5cblx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuXHRcdFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIGdsXG5cblx0XHRnbC5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdGdsLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xuXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyICkge1xuXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuXHRcdHZhciBwcmVmaXggPSBcInByZWNpc2lvbiBcIiArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgXCIgZmxvYXQ7XFxuXCI7XG5cblx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xuXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU2hhZG93TWFwUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TaGFkb3dNYXBQbHVnaW4gPSBmdW5jdGlvbiAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX3dlYmdsT2JqZWN0cywgX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSApIHtcblxuXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQ7XG5cblx0dmFyIF9kZXB0aE1hdGVyaWFsLCBfZGVwdGhNYXRlcmlhbE1vcnBoLCBfZGVwdGhNYXRlcmlhbFNraW4sIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLFxuXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG5cdF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRfbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcblx0X3JlbmRlckxpc3QgPSBbXTtcblxuXHQvLyBpbml0XG5cblx0dmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XG5cdHZhciBkZXB0aFVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGVwdGhTaGFkZXIudW5pZm9ybXMgKTtcblxuXHRfZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuXHRcdHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuXHRcdHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlclxuXHQgfSApO1xuXG5cdF9kZXB0aE1hdGVyaWFsTW9ycGggPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3Jtcyxcblx0XHR2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0bW9ycGhUYXJnZXRzOiB0cnVlXG5cdH0gKTtcblxuXHRfZGVwdGhNYXRlcmlhbFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3Jtcyxcblx0XHR2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0c2tpbm5pbmc6IHRydWVcblx0fSApO1xuXG5cdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cdFx0dW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG5cdFx0dmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuXHRcdG1vcnBoVGFyZ2V0czogdHJ1ZSxcblx0XHRza2lubmluZzogdHJ1ZVxuXHR9ICk7XG5cblx0X2RlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXHRfZGVwdGhNYXRlcmlhbE1vcnBoLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblx0X2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblx0X2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwRW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR2YXIgaSwgaWwsIGosIGpsLCBuLFxuXG5cdFx0c2hhZG93TWFwLCBzaGFkb3dNYXRyaXgsIHNoYWRvd0NhbWVyYSxcblx0XHRwcm9ncmFtLCBidWZmZXIsIG1hdGVyaWFsLFxuXHRcdHdlYmdsT2JqZWN0LCBvYmplY3QsIGxpZ2h0LFxuXG5cdFx0bGlnaHRzID0gW10sXG5cdFx0ayA9IDAsXG5cblx0XHRmb2cgPSBudWxsO1xuXG5cdFx0Ly8gc2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXBcblxuXHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XG5cdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuXHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcEN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG5cdFx0fVxuXG5cdFx0X3JlbmRlcmVyLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuXG5cdFx0Ly8gcHJlcHJvY2VzcyBsaWdodHNcblx0XHQvLyBcdC0gc2tpcCBsaWdodHMgdGhhdCBhcmUgbm90IGNhc3Rpbmcgc2hhZG93c1xuXHRcdC8vXHQtIGNyZWF0ZSB2aXJ0dWFsIGxpZ2h0cyBmb3IgY2FzY2FkZWQgc2hhZG93IG1hcHNcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGxpZ2h0ID0gX2xpZ2h0c1sgaSBdO1xuXG5cdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgJiYgbGlnaHQuc2hhZG93Q2FzY2FkZSApIHtcblxuXHRcdFx0XHRmb3IgKCBuID0gMDsgbiA8IGxpZ2h0LnNoYWRvd0Nhc2NhZGVDb3VudDsgbiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2aXJ0dWFsTGlnaHQ7XG5cblx0XHRcdFx0XHRpZiAoICEgbGlnaHQuc2hhZG93Q2FzY2FkZUFycmF5WyBuIF0gKSB7XG5cblx0XHRcdFx0XHRcdHZpcnR1YWxMaWdodCA9IGNyZWF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcblx0XHRcdFx0XHRcdHZpcnR1YWxMaWdodC5vcmlnaW5hbENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHRcdFx0dmFyIGd5cm8gPSBuZXcgVEhSRUUuR3lyb3Njb3BlKCk7XG5cdFx0XHRcdFx0XHRneXJvLnBvc2l0aW9uLmNvcHkoIGxpZ2h0LnNoYWRvd0Nhc2NhZGVPZmZzZXQgKTtcblxuXHRcdFx0XHRcdFx0Z3lyby5hZGQoIHZpcnR1YWxMaWdodCApO1xuXHRcdFx0XHRcdFx0Z3lyby5hZGQoIHZpcnR1YWxMaWdodC50YXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0Y2FtZXJhLmFkZCggZ3lybyApO1xuXG5cdFx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXSA9IHZpcnR1YWxMaWdodDtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiQ3JlYXRlZCB2aXJ0dWFsTGlnaHRcIiwgdmlydHVhbExpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHVwZGF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcblxuXHRcdFx0XHRcdGxpZ2h0c1sgayBdID0gdmlydHVhbExpZ2h0O1xuXHRcdFx0XHRcdGsgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxpZ2h0c1sgayBdID0gbGlnaHQ7XG5cdFx0XHRcdGsgKys7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGkgXTtcblxuXHRcdFx0aWYgKCAhIGxpZ2h0LnNoYWRvd01hcCApIHtcblxuXHRcdFx0XHR2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRcdFx0XHRzaGFkb3dGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGFycyA9IHsgbWluRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIG1hZ0ZpbHRlcjogc2hhZG93RmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQgfTtcblxuXHRcdFx0XHRsaWdodC5zaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIHBhcnMgKTtcblx0XHRcdFx0bGlnaHQuc2hhZG93TWFwU2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ICk7XG5cblx0XHRcdFx0bGlnaHQuc2hhZG93TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgbGlnaHQuc2hhZG93Q2FtZXJhICkge1xuXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUZvdiwgbGlnaHQuc2hhZG93TWFwV2lkdGggLyBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRcdGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUxlZnQsIGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFUb3AsIGxpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbSwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVW5zdXBwb3J0ZWQgbGlnaHQgdHlwZSBmb3Igc2hhZG93XCIgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NlbmUuYWRkKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcblxuXHRcdFx0XHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSAmJiAhIGxpZ2h0LmNhbWVyYUhlbHBlciApIHtcblxuXHRcdFx0XHRsaWdodC5jYW1lcmFIZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcblx0XHRcdFx0c2NlbmUuYWRkKCBsaWdodC5jYW1lcmFIZWxwZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxpZ2h0LmlzVmlydHVhbCAmJiB2aXJ0dWFsTGlnaHQub3JpZ2luYWxDYW1lcmEgPT0gY2FtZXJhICkge1xuXG5cdFx0XHRcdHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNoYWRvd01hcCA9IGxpZ2h0LnNoYWRvd01hcDtcblx0XHRcdHNoYWRvd01hdHJpeCA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcblx0XHRcdHNoYWRvd0NhbWVyYSA9IGxpZ2h0LnNoYWRvd0NhbWVyYTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdF9tYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX21hdHJpeFBvc2l0aW9uICk7XG5cdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCBsaWdodC5jYW1lcmFIZWxwZXIgKSBsaWdodC5jYW1lcmFIZWxwZXIudmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG5cdFx0XHRpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgKSBsaWdodC5jYW1lcmFIZWxwZXIudXBkYXRlKCk7XG5cblx0XHRcdC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxuXG5cdFx0XHRzaGFkb3dNYXRyaXguc2V0KFxuXHRcdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXG5cdFx0XHRcdDAuMCwgMC41LCAwLjAsIDAuNSxcblx0XHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxuXHRcdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcblx0XHRcdCk7XG5cblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcFxuXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcblx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXG5cblx0XHRcdF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBzY2VuZSwgc2hhZG93Q2FtZXJhICk7XG5cblxuXHRcdFx0Ly8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xuXG5cdFx0XHR2YXIgb2JqZWN0TWF0ZXJpYWwsIHVzZU1vcnBoaW5nLCB1c2VTa2lubmluZztcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gX3JlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0d2ViZ2xPYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xuXG5cdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblx0XHRcdFx0YnVmZmVyID0gd2ViZ2xPYmplY3QuYnVmZmVyO1xuXG5cdFx0XHRcdC8vIGN1bGxpbmcgaXMgb3ZlcnJpZGVuIGdsb2JhbGx5IGZvciBhbGwgb2JqZWN0c1xuXHRcdFx0XHQvLyB3aGlsZSByZW5kZXJpbmcgZGVwdGggbWFwXG5cblx0XHRcdFx0Ly8gbmVlZCB0byBkZWFsIHdpdGggTWVzaEZhY2VNYXRlcmlhbCBzb21laG93XG5cdFx0XHRcdC8vIGluIHRoYXQgY2FzZSBqdXN0IHVzZSB0aGUgZmlyc3Qgb2YgbWF0ZXJpYWwubWF0ZXJpYWxzIGZvciBub3dcblx0XHRcdFx0Ly8gKHByb3BlciBzb2x1dGlvbiB3b3VsZCByZXF1aXJlIHRvIGJyZWFrIG9iamVjdHMgYnkgbWF0ZXJpYWxzXG5cdFx0XHRcdC8vICBzaW1pbGFybHkgdG8gcmVndWxhciByZW5kZXJpbmcgYW5kIHRoZW4gc2V0IGNvcnJlc3BvbmRpbmdcblx0XHRcdFx0Ly8gIGRlcHRoIG1hdGVyaWFscyBwZXIgZWFjaCBjaHVuayBpbnN0ZWFkIG9mIGp1c3Qgb25jZSBwZXIgb2JqZWN0KVxuXG5cdFx0XHRcdG9iamVjdE1hdGVyaWFsID0gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApO1xuXG5cdFx0XHRcdHVzZU1vcnBoaW5nID0gb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBvYmplY3RNYXRlcmlhbC5tb3JwaFRhcmdldHM7XG5cdFx0XHRcdHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgb2JqZWN0TWF0ZXJpYWwuc2tpbm5pbmc7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdXNlU2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IHVzZU1vcnBoaW5nID8gX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gOiBfZGVwdGhNYXRlcmlhbFNraW47XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdXNlTW9ycGhpbmcgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsTW9ycGg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9yZW5kZXJlci5zZXRNYXRlcmlhbEZhY2VzKCBvYmplY3RNYXRlcmlhbCApO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXIoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgZm9nLCBtYXRlcmlhbCwgYnVmZmVyLCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IG1hdHJpY2VzIGFuZCByZW5kZXIgaW1tZWRpYXRlIG9iamVjdHNcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR3ZWJnbE9iamVjdCA9IF93ZWJnbE9iamVjdHNJbW1lZGlhdGVbIGogXTtcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgJiYgb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgZm9nLCBfZGVwdGhNYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIEdMIHN0YXRlXG5cblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwQ3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cblx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuXHRcdH1cblxuXHRcdF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIHNjZW5lLCBvYmplY3QsIHNoYWRvd0NhbWVyYSApe1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0cyA9IF93ZWJnbE9iamVjdHNbIG9iamVjdC5pZCBdO1xuXG5cdFx0XHRpZiAoIHdlYmdsT2JqZWN0cyAmJiBvYmplY3QuY2FzdFNoYWRvdyAmJiAob2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlKSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB3ZWJnbE9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB3ZWJnbE9iamVjdCA9IHdlYmdsT2JqZWN0c1sgaSBdO1xuXG5cdFx0XHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X3JlbmRlckxpc3QucHVzaCggd2ViZ2xPYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIG9iamVjdC5jaGlsZHJlblsgaSBdLCBzaGFkb3dDYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xuXG5cdFx0dmFyIHZpcnR1YWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCk7XG5cblx0XHR2aXJ0dWFsTGlnaHQuaXNWaXJ0dWFsID0gdHJ1ZTtcblxuXHRcdHZpcnR1YWxMaWdodC5vbmx5U2hhZG93ID0gdHJ1ZTtcblx0XHR2aXJ0dWFsTGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG5cblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXI7XG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUZhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYUZhcjtcblxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gbGlnaHQuc2hhZG93Q2FtZXJhTGVmdDtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQgPSBsaWdodC5zaGFkb3dDYW1lcmFSaWdodDtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tID0gbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tO1xuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFUb3AgPSBsaWdodC5zaGFkb3dDYW1lcmFUb3A7XG5cblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG5cblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93RGFya25lc3MgPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcblxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93Q2FzY2FkZUJpYXNbIGNhc2NhZGUgXTtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93TWFwV2lkdGggPSBsaWdodC5zaGFkb3dDYXNjYWRlV2lkdGhbIGNhc2NhZGUgXTtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93TWFwSGVpZ2h0ID0gbGlnaHQuc2hhZG93Q2FzY2FkZUhlaWdodFsgY2FzY2FkZSBdO1xuXG5cdFx0dmlydHVhbExpZ2h0LnBvaW50c1dvcmxkID0gW107XG5cdFx0dmlydHVhbExpZ2h0LnBvaW50c0ZydXN0dW0gPSBbXTtcblxuXHRcdHZhciBwb2ludHNXb3JsZCA9IHZpcnR1YWxMaWdodC5wb2ludHNXb3JsZCxcblx0XHRcdHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cblx0XHRcdHBvaW50c1dvcmxkWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cG9pbnRzRnJ1c3R1bVsgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdHZhciBuZWFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWlsgY2FzY2FkZSBdO1xuXHRcdHZhciBmYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZUZhclpbIGNhc2NhZGUgXTtcblxuXHRcdHBvaW50c0ZydXN0dW1bIDAgXS5zZXQoIC0gMSwgLSAxLCBuZWFyWiApO1xuXHRcdHBvaW50c0ZydXN0dW1bIDEgXS5zZXQoICAxLCAtIDEsIG5lYXJaICk7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgMiBdLnNldCggLSAxLCAgMSwgbmVhclogKTtcblx0XHRwb2ludHNGcnVzdHVtWyAzIF0uc2V0KCAgMSwgIDEsIG5lYXJaICk7XG5cblx0XHRwb2ludHNGcnVzdHVtWyA0IF0uc2V0KCAtIDEsIC0gMSwgZmFyWiApO1xuXHRcdHBvaW50c0ZydXN0dW1bIDUgXS5zZXQoICAxLCAtIDEsIGZhclogKTtcblx0XHRwb2ludHNGcnVzdHVtWyA2IF0uc2V0KCAtIDEsICAxLCBmYXJaICk7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgNyBdLnNldCggIDEsICAxLCBmYXJaICk7XG5cblx0XHRyZXR1cm4gdmlydHVhbExpZ2h0O1xuXG5cdH1cblxuXHQvLyBTeW5jaHJvbml6ZSB2aXJ0dWFsIGxpZ2h0IHdpdGggdGhlIG9yaWdpbmFsIGxpZ2h0XG5cblx0ZnVuY3Rpb24gdXBkYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgY2FzY2FkZSApIHtcblxuXHRcdHZhciB2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIGNhc2NhZGUgXTtcblxuXHRcdHZpcnR1YWxMaWdodC5wb3NpdGlvbi5jb3B5KCBsaWdodC5wb3NpdGlvbiApO1xuXHRcdHZpcnR1YWxMaWdodC50YXJnZXQucG9zaXRpb24uY29weSggbGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XG5cdFx0dmlydHVhbExpZ2h0Lmxvb2tBdCggdmlydHVhbExpZ2h0LnRhcmdldCApO1xuXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dEYXJrbmVzcyA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xuXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3dDYXNjYWRlQmlhc1sgY2FzY2FkZSBdO1xuXG5cdFx0dmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XG5cdFx0dmFyIGZhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlRmFyWlsgY2FzY2FkZSBdO1xuXG5cdFx0dmFyIHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcblxuXHRcdHBvaW50c0ZydXN0dW1bIDAgXS56ID0gbmVhclo7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgMSBdLnogPSBuZWFyWjtcblx0XHRwb2ludHNGcnVzdHVtWyAyIF0ueiA9IG5lYXJaO1xuXHRcdHBvaW50c0ZydXN0dW1bIDMgXS56ID0gbmVhclo7XG5cblx0XHRwb2ludHNGcnVzdHVtWyA0IF0ueiA9IGZhclo7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgNSBdLnogPSBmYXJaO1xuXHRcdHBvaW50c0ZydXN0dW1bIDYgXS56ID0gZmFyWjtcblx0XHRwb2ludHNGcnVzdHVtWyA3IF0ueiA9IGZhclo7XG5cblx0fVxuXG5cdC8vIEZpdCBzaGFkb3cgY2FtZXJhJ3Mgb3J0aG8gZnJ1c3R1bSB0byBjYW1lcmEgZnJ1c3R1bVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApIHtcblxuXHRcdHZhciBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmEsXG5cdFx0XHRwb2ludHNGcnVzdHVtID0gbGlnaHQucG9pbnRzRnJ1c3R1bSxcblx0XHRcdHBvaW50c1dvcmxkID0gbGlnaHQucG9pbnRzV29ybGQ7XG5cblx0XHRfbWluLnNldCggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHRcdF9tYXguc2V0KCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG5cdFx0XHR2YXIgcCA9IHBvaW50c1dvcmxkWyBpIF07XG5cblx0XHRcdHAuY29weSggcG9pbnRzRnJ1c3R1bVsgaSBdICk7XG5cdFx0XHRwLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHRcdHAuYXBwbHlNYXRyaXg0KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdGlmICggcC54IDwgX21pbi54ICkgX21pbi54ID0gcC54O1xuXHRcdFx0aWYgKCBwLnggPiBfbWF4LnggKSBfbWF4LnggPSBwLng7XG5cblx0XHRcdGlmICggcC55IDwgX21pbi55ICkgX21pbi55ID0gcC55O1xuXHRcdFx0aWYgKCBwLnkgPiBfbWF4LnkgKSBfbWF4LnkgPSBwLnk7XG5cblx0XHRcdGlmICggcC56IDwgX21pbi56ICkgX21pbi56ID0gcC56O1xuXHRcdFx0aWYgKCBwLnogPiBfbWF4LnogKSBfbWF4LnogPSBwLno7XG5cblx0XHR9XG5cblx0XHRzaGFkb3dDYW1lcmEubGVmdCA9IF9taW4ueDtcblx0XHRzaGFkb3dDYW1lcmEucmlnaHQgPSBfbWF4Lng7XG5cdFx0c2hhZG93Q2FtZXJhLnRvcCA9IF9tYXgueTtcblx0XHRzaGFkb3dDYW1lcmEuYm90dG9tID0gX21pbi55O1xuXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGZpdCBuZWFyL2ZhclxuXHRcdC8vc2hhZG93Q2FtZXJhLm5lYXIgPSBfbWluLno7XG5cdFx0Ly9zaGFkb3dDYW1lcmEuZmFyID0gX21heC56O1xuXG5cdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Ly8gRm9yIHRoZSBtb21lbnQganVzdCBpZ25vcmUgb2JqZWN0cyB0aGF0IGhhdmUgbXVsdGlwbGUgbWF0ZXJpYWxzIHdpdGggZGlmZmVyZW50IGFuaW1hdGlvbiBtZXRob2RzXG5cdC8vIE9ubHkgdGhlIGZpcnN0IG1hdGVyaWFsIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50IGZvciBkZWNpZGluZyB3aGljaCBkZXB0aCBtYXRlcmlhbCB0byB1c2UgZm9yIHNoYWRvdyBtYXBzXG5cblx0ZnVuY3Rpb24gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApIHtcblxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXG5cdFx0XHQ/IG9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHNbIDAgXVxuXHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XG5cblx0fTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU3ByaXRlUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc3ByaXRlcyApIHtcblxuXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG5cdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG5cdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuXHR2YXIgdGV4dHVyZTtcblx0XG5cdHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXHRcdFx0LSAwLjUsIC0gMC41LCAgMCwgMCxcblx0XHRcdCAgMC41LCAtIDAuNSwgIDEsIDAsXG5cdFx0XHQgIDAuNSwgICAwLjUsICAxLCAxLFxuXHRcdFx0LSAwLjUsICAgMC41LCAgMCwgMVxuXHRcdF0gKTtcblxuXHRcdHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuXHRcdFx0MCwgMSwgMixcblx0XHRcdDAsIDIsIDNcblx0XHRdICk7XG5cblx0XHR2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0ZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0YXR0cmlidXRlcyA9IHtcblx0XHRcdHBvc2l0aW9uOlx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxuXHRcdFx0dXY6XHRcdFx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3V2JyApXG5cdFx0fTtcblxuXHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0dXZPZmZzZXQ6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXG5cdFx0XHR1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cblx0XHRcdHJvdGF0aW9uOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxuXHRcdFx0c2NhbGU6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcblxuXHRcdFx0Y29sb3I6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcblx0XHRcdG1hcDpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcblx0XHRcdG9wYWNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcblxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcblx0XHRcdHByb2plY3Rpb25NYXRyaXg6XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxuXG5cdFx0XHRmb2dUeXBlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXG5cdFx0XHRmb2dEZW5zaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXG5cdFx0XHRmb2dOZWFyOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXG5cdFx0XHRmb2dGYXI6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXG5cdFx0XHRmb2dDb2xvcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuXHRcdFx0YWxwaGFUZXN0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxuXHRcdH07XG5cblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRjYW52YXMud2lkdGggPSA4O1xuXHRcdGNhbnZhcy5oZWlnaHQgPSA4O1xuXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcblx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cblx0XHR0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH07XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Ly8gc2V0dXAgZ2xcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbml0KCk7XG5cblx0XHR9XG5cblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHRnbC5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRnbC5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XG5cblx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XG5cdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcblxuXHRcdGlmICggZm9nICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cblx0XHRcdGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcblx0XHRcdFx0b2xkRm9nVHlwZSA9IDE7XG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuXHRcdFx0XHRvbGRGb2dUeXBlID0gMjtcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG5cdFx0XHRvbGRGb2dUeXBlID0gMDtcblx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XG5cblx0XHR9XG5cblxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuXHRcdFx0c3ByaXRlLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGlmICggc3ByaXRlLnJlbmRlckRlcHRoID09PSBudWxsICkge1xuXG5cdFx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUuX21vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzcHJpdGUueiA9IHNwcml0ZS5yZW5kZXJEZXB0aDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG5cdFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXG5cblx0XHR2YXIgc2NhbGUgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblx0XHRcdHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdFx0c2NhbGVbIDAgXSA9IHNwcml0ZS5zY2FsZS54O1xuXHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZS5zY2FsZS55O1xuXG5cdFx0XHR2YXIgZm9nVHlwZSA9IDA7XG5cblx0XHRcdGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuXHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcblx0XHRcdFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XG5cblx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG5cdFx0XHRnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblx0XHRcdHJlbmRlcmVyLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRyZW5kZXJlci5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pbWFnZSAmJiBtYXRlcmlhbC5tYXAuaW1hZ2Uud2lkdGggKSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzdG9yZSBnbFxuXG5cdFx0Z2wuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRcblx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCkge1xuXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXG5cblx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dlNjYWxlOycsXG5cblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcblxuXHRcdFx0XHQndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXG5cblx0XHRcdFx0J3ZlYzIgcm90YXRlZFBvc2l0aW9uOycsXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7Jyxcblx0XHRcdFx0J3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG5cdFx0XHRcdCd2ZWM0IGZpbmFsUG9zaXRpb247JyxcblxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBmaW5hbFBvc2l0aW9uOycsXG5cblx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxuXG5cdFx0XHQnfSdcblxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xuXG5cdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuXHRcdFx0J3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxuXHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG5cdFx0XHQndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcblxuXHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxuXG5cdFx0XHRcdCd2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcblxuXHRcdFx0XHQnaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXG5cblx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxuXG5cdFx0XHRcdCdpZiAoIGZvZ1R5cGUgPiAwICkgeycsXG5cblx0XHRcdFx0XHQnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXG5cdFx0XHRcdFx0J2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG5cdFx0XHRcdFx0J2lmICggZm9nVHlwZSA9PSAxICkgeycsXG5cblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7JyxcblxuXHRcdFx0XHRcdCd9IGVsc2UgeycsXG5cblx0XHRcdFx0XHRcdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7Jyxcblx0XHRcdFx0XHRcdCdmbG9hdCBmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTsnLFxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuXHRcdFx0XHRcdCd9JyxcblxuXHRcdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXG5cblx0XHRcdFx0J30nLFxuXG5cdFx0XHQnfSdcblxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcblxuXHRcdH1cblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvR2VvbWV0cnlVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcblxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XG5cblx0XHR2YXIgbWF0cml4O1xuXG5cdFx0aWYgKCBnZW9tZXRyeTIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG5cdFx0XHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XG5cdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XG5cblx0fSxcblxuXHRjZW50ZXI6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvSW1hZ2VVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBEYW9zaGVuZyBNdSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW9zaGVuZ011L1xuICovXG5cblRIUkVFLkltYWdlVXRpbHMgPSB7XG5cblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcblx0XHRsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCBtYXBwaW5nICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRleHR1cmUuc291cmNlRmlsZSA9IHVybDtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIGFycmF5LCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cdFx0bG9hZGVyLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcgKTtcblxuXHRcdC8vIG5vIGZsaXBwaW5nIG5lZWRlZCBmb3IgY3ViZSB0ZXh0dXJlc1xuXG5cdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0dmFyIGxvYWRlZCA9IDA7XG5cblx0XHR2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCBhcnJheVsgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuXHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG5cdH0sXG5cblx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xuXG5cdFx0Ly8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL2xhYi9oZWlnaHRub3JtYWwvXG5cblx0XHR2YXIgY3Jvc3MgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcblxuXHRcdH1cblxuXHRcdHZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0dmFyIGwgPSBNYXRoLnNxcnQoIGFbIDAgXSAqIGFbIDAgXSArIGFbIDEgXSAqIGFbIDEgXSArIGFbIDIgXSAqIGFbIDIgXSApO1xuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC8gbCwgYVsgMSBdIC8gbCwgYVsgMiBdIC8gbCBdO1xuXG5cdFx0fVxuXG5cdFx0ZGVwdGggPSBkZXB0aCB8IDE7XG5cblx0XHR2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcblxuXHRcdHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKS5kYXRhO1xuXHRcdHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xuXHRcdHZhciBvdXRwdXQgPSBpbWFnZURhdGEuZGF0YTtcblxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGx5ID0geSAtIDEgPCAwID8gMCA6IHkgLSAxO1xuXHRcdFx0XHR2YXIgdXkgPSB5ICsgMSA+IGhlaWdodCAtIDEgPyBoZWlnaHQgLSAxIDogeSArIDE7XG5cdFx0XHRcdHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcblx0XHRcdFx0dmFyIHV4ID0geCArIDEgPiB3aWR0aCAtIDEgPyB3aWR0aCAtIDEgOiB4ICsgMTtcblxuXHRcdFx0XHR2YXIgcG9pbnRzID0gW107XG5cdFx0XHRcdHZhciBvcmlnaW4gPSBbIDAsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgLSAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAwLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgIDEsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAwLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblxuXHRcdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdFx0XHR2YXIgbnVtX3BvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtX3BvaW50czsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2MSA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRcdHZhciB2MiA9IHBvaW50c1sgKCBpICsgMSApICUgbnVtX3BvaW50cyBdO1xuXHRcdFx0XHRcdHYxID0gc3VidHJhY3QoIHYxLCBvcmlnaW4gKTtcblx0XHRcdFx0XHR2MiA9IHN1YnRyYWN0KCB2Miwgb3JpZ2luICk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWxpemUoIGNyb3NzKCB2MSwgdjIgKSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBub3JtYWwgPSBbIDAsIDAsIDAgXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG5vcm1hbFsgMCBdICs9IG5vcm1hbHNbIGkgXVsgMCBdO1xuXHRcdFx0XHRcdG5vcm1hbFsgMSBdICs9IG5vcm1hbHNbIGkgXVsgMSBdO1xuXHRcdFx0XHRcdG5vcm1hbFsgMiBdICs9IG5vcm1hbHNbIGkgXVsgMiBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRub3JtYWxbIDAgXSAvPSBub3JtYWxzLmxlbmd0aDtcblx0XHRcdFx0bm9ybWFsWyAxIF0gLz0gbm9ybWFscy5sZW5ndGg7XG5cdFx0XHRcdG5vcm1hbFsgMiBdIC89IG5vcm1hbHMubGVuZ3RoO1xuXG5cdFx0XHRcdHZhciBpZHggPSAoIHkgKiB3aWR0aCArIHggKSAqIDQ7XG5cblx0XHRcdFx0b3V0cHV0WyBpZHggXSA9ICggKCBub3JtYWxbIDAgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xuXHRcdFx0XHRvdXRwdXRbIGlkeCArIDEgXSA9ICggKCBub3JtYWxbIDEgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xuXHRcdFx0XHRvdXRwdXRbIGlkeCArIDIgXSA9ICggbm9ybWFsWyAyIF0gKiAyNTUgKSB8IDA7XG5cdFx0XHRcdG91dHB1dFsgaWR4ICsgMyBdID0gMjU1O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2VEYXRhLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gY2FudmFzO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVEYXRhVGV4dHVyZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBjb2xvciApIHtcblxuXHRcdHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG5cdFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggMyAqIHNpemUgKTtcblxuXHRcdHZhciByID0gTWF0aC5mbG9vciggY29sb3IuciAqIDI1NSApO1xuXHRcdHZhciBnID0gTWF0aC5mbG9vciggY29sb3IuZyAqIDI1NSApO1xuXHRcdHZhciBiID0gTWF0aC5mbG9vciggY29sb3IuYiAqIDI1NSApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0ZGF0YVsgaSAqIDMgXSBcdCAgID0gcjtcblx0XHRcdGRhdGFbIGkgKiAzICsgMSBdID0gZztcblx0XHRcdGRhdGFbIGkgKiAzICsgMiBdID0gYjtcblxuXHRcdH1cblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBUSFJFRS5SR0JGb3JtYXQgKTtcblx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL1NjZW5lVXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNjZW5lVXRpbHMgPSB7XG5cblx0Y3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xuXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Z3JvdXAuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBncm91cDtcblxuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcblxuXHRcdGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xuXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcblxuXHR9LFxuXG5cdGF0dGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgc2NlbmUsIHBhcmVudCApIHtcblxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRzY2VuZS5yZW1vdmUoIGNoaWxkICk7XG5cdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9Gb250VXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBUZXh0IG9wZXJhdGlvbnMgaW4gdGhyZWUuanMgKFNlZSBUZXh0R2VvbWV0cnkpXG4gKlxuICogSXQgdXNlcyB0ZWNobmlxdWVzIHVzZWQgaW46XG4gKlxuICogXHR0eXBlZmFjZS5qcyBhbmQgY2FudmFzdGV4dFxuICogXHRcdEZvciBjb252ZXJ0aW5nIGZvbnRzIGFuZCByZW5kZXJpbmcgd2l0aCBqYXZhc2NyaXB0XG4gKlx0XHRodHRwOi8vdHlwZWZhY2UubmVvY3JhY3kub3JnXG4gKlxuICpcdFRyaWFuZ3VsYXRpb24gcG9ydGVkIGZyb20gQVMzXG4gKlx0XHRTaW1wbGUgUG9seWdvbiBUcmlhbmd1bGF0aW9uXG4gKlx0XHRodHRwOi8vYWN0aW9uc25pcHBldC5jb20vP3A9MTQ2MlxuICpcbiAqIFx0QSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcbiAqXHRcdGh0dHA6Ly93d3cuc2FrcmkubmV0L2Jsb2cvMjAwOS8wNi8xMi9hbi1hcHByb2FjaC10by10cmlhbmd1bGF0aW5nLXBvbHlnb25zLXdpdGgtaG9sZXMvXG4gKlxuICovXG5cblRIUkVFLkZvbnRVdGlscyA9IHtcblxuXHRmYWNlczoge30sXG5cblx0Ly8gSnVzdCBmb3Igbm93LiBmYWNlW3dlaWdodF1bc3R5bGVdXG5cblx0ZmFjZTogJ2hlbHZldGlrZXInLFxuXHR3ZWlnaHQ6ICdub3JtYWwnLFxuXHRzdHlsZTogJ25vcm1hbCcsXG5cdHNpemU6IDE1MCxcblx0ZGl2aXNpb25zOiAxMCxcblxuXHRnZXRGYWNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5mYWNlc1sgdGhpcy5mYWNlIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcblxuXHRcdH0gY2F0Y2ggKGUpIHtcblxuXHRcdFx0dGhyb3cgXCJUaGUgZm9udCBcIiArIHRoaXMuZmFjZSArIFwiIHdpdGggXCIgKyB0aGlzLndlaWdodCArIFwiIHdlaWdodCBhbmQgXCIgKyB0aGlzLnN0eWxlICsgXCIgc3R5bGUgaXMgbWlzc2luZy5cIlxuXG5cdFx0fTtcblxuXHR9LFxuXG5cdGxvYWRGYWNlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHR2YXIgVGhyZWVGb250ID0gdGhpcztcblxuXHRcdFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xuXG5cdFx0VGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcblx0XHRUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cblx0XHR2YXIgZmFjZSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH0sXG5cblx0ZHJhd1RleHQ6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdHZhciBjaGFyYWN0ZXJQdHMgPSBbXSwgYWxsUHRzID0gW107XG5cblx0XHQvLyBSZW5kZXJUZXh0XG5cblx0XHR2YXIgaSwgcCxcblx0XHRcdGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcblx0XHRcdHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxuXHRcdFx0b2Zmc2V0ID0gMCxcblx0XHRcdGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXG5cdFx0XHRsZW5ndGggPSBjaGFycy5sZW5ndGg7XG5cblx0XHR2YXIgZm9udFBhdGhzID0gW107XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHR2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcblx0XHRcdG9mZnNldCArPSByZXQub2Zmc2V0O1xuXG5cdFx0XHRmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcblxuXHRcdH1cblxuXHRcdC8vIGdldCB0aGUgd2lkdGhcblxuXHRcdHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XG5cdFx0Ly9cblx0XHQvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcblx0XHQvL1xuXHRcdC8vIFx0YWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcblx0XHQvL1xuXHRcdC8vIH1cblxuXHRcdC8vdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3RQb2ludHMoIGFsbFB0cywgY2hhcmFjdGVyUHRzICk7XG5cdFx0Ly9leHRyYWN0LmNvbnRvdXIgPSBhbGxQdHM7XG5cblx0XHQvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XG5cdFx0Ly9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xuXG5cdFx0cmV0dXJuIHsgcGF0aHM6IGZvbnRQYXRocywgb2Zmc2V0OiB3aWR0aCB9O1xuXG5cdH0sXG5cblxuXG5cblx0ZXh0cmFjdEdseXBoUG9pbnRzOiBmdW5jdGlvbiAoIGMsIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKSB7XG5cblx0XHR2YXIgcHRzID0gW107XG5cblx0XHR2YXIgaSwgaTIsIGRpdmlzaW9ucyxcblx0XHRcdG91dGxpbmUsIGFjdGlvbiwgbGVuZ3RoLFxuXHRcdFx0c2NhbGVYLCBzY2FsZVksXG5cdFx0XHR4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5Mixcblx0XHRcdGxhc3RlLFxuXHRcdFx0Z2x5cGggPSBmYWNlLmdseXBoc1sgYyBdIHx8IGZhY2UuZ2x5cGhzWyAnPycgXTtcblxuXHRcdGlmICggISBnbHlwaCApIHJldHVybjtcblxuXHRcdGlmICggZ2x5cGgubyApIHtcblxuXHRcdFx0b3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xuXHRcdFx0bGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XG5cblx0XHRcdHNjYWxlWCA9IHNjYWxlO1xuXHRcdFx0c2NhbGVZID0gc2NhbGU7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcblxuXHRcdFx0XHRhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyggYWN0aW9uICk7XG5cblx0XHRcdFx0c3dpdGNoICggYWN0aW9uICkge1xuXG5cdFx0XHRcdGNhc2UgJ20nOlxuXG5cdFx0XHRcdFx0Ly8gTW92ZSBUb1xuXG5cdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcblx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuXG5cdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdsJzpcblxuXHRcdFx0XHRcdC8vIExpbmUgVG9cblxuXHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG5cdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcblx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCx5ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncSc6XG5cblx0XHRcdFx0XHQvLyBRdWFkcmF0aWNDdXJ2ZVRvXG5cblx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XG5cdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcblx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuXG5cdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xuXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXHRcdFx0XHRcdCAgfVxuXG5cdFx0XHRcdCAgfVxuXG5cdFx0XHRcdCAgYnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYic6XG5cblx0XHRcdFx0XHQvLyBDdWJpYyBCZXppZXIgQ3VydmVcblxuXHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXHRcdFx0XHRcdGNweDIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXG5cdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0cmV0dXJuIHsgb2Zmc2V0OiBnbHlwaC5oYSAqIHNjYWxlLCBwYXRoOnBhdGggfTtcblx0fVxuXG59O1xuXG5cblRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuXHQvLyBQYXJhbWV0ZXJzIFxuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHZhciBzaXplID0gcGFyYW1ldGVycy5zaXplICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNpemUgOiAxMDA7XG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgOiA0O1xuXG5cdHZhciBmb250ID0gcGFyYW1ldGVycy5mb250ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvbnQgOiAnaGVsdmV0aWtlcic7XG5cdHZhciB3ZWlnaHQgPSBwYXJhbWV0ZXJzLndlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53ZWlnaHQgOiAnbm9ybWFsJztcblx0dmFyIHN0eWxlID0gcGFyYW1ldGVycy5zdHlsZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdHlsZSA6ICdub3JtYWwnO1xuXG5cdFRIUkVFLkZvbnRVdGlscy5zaXplID0gc2l6ZTtcblx0VEhSRUUuRm9udFV0aWxzLmRpdmlzaW9ucyA9IGN1cnZlU2VnbWVudHM7XG5cblx0VEhSRUUuRm9udFV0aWxzLmZhY2UgPSBmb250O1xuXHRUSFJFRS5Gb250VXRpbHMud2VpZ2h0ID0gd2VpZ2h0O1xuXHRUSFJFRS5Gb250VXRpbHMuc3R5bGUgPSBzdHlsZTtcblxuXHQvLyBHZXQgYSBGb250IGRhdGEganNvbiBvYmplY3RcblxuXHR2YXIgZGF0YSA9IFRIUkVFLkZvbnRVdGlscy5kcmF3VGV4dCggdGV4dCApO1xuXG5cdHZhciBwYXRocyA9IGRhdGEucGF0aHM7XG5cdHZhciBzaGFwZXMgPSBbXTtcblxuXHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcblxuXHR9XG5cblx0cmV0dXJuIHNoYXBlcztcblxufTtcblxuXG4vKipcbiAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXG4gKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxuICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcbiAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcbiAqXG4gKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXG4gKlxuICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqL1xuXG5cbiggZnVuY3Rpb24gKCBuYW1lc3BhY2UgKSB7XG5cblx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cblx0Ly8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xuXG5cdHZhciBwcm9jZXNzID0gZnVuY3Rpb24gKCBjb250b3VyLCBpbmRpY2VzICkge1xuXG5cdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdHZlcnRzID0gW10sXG5cdFx0XHR2ZXJ0SW5kaWNlcyA9IFtdO1xuXG5cdFx0Lyogd2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gdmVydHMgKi9cblxuXHRcdHZhciB1LCB2LCB3O1xuXG5cdFx0aWYgKCBhcmVhKCBjb250b3VyICkgPiAwLjAgKSB7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSB2O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XG5cblx0XHR9XG5cblx0XHR2YXIgbnYgPSBuO1xuXG5cdFx0LyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xuXG5cdFx0dmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xuXG5cdFx0Zm9yICggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcblxuXHRcdFx0LyogaWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gKi9cblxuXHRcdFx0aWYgKCAoIGNvdW50IC0tICkgPD0gMCApIHtcblxuXHRcdFx0XHQvLyoqIFRyaWFuZ3VsYXRlOiBFUlJPUiAtIHByb2JhYmxlIGJhZCBwb2x5Z29uIVxuXG5cdFx0XHRcdC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XG5cdFx0XHRcdC8vcmV0dXJuIG51bGw7XG5cdFx0XHRcdC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxuXHRcdFx0XHRjb25zb2xlLmxvZyggJ1dhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIScgKTtcblxuXHRcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH1cblxuXHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cblx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cblx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cblx0XHRcdHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuXHRcdFx0aWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuXHRcdFx0XHR2YXIgYSwgYiwgYywgcywgdDtcblxuXHRcdFx0XHQvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG5cdFx0XHRcdGEgPSB2ZXJ0c1sgdSBdO1xuXHRcdFx0XHRiID0gdmVydHNbIHYgXTtcblx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XG5cblx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXG5cblx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuXHRcdFx0XHRcdGNvbnRvdXJbIGIgXSxcblx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xuXG5cblx0XHRcdFx0dmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuXHRcdFx0XHQvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG5cdFx0XHRcdGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcysrLCB0KysgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bnYgLS07XG5cblx0XHRcdFx0LyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cblxuXHRcdFx0XHRjb3VudCA9IDIgKiBudjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fTtcblxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cblx0dmFyIGFyZWEgPSBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XG5cblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXHRcdHZhciBhID0gMC4wO1xuXG5cdFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcblxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhICogMC41O1xuXG5cdH07XG5cblx0dmFyIHNuaXAgPSBmdW5jdGlvbiAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xuXG5cdFx0dmFyIHA7XG5cdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xuXHRcdHZhciBjeCwgY3ksIHB4LCBweTtcblxuXHRcdGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XG5cdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuXHRcdGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XG5cdFx0YnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcblxuXHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG5cdFx0Y3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcblxuXHRcdGlmICggRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XG5cdFx0dmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XG5cdFx0dmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XG5cblx0XHRhWCA9IGN4IC0gYng7ICBhWSA9IGN5IC0gYnk7XG5cdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xuXHRcdGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcblxuXHRcdGZvciAoIHAgPSAwOyBwIDwgbjsgcCArKyApIHtcblxuXHRcdFx0cHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueFxuXHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueVxuXG5cdFx0XHRpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcblx0XHRcdFx0ICggKCBweCA9PT0gYnggKSAmJiAoIHB5ID09PSBieSApICkgfHxcblx0XHRcdFx0ICggKCBweCA9PT0gY3ggKSAmJiAoIHB5ID09PSBjeSApICkgKVx0Y29udGludWU7XG5cblx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuXHRcdFx0YnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XG5cdFx0XHRjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcblxuXHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG5cdFx0XHRhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XG5cdFx0XHRjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XG5cdFx0XHRiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cblx0XHRcdGlmICggKCBhQ1JPU1NicCA+PSAtIEVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBFUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG5cblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2Vzcztcblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xuXG5cdHJldHVybiBuYW1lc3BhY2U7XG5cbn0gKSggVEhSRUUuRm9udFV0aWxzICk7XG5cbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXG5zZWxmLl90eXBlZmFjZV9qcyA9IHsgZmFjZXM6IFRIUkVFLkZvbnRVdGlscy5mYWNlcywgbG9hZEZhY2U6IFRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZSB9O1xuVEhSRUUudHlwZWZhY2VfanMgPSBzZWxmLl90eXBlZmFjZV9qcztcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BdWRpbyA9IGZ1bmN0aW9uICggbGlzdGVuZXIgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cblx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cblx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0cmVxdWVzdC5vcGVuKCAnR0VUJywgZmlsZSwgdHJ1ZSApO1xuXHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0c2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRzY29wZS5zb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0c2NvcGUuc291cmNlLmNvbm5lY3QoIHNjb3BlLnBhbm5lciApO1xuXHRcdFx0c2NvcGUuc291cmNlLnN0YXJ0KCAwICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblx0cmVxdWVzdC5zZW5kKCk7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHR0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdFx0cG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXG5cdH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW9MaXN0ZW5lci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW9MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG5cdHRoaXMuY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHR2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHZhciBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIHBvc2l0aW9uUHJldiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuXHRcdG9yaWVudGF0aW9uLnNldCggMCwgMCwgLTEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblx0XHR2ZWxvY2l0eS5zdWJWZWN0b3JzKCBwb3NpdGlvbiwgcG9zaXRpb25QcmV2ICk7XG5cblx0XHRsaXN0ZW5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB0aGlzLnVwLngsIHRoaXMudXAueSwgdGhpcy51cC56ICk7XG5cdFx0bGlzdGVuZXIuc2V0VmVsb2NpdHkoIHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnogKTtcblxuXHRcdHBvc2l0aW9uUHJldi5jb3B5KCBwb3NpdGlvbiApO1xuXG5cdH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG4gKlxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG4gKiAuZ2V0TGVuZ3RoKClcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcbiAqXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XG4gKlxuICogLS0gMmQgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuU3BsaW5lQ3VydmVcbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqXG4gKiAtLSAzZCBjbGFzc2VzIC0tXG4gKiBUSFJFRS5MaW5lQ3VydmUzXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xuICpcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuLy9cdC0gdCBbMCAuLiAxXVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0Y29uc29sZS5sb2coIFwiV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcblx0cmV0dXJuIG51bGw7XG5cbn07XG5cbi8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuLy8gLSB1IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG5cdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xuXG59O1xuXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG5cdHZhciBkLCBwdHMgPSBbXTtcblxuXHRmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRwdHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0fVxuXG5cdHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuXHR2YXIgZCwgcHRzID0gW107XG5cblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0fVxuXG5cdHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG59O1xuXG4vLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RocyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucykgPyAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyk6IDIwMDtcblxuXHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXG5cdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT0gZGl2aXNpb25zICsgMSApXG5cdFx0JiYgISB0aGlzLm5lZWRzVXBkYXRlKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xuXHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHR9XG5cblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBjYWNoZSA9IFtdO1xuXHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcblx0dmFyIHAsIHN1bSA9IDA7XG5cblx0Y2FjaGUucHVzaCggMCApO1xuXG5cdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuXHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xuXHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcblx0XHRjYWNoZS5wdXNoKCBzdW0gKTtcblx0XHRsYXN0ID0gY3VycmVudDtcblxuXHR9XG5cblx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcblxuXHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cbn07XG5cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLnVwZGF0ZUFyY0xlbmd0aHMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdHRoaXMuZ2V0TGVuZ3RocygpO1xufTtcblxuLy8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpIGRpc3RhbmNlXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRVdG9UbWFwcGluZyA9IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XG5cblx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblxuXHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0dmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XG5cblx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0fVxuXG5cdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cblx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcblxuXHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xuXG5cdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XG5cblx0XHRcdGxvdyA9IGkgKyAxO1xuXHRcdFx0Y29udGludWU7XG5cblx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcblxuXHRcdFx0aGlnaCA9IGkgLSAxO1xuXHRcdFx0Y29udGludWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRoaWdoID0gaTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBET05FXG5cblx0XHR9XG5cblx0fVxuXG5cdGkgPSBoaWdoO1xuXG5cdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcblxuXHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PSB0YXJnZXRBcmNMZW5ndGggKSB7XG5cblx0XHR2YXIgdCA9IGkgLyAoIGlsIC0gMSApO1xuXHRcdHJldHVybiB0O1xuXG5cdH1cblxuXHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0YXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcbiAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcblxuICAgIC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cbiAgICB2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtMSApO1xuXG5cdHJldHVybiB0O1xuXG59O1xuXG4vLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuLy8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciBkZWx0YSA9IDAuMDAwMTtcblx0dmFyIHQxID0gdCAtIGRlbHRhO1xuXHR2YXIgdDIgPSB0ICsgZGVsdGE7XG5cblx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG5cdGlmICggdDEgPCAwICkgdDEgPSAwO1xuXHRpZiAoIHQyID4gMSApIHQyID0gMTtcblxuXHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcblx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0dmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YihwdDEpO1xuXHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcblxufTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZS5VdGlscyA9IHtcblxuXHR0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cblx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcblxuXHR9LFxuXG5cdC8vIFB1YXkgQmluZywgdGhhbmtzIGZvciBoZWxwaW5nIHdpdGggdGhpcyBkZXJpdmF0aXZlIVxuXG5cdHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdFx0cmV0dXJuIC0gMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgICtcblx0XHRcdDMgKiBwMSAqICgxIC0gdCkgKiAoMS10KSAtIDYgKnQgKnAxICogKDEtdCkgK1xuXHRcdFx0NiAqIHQgKiAgcDIgKiAoMS10KSAtIDMgKiB0ICogdCAqIHAyICtcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xuXG5cdH0sXG5cblx0dGFuZ2VudFNwbGluZTogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XG5cblx0XHR2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IFx0Ly8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxuXHRcdHZhciBoMDEgPSAtIDYgKiB0ICogdCArIDYgKiB0OyBcdC8vIOKIkiAydDMgKyAzdDJcblx0XHR2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7XHQvLyB0MyDiiJIgdDJcblxuXHRcdHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XG5cblx0fSxcblxuXHQvLyBDYXRtdWxsLVJvbVxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcblx0XHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHR2YXIgdDMgPSB0ICogdDI7XG5cdFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cblx0fVxuXG59O1xuXG5cbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdDNEIEN1cnZlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XG5cblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmN1cnZlcyA9IFtdO1xuXHR0aGlzLmJlbmRzID0gW107XG5cdFxuXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggY3VydmUgKSB7XG5cblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0Ly8gVE9ET1xuXHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXG5cdC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0Ly8gVE9ETyBUZXN0XG5cdC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXG5cdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApO1xuXHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGgtMV0uZ2V0UG9pbnQoMSk7XG5cdFxuXHRpZiAoISBzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKGVuZFBvaW50LCBzdGFydFBvaW50KSApO1xuXHR9XG5cdFxufTtcblxuLy8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXG4vLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG4vLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cbi8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cbi8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxuLy8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xuXHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcblx0dmFyIGkgPSAwLCBkaWZmLCBjdXJ2ZTtcblxuXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xuXG5cdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHRkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xuXHRcdFx0Y3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHR2YXIgdSA9IDEgLSBkaWZmIC8gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cblx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XG5cblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGkgKys7XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG5cdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG59OyovXG5cblxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuXHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cblx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xuXG5cdH07XG5cblx0Ly8gR2V0IGxlbmd0aCBvZiBzdWJzdXJ2ZVxuXHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuXHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcblx0dmFyIGksIGlsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XG5cdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0fVxuXG5cdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcblxuXHRyZXR1cm4gbGVuZ3RocztcblxufTtcblxuXG5cbi8vIFJldHVybnMgbWluIGFuZCBtYXggY29vcmRpbmF0ZXNcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcblxuXHR2YXIgbWF4WCwgbWF4WSwgbWF4Wjtcblx0dmFyIG1pblgsIG1pblksIG1pblo7XG5cblx0bWF4WCA9IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cdG1pblggPSBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdHZhciBwLCBpLCBpbCwgc3VtO1xuXG5cdHZhciB2MyA9IHBvaW50c1swXSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjM7XG5cblx0c3VtID0gdjMgPyBuZXcgVEhSRUUuVmVjdG9yMygpIDogbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gcG9pbnRzWyBpIF07XG5cblx0XHRpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xuXHRcdGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcblxuXHRcdGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XG5cdFx0ZWxzZSBpZiAoIHAueSA8IG1pblkgKSBtaW5ZID0gcC55O1xuXG5cdFx0aWYgKCB2MyApIHtcblxuXHRcdFx0aWYgKCBwLnogPiBtYXhaICkgbWF4WiA9IHAuejtcblx0XHRcdGVsc2UgaWYgKCBwLnogPCBtaW5aICkgbWluWiA9IHAuejtcblxuXHRcdH1cblxuXHRcdHN1bS5hZGQoIHAgKTtcblxuXHR9XG5cblx0dmFyIHJldCA9IHtcblxuXHRcdG1pblg6IG1pblgsXG5cdFx0bWluWTogbWluWSxcblx0XHRtYXhYOiBtYXhYLFxuXHRcdG1heFk6IG1heFlcblxuXHR9O1xuXG5cdGlmICggdjMgKSB7XG5cblx0XHRyZXQubWF4WiA9IG1heFo7XG5cdFx0cmV0Lm1pblogPSBtaW5aO1xuXG5cdH1cblxuXHRyZXR1cm4gcmV0O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cblx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG4vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW5jZSBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuXHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSwgcG9pbnRzWyBpIF0ueiB8fCAwKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0QmVuZCAvIFdyYXAgSGVscGVyIE1ldGhvZHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gV3JhcCBwYXRoIC8gQmVuZCBtb2RpZmllcnM/XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGggPSBmdW5jdGlvbiAoIGJlbmRwYXRoICkge1xuXG5cdHRoaXMuYmVuZHMucHVzaCggYmVuZHBhdGggKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBzZWdtZW50cyApOyAvLyBnZXRQb2ludHMgZ2V0U3BhY2VkUG9pbnRzXG5cdHZhciBpLCBpbDtcblxuXHRpZiAoICEgYmVuZHMgKSB7XG5cblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XG5cblx0fVxuXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBzZWdtZW50cyApO1xuXG5cdHZhciBpLCBpbDtcblxuXHRpZiAoICEgYmVuZHMgKSB7XG5cblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XG5cblx0fVxuXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uICggb2xkUHRzLCBwYXRoICkge1xuXG5cdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cblx0dmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gb2xkUHRzWyBpIF07XG5cblx0XHRvbGRYID0gcC54O1xuXHRcdG9sZFkgPSBwLnk7XG5cblx0XHR4Tm9ybSA9IG9sZFggLyBib3VuZHMubWF4WDtcblxuXHRcdC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xuXHRcdC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxuXG5cdFx0eE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xuXG5cdFx0Ly8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cblx0XHR2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcblx0XHR2YXIgbm9ybWFsID0gcGF0aC5nZXRUYW5nZW50KCB4Tm9ybSApO1xuXHRcdG5vcm1hbC5zZXQoIC0gbm9ybWFsLnksIG5vcm1hbC54ICkubXVsdGlwbHlTY2FsYXIoIG9sZFkgKTtcblxuXHRcdHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XG5cdFx0cC55ID0gcGF0aFB0LnkgKyBub3JtYWwueTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9HeXJvc2NvcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkd5cm9zY29wZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbn07XG5cblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciB0cmFuc2xhdGlvbk9iamVjdCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBxdWF0ZXJuaW9uT2JqZWN0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0dmFyIHNjYWxlT2JqZWN0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgdHJhbnNsYXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBxdWF0ZXJuaW9uV29ybGQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHR2YXIgc2NhbGVXb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgJiYgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggdHJhbnNsYXRpb25Xb3JsZCwgcXVhdGVybmlvbldvcmxkLCBzY2FsZVdvcmxkICk7XG5cdFx0XHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdHJhbnNsYXRpb25PYmplY3QsIHF1YXRlcm5pb25PYmplY3QsIHNjYWxlT2JqZWN0ICk7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb21wb3NlKCB0cmFuc2xhdGlvbldvcmxkLCBxdWF0ZXJuaW9uT2JqZWN0LCBzY2FsZVdvcmxkICk7XG5cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdH1cblxuXHR9O1xuXHRcbn0oKSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9QYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXG4gKlxuICoqL1xuXG5USFJFRS5QYXRoID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0VEhSRUUuQ3VydmVQYXRoLmNhbGwodGhpcyk7XG5cblx0dGhpcy5hY3Rpb25zID0gW107XG5cblx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XG5cblRIUkVFLlBhdGhBY3Rpb25zID0ge1xuXG5cdE1PVkVfVE86ICdtb3ZlVG8nLFxuXHRMSU5FX1RPOiAnbGluZVRvJyxcblx0UVVBRFJBVElDX0NVUlZFX1RPOiAncXVhZHJhdGljQ3VydmVUbycsIC8vIEJlemllciBxdWFkcmF0aWMgY3VydmVcblx0QkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsIFx0XHQvLyBCZXppZXIgY3ViaWMgY3VydmVcblx0Q1NQTElORV9USFJVOiAnc3BsaW5lVGhydScsXHRcdFx0XHQvLyBDYXRtdWxsLXJvbSBzcGxpbmVcblx0QVJDOiAnYXJjJyxcdFx0XHRcdFx0XHRcdFx0Ly8gQ2lyY2xlXG5cdEVMTElQU0U6ICdlbGxpcHNlJ1xufTtcblxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxuXG4vLyBDcmVhdGUgcGF0aCB1c2luZyBzdHJhaWdodCBsaW5lcyB0byBjb25uZWN0IGFsbCBwb2ludHNcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG5cdHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcblxuXHRmb3IgKCB2YXIgdiA9IDEsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDsgdiA8IHZsZW47IHYgKysgKSB7XG5cblx0XHR0aGlzLmxpbmVUbyggdmVjdG9yc1sgdiBdLngsIHZlY3RvcnNbIHYgXS55ICk7XG5cblx0fTtcblxufTtcblxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5MaW5lQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSwgbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTElORV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgICBhQ1AyeCwgYUNQMnksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgYVgsIGFZICkge1xuXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcbi8vLS0tXG5cdHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcblx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xuXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHR0aGlzLmFic2FyYyhhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxuXHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuIH07XG5cbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdCAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblx0dGhpcy5hYnNlbGxpcHNlKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG4gfTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0ICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDFdLmFyZ3M7XG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dGhpcy5hYnNlbGxpcHNlKGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG4gfTtcblxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNlbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoMSk7XG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueCk7XG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueSk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFLCBhcmdzOiBhcmdzIH0gKTtcblxuIH07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xuXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcblxuXHR2YXIgcG9pbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xuXG5cdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0Ly9pZiggIXRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApIHRocm93IFwiRElFXCI7XG5cblx0fVxuXG5cdC8vIGlmICggY2xvc2VkUGF0aCApIHtcblx0Ly9cblx0Ly8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblx0Ly9cblx0Ly8gfVxuXG5cdHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuXHRpZiAodGhpcy51c2VTcGFjZWRQb2ludHMpIHtcblx0XHRjb25zb2xlLmxvZygndGF0YScpO1xuXHRcdHJldHVybiB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCBjbG9zZWRQYXRoICk7XG5cdH1cblxuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XG5cblx0dmFyIHBvaW50cyA9IFtdO1xuXG5cdHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuXHR2YXIgY3B4LCBjcHksIGNweDIsIGNweTIsIGNweDEsIGNweTEsIGNweDAsIGNweTAsXG5cdFx0bGFzdGUsIGosXG5cdFx0dCwgdHgsIHR5O1xuXG5cdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcblxuXHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXHRcdGFyZ3MgPSBpdGVtLmFyZ3M7XG5cblx0XHRzd2l0Y2goIGFjdGlvbiApIHtcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcblxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxuXG5cdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcblxuXHRcdFx0Y3B4ICA9IGFyZ3NbIDIgXTtcblx0XHRcdGNweSAgPSBhcmdzWyAzIF07XG5cblx0XHRcdGNweDEgPSBhcmdzWyAwIF07XG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dCA9IGogLyBkaXZpc2lvbnM7XG5cblx0XHRcdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG5cdFx0XHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPOlxuXG5cdFx0XHRjcHggID0gYXJnc1sgNCBdO1xuXHRcdFx0Y3B5ICA9IGFyZ3NbIDUgXTtcblxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcblx0XHRcdGNweTEgPSBhcmdzWyAxIF07XG5cblx0XHRcdGNweDIgPSBhcmdzWyAyIF07XG5cdFx0XHRjcHkyID0gYXJnc1sgMyBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcblxuXHRcdFx0XHR0ID0gaiAvIGRpdmlzaW9ucztcblxuXHRcdFx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcblx0XHRcdFx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlU6XG5cblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cblx0XHRcdHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcblx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XG5cblx0XHRcdHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcblxuXHRcdFx0c3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcblxuXHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBuOyBqICsrICkge1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApIDtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQVJDOlxuXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuXHRcdFx0XHRhUmFkaXVzID0gYXJnc1sgMiBdLFxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISEgYXJnc1sgNSBdO1xuXG5cdFx0XHR2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGFuZ2xlO1xuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdHQgPSBqIC8gdGRpdmlzaW9ucztcblxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcblxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG5cdFx0XHRcdHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0XHRcdHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cblx0XHQgIGJyZWFrO1xuXHRcdCAgXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFOlxuXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuXHRcdFx0XHR4UmFkaXVzID0gYXJnc1sgMiBdLFxuXHRcdFx0XHR5UmFkaXVzID0gYXJnc1sgMyBdLFxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISEgYXJnc1sgNiBdO1xuXG5cblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgYW5nbGU7XG5cdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dCA9IGogLyB0ZGl2aXNpb25zO1xuXG5cdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xuXG5cdFx0XHRcdFx0dCA9IDEgLSB0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cblx0XHRcdFx0dHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRcdFx0dHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuXHRcdCAgYnJlYWs7XG5cblx0XHR9IC8vIGVuZCBzd2l0Y2hcblxuXHR9XG5cblxuXG5cdC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cblx0dmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDFdO1xuXHR2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblx0aWYgKCBNYXRoLmFicyhsYXN0UG9pbnQueCAtIHBvaW50c1sgMCBdLngpIDwgRVBTSUxPTiAmJlxuXHRcdFx0IE1hdGguYWJzKGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSkgPCBFUFNJTE9OKVxuXHRcdHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxKTtcblx0aWYgKCBjbG9zZWRQYXRoICkge1xuXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0fVxuXG5cdHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8vXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xuLy9cbi8vXHRBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcbi8vXHQtIGhvbGVzIGFyZSBkZWZpbmVkIGNvdW50ZXJjbG9ja3dpc2UgKENDVylcbi8vXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XG4vLyAgLSBhbGwgc3ViUGF0aHMgYXJlIHJlZ2FyZGVkIGFzIHNvbGlkIHNoYXBlc1xuLy8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxuLy9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1csIG5vSG9sZXMgKSB7XG5cblx0ZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XG5cblx0XHR2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcblxuXHRcdHZhciBzdWJQYXRocyA9IFtdLCBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBpbkFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcblxuXHRcdFx0YXJncyA9IGl0ZW0uYXJncztcblx0XHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG5cdFx0XHRpZiAoIGFjdGlvbiA9PSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPICkge1xuXG5cdFx0XHRcdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT0gMCApIHtcblxuXHRcdFx0XHRcdHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cdFx0XHRcdFx0bGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9IDAgKSB7XG5cblx0XHRcdHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb25zb2xlLmxvZyhzdWJQYXRocyk7XG5cblx0XHRyZXR1cm5cdHN1YlBhdGhzO1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG5cdFx0dmFyIHNoYXBlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG5cdFx0XHR2YXIgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcblx0XHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XG5cdFx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cblx0XHR2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XG5cblx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuXHRcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2Vcblx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG5cdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcblx0XHR2YXIgaW5zaWRlID0gZmFsc2U7XG5cdFx0Zm9yKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuXHRcdFx0dmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcblx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cblx0XHRcdHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcblx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyhlZGdlRHkpID4gRVBTSUxPTiApIHtcdFx0XHQvLyBub3QgcGFyYWxsZWxcblx0XHRcdFx0aWYgKCBlZGdlRHkgPCAwICkge1xuXHRcdFx0XHRcdGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XG5cdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggaW5QdC55ID09IGVkZ2VMb3dQdC55ICkge1xuXHRcdFx0XHRcdGlmICggaW5QdC54ID09IGVkZ2VMb3dQdC54IClcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqIChpblB0LnggLSBlZGdlTG93UHQueCkgLSBlZGdlRHggKiAoaW5QdC55IC0gZWRnZUxvd1B0LnkpO1xuXHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcdFx0Ly8gcGFyYWxsZWwgb3IgY29saW5lYXJcblx0XHRcdFx0aWYgKCBpblB0LnkgIT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcblx0XHRcdFx0Ly8gZWdkZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG5cdFx0XHRcdGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcblx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0Ly8gY29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuXHRpbnNpZGU7XG5cdH1cblxuXG5cdHZhciBzdWJQYXRocyA9IGV4dHJhY3RTdWJwYXRocyggdGhpcy5hY3Rpb25zICk7XG5cdGlmICggc3ViUGF0aHMubGVuZ3RoID09IDAgKSByZXR1cm4gW107XG5cblx0aWYgKCBub0hvbGVzID09PSB0cnVlIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT0gMSkge1xuXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWzBdO1xuXHRcdHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG5cdFx0dG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcblx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH1cblxuXHR2YXIgaG9sZXNGaXJzdCA9ICEgVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcblx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuXHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXHRcblx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcblx0dmFyIG5ld1NoYXBlcyA9IFtdO1xuXHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuXHR2YXIgbWFpbklkeCA9IDA7XG5cdHZhciB0bXBQb2ludHM7XG5cblx0bmV3U2hhcGVzW21haW5JZHhdID0gdW5kZWZpbmVkO1xuXHRuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XG5cblx0dmFyIGksIGlsO1xuXG5cdGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XG5cdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcblx0XHRzb2xpZCA9IFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcblx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xuXG5cdFx0aWYgKCBzb2xpZCApIHtcblxuXHRcdFx0aWYgKCAoISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbbWFpbklkeF0gKSApXHRtYWluSWR4ICsrO1xuXG5cdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0gPSB7IHM6IG5ldyBUSFJFRS5TaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcblx0XHRcdG5ld1NoYXBlc1ttYWluSWR4XS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRcdFxuXHRcdFx0aWYgKCBob2xlc0ZpcnN0IClcdG1haW5JZHggKys7XG5cdFx0XHRuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRuZXdTaGFwZUhvbGVzW21haW5JZHhdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWzBdIH0gKTtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXHRpZiAoICEgbmV3U2hhcGVzWzBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblx0XHR2YXIgYW1iaWdpb3VzID0gZmFsc2U7XG5cdFx0dmFyIHRvQ2hhbmdlID0gW107XG5cblx0XHRmb3IgKHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXHRcdFx0YmV0dGVyU2hhcGVIb2xlc1tzSWR4XSA9IFtdO1xuXHRcdH1cblx0XHRmb3IgKHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXHRcdFx0dmFyIHNoID0gbmV3U2hhcGVzW3NJZHhdO1xuXHRcdFx0dmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbc0lkeF07XG5cdFx0XHRmb3IgKHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XG5cdFx0XHRcdHZhciBobyA9IHNob1toSWR4XTtcblx0XHRcdFx0dmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG5cdFx0XHRcdGZvciAodmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcblx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbczJJZHhdLnAgKSApIHtcblx0XHRcdFx0XHRcdGlmICggc0lkeCAhPSBzMklkeCApXHRcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuXHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3MySWR4XS5wdXNoKCBobyApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YW1iaWdpb3VzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7IGJldHRlclNoYXBlSG9sZXNbc0lkeF0ucHVzaCggaG8gKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlnaW91czogXCIsIGFtYmlnaW91cyk7XG5cdFx0aWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG5cdFx0XHRpZiAoISBhbWJpZ2lvdXMpXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblx0XHR9XG5cdH1cblxuXHR2YXIgdG1wSG9sZXMsIGosIGpsO1xuXHRmb3IgKCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbaV0ucztcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHR0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbaV07XG5cdFx0Zm9yICggaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1tqXS5oICk7XG5cdFx0fVxuXHR9XG5cblx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0cmV0dXJuIHNoYXBlcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR0aGlzLmhvbGVzID0gW107XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gRXh0cnVkZUdlb21ldHJ5XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG5cdHZhciBleHRydWRlZCA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblx0cmV0dXJuIGV4dHJ1ZGVkO1xuXG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIFNoYXBlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuXHRyZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEdldCBwb2ludHMgb2YgaG9sZXNcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0dmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsIGhvbGVzUHRzID0gW107XG5cblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xuXG5cdH1cblxuXHRyZXR1cm4gaG9sZXNQdHM7XG5cbn07XG5cbi8vIEdldCBwb2ludHMgb2YgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHR2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCwgaG9sZXNQdHMgPSBbXTtcblxuXHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XG5cblx0fVxuXG5cdHJldHVybiBob2xlc1B0cztcblxufTtcblxuXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRyZXR1cm4ge1xuXG5cdFx0c2hhcGU6IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucyApLFxuXHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG5cdH07XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0aWYgKHRoaXMudXNlU3BhY2VkUG9pbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyhkaXZpc2lvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyhkaXZpc2lvbnMpO1xuXG59O1xuXG4vL1xuLy8gVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHNXaXRoQmVuZCA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBiZW5kICkge1xuLy9cbi8vIFx0cmV0dXJuIHtcbi8vXG4vLyBcdFx0c2hhcGU6IHRoaXMudHJhbnNmb3JtKCBiZW5kLCBkaXZpc2lvbnMgKSxcbi8vIFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcbi8vXG4vLyBcdH07XG4vL1xuLy8gfTtcblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdHJldHVybiB7XG5cblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXG5cdFx0aG9sZXM6IHRoaXMuZ2V0U3BhY2VkUG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cblx0fTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0VXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU2hhcGUuVXRpbHMgPSB7XG5cblx0dHJpYW5ndWxhdGVTaGFwZTogZnVuY3Rpb24gKCBjb250b3VyLCBob2xlcyApIHtcblxuXHRcdGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xuXHRcdFx0Ly8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcblx0XHRcdGlmICggaW5TZWdQdDEueCAhPSBpblNlZ1B0Mi54ICkge1xuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQyLnggKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluRXhjbHVkZUFkamFjZW50U2VncyApIHtcblx0XHRcdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG5cdFx0XHR2YXIgc2VnMWR4ID0gaW5TZWcxUHQyLnggLSBpblNlZzFQdDEueCwgICBzZWcxZHkgPSBpblNlZzFQdDIueSAtIGluU2VnMVB0MS55O1xuXHRcdFx0dmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcblxuXHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xuXHRcdFx0dmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xuXG5cdFx0XHR2YXIgbGltaXRcdFx0PSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG5cdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMobGltaXQpID4gRVBTSUxPTiApIHtcdFx0XHQvLyBub3QgcGFyYWxsZWxcblxuXHRcdFx0XHR2YXIgcGVycFNlZzI7XG5cdFx0XHRcdGlmICggbGltaXQgPiAwICkge1xuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XG5cdFx0XHRcdGlmICggcGVycFNlZzIgPT0gMCApIHtcblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcblx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT0gMCApIHx8ICggcGVycFNlZzEgPT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdHJldHVybiAgWyBpblNlZzFQdDEgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHBlcnBTZWcyID09IGxpbWl0ICkge1xuXHRcdFx0XHRcdGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PSAwICkgfHwgKCBwZXJwU2VnMSA9PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cmV0dXJuICBbIGluU2VnMVB0MiBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT0gMCApXHRcdHJldHVybiAgWyBpblNlZzJQdDEgXTtcblx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PSBsaW1pdCApXHRyZXR1cm4gIFsgaW5TZWcyUHQyIF07XG5cblx0XHRcdFx0Ly8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XG5cdFx0XHRcdHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcblx0XHRcdFx0cmV0dXJuXHRbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxuXHRcdFx0XHRcdFx0XHR5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xuXG5cdFx0XHR9IGVsc2Uge1x0XHQvLyBwYXJhbGxlbCBvciBjb2xpbmVhclxuXHRcdFx0XHRpZiAoICggcGVycFNlZzEgIT0gMCApIHx8XG5cdFx0XHRcdFx0ICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSBcdFx0XHRyZXR1cm4gW107XG5cblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIG9yIGRlZ2VuZXJhdGVcblx0XHRcdFx0dmFyIHNlZzFQdCA9ICggKHNlZzFkeCA9PSAwKSAmJiAoc2VnMWR5ID09IDApICk7XHQvLyBzZWdtZW50MSBpc3QganVzdCBhIHBvaW50P1xuXHRcdFx0XHR2YXIgc2VnMlB0ID0gKCAoc2VnMmR4ID09IDApICYmIChzZWcyZHkgPT0gMCkgKTtcdC8vIHNlZ21lbnQyIGlzdCBqdXN0IGEgcG9pbnQ/XG5cdFx0XHRcdC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xuXHRcdFx0XHRpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XG5cdFx0XHRcdFx0aWYgKCAoaW5TZWcxUHQxLnggIT0gaW5TZWcyUHQxLngpIHx8XG5cdFx0XHRcdFx0XHQgKGluU2VnMVB0MS55ICE9IGluU2VnMlB0MS55KSApXHRcdHJldHVybiBbXTsgICBcdC8vIHRoZXkgYXJlIGRpc3RpbmN0ICBwb2ludHNcblx0XHRcdFx0XHRyZXR1cm4gIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICBcdFx0XHRcdFx0Ly8gdGhleSBhcmUgdGhlIHNhbWUgcG9pbnRcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdGlmICggc2VnMVB0ICkge1xuXHRcdFx0XHRcdGlmICghIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcblx0XHRcdFx0XHRyZXR1cm4gIFsgaW5TZWcxUHQxIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxuXHRcdFx0XHRpZiAoIHNlZzJQdCApIHtcblx0XHRcdFx0XHRpZiAoISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXG5cdFx0XHRcdFx0cmV0dXJuICBbIGluU2VnMlB0MSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXG5cdFx0XHRcdHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xuXHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcblx0XHRcdFx0aWYgKHNlZzFkeCAhPSAwKSB7XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDwgIHNlZzJtaW5WYWwgKVx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PSBzZWcybWluVmFsIClcdHtcblx0XHRcdFx0XHRcdGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMm1pbiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XG5cdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzJtaW4sIHNlZzJtYXggXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPiAgc2VnMm1heFZhbCApXHRyZXR1cm4gW107XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID09IHNlZzJtYXhWYWwgKVx0e1xuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcxbWluIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcblx0XHRcdFx0XHRyZXR1cm5cdFsgc2VnMW1pbiwgc2VnMm1heCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xuXHRcdFx0Ly8gVGhlIG9yZGVyIG9mIGxlZ3MgaXMgaW1wb3J0YW50XG5cblx0XHRcdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG5cdFx0XHQvLyB0cmFuc2xhdGlvbiBvZiBhbGwgcG9pbnRzLCBzbyB0aGF0IFZlcnRleCBpcyBhdCAoMCwwKVxuXHRcdFx0dmFyIGxlZ0Zyb21QdFhcdD0gaW5MZWdGcm9tUHQueCAtIGluVmVydGV4LngsICBsZWdGcm9tUHRZXHQ9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuXHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XG5cdFx0XHR2YXIgb3RoZXJQdFhcdD0gaW5PdGhlclB0LnhcdC0gaW5WZXJ0ZXgueCwgIG90aGVyUHRZXHRcdD0gaW5PdGhlclB0LnlcdC0gaW5WZXJ0ZXgueTtcblxuXHRcdFx0Ly8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG5cdFx0XHR2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcblx0XHRcdHZhciBmcm9tMm90aGVyQW5nbGVcdD0gbGVnRnJvbVB0WCAqIG90aGVyUHRZIC0gbGVnRnJvbVB0WSAqIG90aGVyUHRYO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKGZyb20ydG9BbmdsZSkgPiBFUFNJTE9OICkge1x0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXG5cblx0XHRcdFx0dmFyIG90aGVyMnRvQW5nbGVcdFx0PSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG5cdFx0XHRcdGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcdFx0XHRcdC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZ2xlID09IDE4MCBkZWcuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcblx0XHRcdFx0cmV0dXJuXHQoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcblxuXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG5cdFx0XHR2YXIgaG9sZTtcblxuXHRcdFx0ZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XG5cdFx0XHRcdC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XG5cdFx0XHRcdHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcblx0XHRcdFx0aWYgKCBwcmV2U2hhcGVJZHggPCAwIClcdFx0XHRwcmV2U2hhcGVJZHggPSBsYXN0U2hhcGVJZHg7XG5cblx0XHRcdFx0dmFyIG5leHRTaGFwZUlkeCA9IGluU2hhcGVJZHggKyAxO1xuXHRcdFx0XHRpZiAoIG5leHRTaGFwZUlkeCA+IGxhc3RTaGFwZUlkeCApXHRuZXh0U2hhcGVJZHggPSAwO1xuXG5cdFx0XHRcdHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbaW5TaGFwZUlkeF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlW2luSG9sZUlkeF0gKTtcblx0XHRcdFx0aWYgKCEgaW5zaWRlQW5nbGUgKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChTaGFwZSk6IFwiICsgaW5TaGFwZUlkeCArIFwiLCBQb2ludDogXCIgKyBob2xlW2luSG9sZUlkeF0ueCArIFwiL1wiICsgaG9sZVtpbkhvbGVJZHhdLnkgKTtcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgc2hhcGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIGhvbGUgcG9pbnRcblx0XHRcdFx0dmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdHZhciBwcmV2SG9sZUlkeCA9IGluSG9sZUlkeCAtIDE7XG5cdFx0XHRcdGlmICggcHJldkhvbGVJZHggPCAwIClcdFx0XHRwcmV2SG9sZUlkeCA9IGxhc3RIb2xlSWR4O1xuXG5cdFx0XHRcdHZhciBuZXh0SG9sZUlkeCA9IGluSG9sZUlkeCArIDE7XG5cdFx0XHRcdGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApXHRuZXh0SG9sZUlkeCA9IDA7XG5cblx0XHRcdFx0aW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIGhvbGVbaW5Ib2xlSWR4XSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbaW5TaGFwZUlkeF0gKTtcblx0XHRcdFx0aWYgKCEgaW5zaWRlQW5nbGUgKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm5cdHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXG5cdFx0XHRcdHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGZvciAoIHNJZHggPSAwOyBzSWR4IDwgc2hhcGUubGVuZ3RoOyBzSWR4ICsrICkge1xuXHRcdFx0XHRcdG5leHRJZHggPSBzSWR4KzE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbc0lkeF0sIHNoYXBlW25leHRJZHhdLCB0cnVlICk7XG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRlcEhvbGVzID0gW107XG5cblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcblx0XHRcdFx0Ly8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xuXHRcdFx0XHR2YXIgaWhJZHgsIGNoa0hvbGUsXG5cdFx0XHRcdFx0aElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRmb3IgKCBpaElkeCA9IDA7IGloSWR4IDwgaW5kZXBIb2xlcy5sZW5ndGg7IGloSWR4ICsrICkge1xuXHRcdFx0XHRcdGNoa0hvbGUgPSBob2xlc1tpbmRlcEhvbGVzW2loSWR4XV07XG5cdFx0XHRcdFx0Zm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcblx0XHRcdFx0XHRcdG5leHRJZHggPSBoSWR4KzE7IG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbaElkeF0sIGNoa0hvbGVbbmV4dElkeF0sIHRydWUgKTtcblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG5cdFx0XHRcdHNoYXBlUHQsIGhvbGVQdCxcblx0XHRcdFx0aG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXG5cdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuXHRcdFx0XHR0bXBIb2xlMSwgdG1wSG9sZTI7XG5cblx0XHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWluU2hhcGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcblx0XHRcdHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRjb3VudGVyIC0tO1xuXHRcdFx0XHRpZiAoIGNvdW50ZXIgPCAwICkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlYXJjaCBmb3Igc2hhcGUtdmVydGV4IGFuZCBob2xlLXZlcnRleCxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcblx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XG5cblx0XHRcdFx0XHRzaGFwZVB0ID0gc2hhcGVbIHNoYXBlSW5kZXggXTtcblx0XHRcdFx0XHRob2xlSW5kZXhcdD0gLSAxO1xuXG5cdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBob2xlIHdoaWNoIGNhbiBiZSByZWFjaGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoICsrICkge1xuXHRcdFx0XHRcdFx0aG9sZUlkeCA9IGluZGVwSG9sZXNbaF07XG5cblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXG5cdFx0XHRcdFx0XHRjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcblx0XHRcdFx0XHRcdGlmICggZmFpbGVkQ3V0c1tjdXRLZXldICE9PSB1bmRlZmluZWQgKVx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRob2xlID0gaG9sZXNbaG9sZUlkeF07XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcblx0XHRcdFx0XHRcdFx0aG9sZVB0ID0gaG9sZVsgaDIgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCEgaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBzaGFwZUluZGV4LCBoMiApIClcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c1NoYXBlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKVx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0aG9sZUluZGV4ID0gaDI7XG5cdFx0XHRcdFx0XHRcdGluZGVwSG9sZXMuc3BsaWNlKGgsMSk7XG5cblx0XHRcdFx0XHRcdFx0dG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXgrMSApO1xuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCsxICk7XG5cblx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG5cdFx0XHRcdFx0XHRcdG1pblNoYXBlSW5kZXggPSBzaGFwZUluZGV4O1xuXG5cdFx0XHRcdFx0XHRcdC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcblx0XHRcdFx0XHRcdFx0Ly8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGhvbGVJbmRleCA+PSAwIClcdGJyZWFrO1x0XHQvLyBob2xlLXZlcnRleCBmb3VuZFxuXG5cdFx0XHRcdFx0XHRmYWlsZWRDdXRzW2N1dEtleV0gPSB0cnVlO1x0XHRcdC8vIHJlbWVtYmVyIGZhaWx1cmVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2hhcGU7IFx0XHRcdC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cblx0XHR9XG5cblxuXHRcdHZhciBpLCBpbCwgZiwgZmFjZSxcblx0XHRcdGtleSwgaW5kZXgsXG5cdFx0XHRhbGxQb2ludHNNYXAgPSB7fTtcblxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuXHRcdHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG5cdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1toXSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJhbGxwb2ludHNcIixhbGxwb2ludHMsIGFsbHBvaW50cy5sZW5ndGggKTtcblxuXHRcdC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0a2V5ID0gYWxscG9pbnRzWyBpIF0ueCArIFwiOlwiICsgYWxscG9pbnRzWyBpIF0ueTtcblxuXHRcdFx0aWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coIFwiRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxuXHRcdHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xuXG5cdFx0dmFyIHRyaWFuZ2xlcyA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XG5cblx0XHQvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xuXG5cdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcblxuXHRcdFx0XHRpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xuXG5cdH0sXG5cblx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xuXG5cdFx0cmV0dXJuIFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBwdHMgKSA8IDA7XG5cblx0fSxcblxuXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuXG5cdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG5cdGIycDA6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIGsgKiBrICogcDtcblxuXHR9LFxuXG5cdGIycDE6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cblx0fSxcblxuXHRiMnAyOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHRyZXR1cm4gdCAqIHQgKiBwO1xuXG5cdH0sXG5cblx0YjI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcblxuXHRcdHJldHVybiB0aGlzLmIycDAoIHQsIHAwICkgKyB0aGlzLmIycDEoIHQsIHAxICkgKyB0aGlzLmIycDIoIHQsIHAyICk7XG5cblx0fSxcblxuXHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cblx0YjNwMDogZnVuY3Rpb24gKCB0LCBwICkge1xuXG5cdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcblxuXHR9LFxuXG5cdGIzcDE6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG5cdH0sXG5cblx0YjNwMjogZnVuY3Rpb24gKCB0LCBwICkge1xuXG5cdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cblx0fSxcblxuXHRiM3AzOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuXHR9LFxuXG5cdGIzOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYjNwMCggdCwgcDAgKSArIHRoaXMuYjNwMSggdCwgcDEgKSArIHRoaXMuYjNwMiggdCwgcDIgKSArICB0aGlzLmIzcDMoIHQsIHAzICk7XG5cblx0fVxuXG59O1xuXG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlID0gZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKHRoaXMudjEpO1xuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG5cdHJldHVybiBwb2ludDtcblxufTtcblxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XG5cblx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHR2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG5cdHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblxuXHRyZXR1cm4gdmVjdG9yO1xuXG59O1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG5cdHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG5cdC8vIHJldHVybnMgdW5pdCB2ZWN0b3JcblxuXHRyZXR1cm4gdmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cdHRoaXMudjMgPSB2MztcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHR4LCB0eTtcblxuXHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcblx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciB0eCwgdHk7XG5cblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuXHR0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cblx0dmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG5cdHRhbmdlbnQubm9ybWFsaXplKCk7XG5cblx0cmV0dXJuIHRhbmdlbnQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0U3BsaW5lIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcblxuXHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbn07XG5cblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdXG5cdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF1cblx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLTEgOiBpbnRQb2ludCArIDEgXVxuXHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtMSA6IGludFBvaW50ICsgMiBdXG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuXHR2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cblx0cmV0dXJuIHZlY3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0RWxsaXBzZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5FbGxpcHNlQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuXHR0aGlzLmFYID0gYVg7XG5cdHRoaXMuYVkgPSBhWTtcblxuXHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXHR0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xuXG5cdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcblx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cblx0dGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZTtcblxufTtcblxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXG5cdGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xuXHRpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XG5cblx0dmFyIGFuZ2xlO1xuXG5cdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xuXG5cdFx0YW5nbGUgPSB0aGlzLmFFbmRBbmdsZSArICggMSAtIHQgKSAqICggTWF0aC5QSSAqIDIgLSBkZWx0YUFuZ2xlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG5cdH1cblx0XG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZlY3Rvci54ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHR2ZWN0b3IueSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRyZXR1cm4gdmVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcbn07XG5cblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmUzRFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmVjdG9yLnN1YlZlY3RvcnMoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxuXHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xuXHRcdHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcblxuXHRcdHJldHVybiB2ZWN0b3I7XG5cblx0fVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuXHRcdHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblx0XHR2ZWN0b3IueiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56ICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdWJpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG5cdFx0dmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cdFx0dmVjdG9yLnogPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56ICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0U3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8pIHtcblxuXHRcdHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuXHRcdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG5cdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcblx0XHR2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cdFx0dmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG5cdFx0cmV0dXJuIHZlY3RvcjtcblxuXHR9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xuXG5cdFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG5cdH0sXG5cblx0ZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDAgKSAqIHQ7IC8vIFRoaXMgbmVlZHMgdG8gYmUgZnJvbSAwLWxlbmd0aCArMVxuXG5cdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcblxuXHRcdHZhciBwb2ludDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBwb2ludHMubGVuZ3RoIF07XG5cdFx0dmFyIHBvaW50MSA9IHBvaW50c1sgKCBpbnRQb2ludCAgICAgKSAlIHBvaW50cy5sZW5ndGggXTtcblx0XHR2YXIgcG9pbnQyID0gcG9pbnRzWyAoIGludFBvaW50ICsgMSApICUgcG9pbnRzLmxlbmd0aCBdO1xuXHRcdHZhciBwb2ludDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBwb2ludHMubGVuZ3RoIF07XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcblx0XHR2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cdFx0dmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG5cdFx0cmV0dXJuIHZlY3RvcjtcblxuXHR9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uSGFuZGxlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuVEhSRUUuQW5pbWF0aW9uSGFuZGxlciA9IHtcblxuXHRMSU5FQVI6IDAsXG5cdENBVE1VTExST006IDEsXG5cdENBVE1VTExST01fRk9SV0FSRDogMixcblxuXHQvL1xuXG5cdGFkZDogZnVuY3Rpb24gKCkgeyBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApOyB9LFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTsgfSxcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7IGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7IH0sXG5cblx0Ly9cblxuXHRhbmltYXRpb25zOiBbXSxcblxuXHRpbml0OiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuaW5pdGlhbGl6ZWQgPT09IHRydWUgKSByZXR1cm47XG5cblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGtleXNcblxuXHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApIHtcblxuXHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHQvLyByZW1vdmUgbWludXMgdGltZXNcblxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPCAwICkge1xuXG5cdFx0XHRcdFx0IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgcXVhdGVybmlvbnNcblxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdCAgISAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCBpbnN0YW5jZW9mIFRIUkVFLlF1YXRlcm5pb24gKSApIHtcblxuXHRcdFx0XHRcdHZhciBxdWF0ID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90O1xuXHRcdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCBxdWF0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZXBhcmUgbW9ycGggdGFyZ2V0IGtleXNcblxuXHRcdFx0aWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoICYmIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGdldCBhbGwgdXNlZFxuXG5cdFx0XHRcdHZhciB1c2VkTW9ycGhUYXJnZXRzID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldE5hbWUgPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXTtcblx0XHRcdFx0XHRcdHVzZWRNb3JwaFRhcmdldHNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gLSAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLnVzZWRNb3JwaFRhcmdldHMgPSB1c2VkTW9ycGhUYXJnZXRzO1xuXG5cblx0XHRcdFx0Ly8gc2V0IGFsbCB1c2VkIG9uIGFsbCBmcmFtZXNcblxuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZmx1ZW5jZXMgPSB7fTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gdXNlZE1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdID09PSBtb3JwaFRhcmdldE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBtID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gMDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcyA9IGluZmx1ZW5jZXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCBrZXlzIHRoYXQgYXJlIG9uIHRoZSBzYW1lIHRpbWVcblxuXHRcdFx0Zm9yICggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayAtIDEgXS50aW1lICkge1xuXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLnNwbGljZSggaywgMSApO1xuXHRcdFx0XHRcdGsgLS07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gc2V0IGluZGV4XG5cblx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0uaW5kZXggPSBrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRkYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggcm9vdCApIHtcblxuXHRcdHZhciBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkgPSBmdW5jdGlvbiAoIHJvb3QsIGhpZXJhcmNoeSApIHtcblxuXHRcdFx0aGllcmFyY2h5LnB1c2goIHJvb3QgKTtcblxuXHRcdFx0Zm9yICggdmFyIGMgPSAwOyBjIDwgcm9vdC5jaGlsZHJlbi5sZW5ndGg7IGMgKysgKVxuXHRcdFx0XHRwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QuY2hpbGRyZW5bIGMgXSwgaGllcmFyY2h5ICk7XG5cblx0XHR9O1xuXG5cdFx0Ly8gc2V0dXAgaGllcmFyY2h5XG5cblx0XHR2YXIgaGllcmFyY2h5ID0gW107XG5cblx0XHRpZiAoIHJvb3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGIgPSAwOyBiIDwgcm9vdC5za2VsZXRvbi5ib25lcy5sZW5ndGg7IGIgKysgKSB7XG5cblx0XHRcdFx0aGllcmFyY2h5LnB1c2goIHJvb3Quc2tlbGV0b24uYm9uZXNbIGIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QsIGhpZXJhcmNoeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhpZXJhcmNoeTtcblxuXHR9LFxuXG5cdHBsYXk6IGZ1bmN0aW9uICggYW5pbWF0aW9uICkge1xuXG5cdFx0aWYgKCB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICkgPT09IC0gMSApIHtcblxuXHRcdFx0dGhpcy5hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKCBhbmltYXRpb24gKSB7XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGFUaW1lTVMgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFuaW1hdGlvbnNbIGkgXS5yZXNldEJsZW5kV2VpZ2h0cyggKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9uc1sgaSBdLnVwZGF0ZSggZGVsdGFUaW1lTVMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbiA9IGZ1bmN0aW9uICggcm9vdCwgZGF0YSApIHtcblxuXHR0aGlzLnJvb3QgPSByb290O1xuXHR0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcblx0dGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCByb290ICk7XG5cblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XG5cdHRoaXMudGltZVNjYWxlID0gMTtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHR0aGlzLmxvb3AgPSB0cnVlO1xuXHR0aGlzLndlaWdodCA9IDA7XG5cblx0dGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSO1xuXG59O1xuXG5cblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUua2V5VHlwZXMgPSBbIFwicG9zXCIsIFwicm90XCIsIFwic2NsXCIgXTtcblxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoIHN0YXJ0VGltZSwgd2VpZ2h0ICkge1xuXG5cdHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG5cdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ICE9PSB1bmRlZmluZWQgPyB3ZWlnaHQ6IDE7XG5cblx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdHRoaXMucmVzZXQoKTtcblxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxufTtcblxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXG5cdFx0b2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge1xuXHRcdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdFx0YmxlbmRpbmc6IHtcblx0XHRcdFx0XHRwb3NpdGlvbldlaWdodDogMC4wLFxuXHRcdFx0XHRcdHF1YXRlcm5pb25XZWlnaHQ6IDAuMCxcblx0XHRcdFx0XHRzY2FsZVdlaWdodDogMC4wXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1t0aGlzLmRhdGEubmFtZV0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbdGhpcy5kYXRhLm5hbWVdID0ge307XG5cdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1t0aGlzLmRhdGEubmFtZV0ucHJldktleSA9IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9O1xuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbdGhpcy5kYXRhLm5hbWVdLm5leHRLZXkgPSB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfTtcblx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zW3RoaXMuZGF0YS5uYW1lXS5vcmlnaW5hbE1hdHJpeCA9IG9iamVjdC5tYXRyaXg7XG5cblx0XHR9XG5cblx0XHR2YXIgYW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1t0aGlzLmRhdGEubmFtZV07XG5cblx0XHQvLyBHZXQga2V5cyB0byBtYXRjaCBvdXIgY3VycmVudCB0aW1lXG5cblx0XHRmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xuXG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMua2V5VHlwZXNbIHQgXTtcblxuXHRcdFx0dmFyIHByZXZLZXkgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXHRcdFx0dmFyIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cblx0XHRcdHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuXHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcblx0XHRcdFx0bmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcblx0XHRcdGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnJlc2V0QmxlbmRXZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXG5cdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ID0gMC4wO1xuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSAwLjA7XG5cdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmcuc2NhbGVXZWlnaHQgPSAwLjA7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IChmdW5jdGlvbigpe1xuXG5cdHZhciBwb2ludHMgPSBbXTtcblx0dmFyIHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBuZXdWZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgbmV3UXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0Ly8gQ2F0bXVsbC1Sb20gc3BsaW5lXG5cblx0dmFyIGludGVycG9sYXRlQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzY2FsZSApIHtcblxuXHRcdHZhciBjID0gW10sIHYzID0gW10sXG5cdFx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3Myxcblx0XHRwYSwgcGIsIHBjLCBwZDtcblxuXHRcdHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogc2NhbGU7XG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuXHRcdGNbIDEgXSA9IGludFBvaW50O1xuXHRcdGNbIDIgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMTtcblx0XHRjWyAzIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDI7XG5cblx0XHRwYSA9IHBvaW50c1sgY1sgMCBdIF07XG5cdFx0cGIgPSBwb2ludHNbIGNbIDEgXSBdO1xuXHRcdHBjID0gcG9pbnRzWyBjWyAyIF0gXTtcblx0XHRwZCA9IHBvaW50c1sgY1sgMyBdIF07XG5cblx0XHR3MiA9IHdlaWdodCAqIHdlaWdodDtcblx0XHR3MyA9IHdlaWdodCAqIHcyO1xuXG5cdFx0djNbIDAgXSA9IGludGVycG9sYXRlKCBwYVsgMCBdLCBwYlsgMCBdLCBwY1sgMCBdLCBwZFsgMCBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuXHRcdHYzWyAxIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDEgXSwgcGJbIDEgXSwgcGNbIDEgXSwgcGRbIDEgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcblx0XHR2M1sgMiBdID0gaW50ZXJwb2xhdGUoIHBhWyAyIF0sIHBiWyAyIF0sIHBjWyAyIF0sIHBkWyAyIF0sIHdlaWdodCwgdzIsIHczICk7XG5cblx0XHRyZXR1cm4gdjM7XG5cblx0fTtcblxuXHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHR9O1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cblx0XHRpZiAoIHRoaXMud2VpZ2h0ID09PSAwIClcblx0XHRcdHJldHVybjtcblxuXHRcdC8vXG5cblx0XHR2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gfHwgdGhpcy5jdXJyZW50VGltZSA8IDAgKSB7XG5cblx0XHRcdGlmICggdGhpcy5sb29wICkge1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cblx0XHRcdFx0aWYgKCB0aGlzLmN1cnJlbnRUaW1lIDwgMCApXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50VGltZSArPSBkdXJhdGlvbjtcblxuXHRcdFx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5zdG9wKCk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblx0XHRcdHZhciBhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zW3RoaXMuZGF0YS5uYW1lXTtcblx0XHRcdHZhciBibGVuZGluZyA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5ibGVuZGluZztcblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHBvcy9yb3Qvc2NsXG5cblx0XHRcdGZvciAoIHZhciB0ID0gMDsgdCA8IDM7IHQgKysgKSB7XG5cblx0XHRcdFx0Ly8gZ2V0IGtleXNcblxuXHRcdFx0XHR2YXIgdHlwZSAgICA9IHRoaXMua2V5VHlwZXNbIHQgXTtcblx0XHRcdFx0dmFyIHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF07XG5cdFx0XHRcdHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdO1xuXG5cdFx0XHRcdGlmICggKCB0aGlzLnRpbWVTY2FsZSA+IDAgJiYgbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB8fFxuXHRcdFx0XHRcdCggdGhpcy50aW1lU2NhbGUgPCAwICYmIHByZXZLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkgKSB7XG5cblx0XHRcdFx0XHRwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcblx0XHRcdFx0XHRuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcblx0XHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcblx0XHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSAoIHRoaXMuY3VycmVudFRpbWUgLSBwcmV2S2V5LnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gcHJldktleS50aW1lICk7XG5cblx0XHRcdFx0dmFyIHByZXZYWVogPSBwcmV2S2V5WyB0eXBlIF07XG5cdFx0XHRcdHZhciBuZXh0WFlaID0gbmV4dEtleVsgdHlwZSBdO1xuXG5cdFx0XHRcdGlmICggc2NhbGUgPCAwICkgc2NhbGUgPSAwO1xuXHRcdFx0XHRpZiAoIHNjYWxlID4gMSApIHNjYWxlID0gMTtcblxuXHRcdFx0XHQvLyBpbnRlcnBvbGF0ZVxuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJwb3NcIiApIHtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIgKSB7XG5cblx0XHRcdFx0XHRcdG5ld1ZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xuXHRcdFx0XHRcdFx0bmV3VmVjdG9yLnkgPSBwcmV2WFlaWyAxIF0gKyAoIG5leHRYWVpbIDEgXSAtIHByZXZYWVpbIDEgXSApICogc2NhbGU7XG5cdFx0XHRcdFx0XHRuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuXHRcdFx0XHRcdFx0Ly8gYmxlbmRcblx0XHRcdFx0XHRcdHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLmxlcnAoIG5ld1ZlY3RvciwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG5cdFx0XHRcdFx0XHRibGVuZGluZy5wb3NpdGlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG5cdFx0XHRcdFx0XHRwb2ludHNbIDAgXSA9IHRoaXMuZ2V0UHJldktleVdpdGgoIFwicG9zXCIsIGgsIHByZXZLZXkuaW5kZXggLSAxIClbIFwicG9zXCIgXTtcblx0XHRcdFx0XHRcdHBvaW50c1sgMSBdID0gcHJldlhZWjtcblx0XHRcdFx0XHRcdHBvaW50c1sgMiBdID0gbmV4dFhZWjtcblx0XHRcdFx0XHRcdHBvaW50c1sgMyBdID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJwb3NcIiwgaCwgbmV4dEtleS5pbmRleCArIDEgKVsgXCJwb3NcIiBdO1xuXG5cdFx0XHRcdFx0XHRzY2FsZSA9IHNjYWxlICogMC4zMyArIDAuMzM7XG5cblx0XHRcdFx0XHRcdHZhciBjdXJyZW50UG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKTtcblx0XHRcdFx0XHRcdHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuXHRcdFx0XHRcdFx0YmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cblx0XHRcdFx0XHRcdC8vIGJsZW5kXG5cblx0XHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBvYmplY3QucG9zaXRpb247XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZlY3Rvci54ID0gdmVjdG9yLnggKyAoIGN1cnJlbnRQb2ludFsgMCBdIC0gdmVjdG9yLnggKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblx0XHRcdFx0XHRcdHZlY3Rvci55ID0gdmVjdG9yLnkgKyAoIGN1cnJlbnRQb2ludFsgMSBdIC0gdmVjdG9yLnkgKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblx0XHRcdFx0XHRcdHZlY3Rvci56ID0gdmVjdG9yLnogKyAoIGN1cnJlbnRQb2ludFsgMiBdIC0gdmVjdG9yLnogKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZm9yd2FyZFBvaW50ID0gaW50ZXJwb2xhdGVDYXRtdWxsUm9tKCBwb2ludHMsIHNjYWxlICogMS4wMSApO1xuXG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zZXQoIGZvcndhcmRQb2ludFsgMCBdLCBmb3J3YXJkUG9pbnRbIDEgXSwgZm9yd2FyZFBvaW50WyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnN1YiggdmVjdG9yICk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldC55ID0gMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRhcmdldC54LCB0YXJnZXQueiApO1xuXHRcdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCAwLCBhbmdsZSwgMCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJyb3RcIiApIHtcblxuXHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIHByZXZYWVosIG5leHRYWVosIG5ld1F1YXQsIHNjYWxlICk7XG5cblx0XHRcdFx0XHQvLyBBdm9pZCBwYXlpbmcgdGhlIGNvc3Qgb2YgYW4gYWRkaXRpb25hbCBzbGVycCBpZiB3ZSBkb24ndCBoYXZlIHRvXG5cdFx0XHRcdFx0aWYgKCBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5jb3B5KG5ld1F1YXQpO1xuXHRcdFx0XHRcdFx0YmxlbmRpbmcucXVhdGVybmlvbldlaWdodCA9IHRoaXMud2VpZ2h0O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgKTtcblx0XHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIG9iamVjdC5xdWF0ZXJuaW9uLCBuZXdRdWF0LCBvYmplY3QucXVhdGVybmlvbiwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG5cdFx0XHRcdFx0XHRibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwic2NsXCIgKSB7XG5cblx0XHRcdFx0XHRuZXdWZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcblx0XHRcdFx0XHRuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcblx0XHRcdFx0XHRuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuXHRcdFx0XHRcdHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5zY2FsZVdlaWdodCApO1xuXHRcdFx0XHRcdG9iamVjdC5zY2FsZS5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuXHRcdFx0XHRcdGJsZW5kaW5nLnNjYWxlV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufSkoKTtcblxuXG5cblxuXG4vLyBHZXQgbmV4dCBrZXkgd2l0aFxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldE5leHRLZXlXaXRoID0gZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XG5cblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcblxuXHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuXHRcdCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdGtleSA9IGtleSA8IGtleXMubGVuZ3RoIC0gMSA/IGtleSA6IGtleXMubGVuZ3RoIC0gMTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0a2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cblx0fVxuXG5cdGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSArKyApIHtcblxuXHRcdGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXG59O1xuXG4vLyBHZXQgcHJldmlvdXMga2V5IHdpdGhcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRQcmV2S2V5V2l0aCA9IGZ1bmN0aW9uICggdHlwZSwgaCwga2V5ICkge1xuXG5cdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cblx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcblx0XHR0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdGtleSA9IGtleSA+IDAgPyBrZXkgOiAwO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG5cdH1cblxuXG5cdGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuXHRcdGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vS2V5RnJhbWVBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGtoYW5nIGR1b25nXG4gKiBAYXV0aG9yIGVyaWsga2l0c29uXG4gKi9cblxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24gPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0dGhpcy5yb290ID0gZGF0YS5ub2RlO1xuXHR0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcblx0dGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCB0aGlzLnJvb3QgKTtcblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XG5cdHRoaXMudGltZVNjYWxlID0gMC4wMDE7XG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXHR0aGlzLmxvb3AgPSB0cnVlO1xuXG5cdC8vIGluaXRpYWxpemUgdG8gZmlyc3Qga2V5ZnJhbWVzXG5cblx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXMsXG5cdFx0XHRzaWRzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5zaWRzLFxuXHRcdFx0b2JqID0gdGhpcy5oaWVyYXJjaHlbaF07XG5cblx0XHRpZiAoIGtleXMubGVuZ3RoICYmIHNpZHMgKSB7XG5cblx0XHRcdGZvciAoIHZhciBzID0gMDsgcyA8IHNpZHMubGVuZ3RoOyBzICsrICkge1xuXG5cdFx0XHRcdHZhciBzaWQgPSBzaWRzWyBzIF0sXG5cdFx0XHRcdFx0bmV4dCA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHNpZCwgaCwgMCApO1xuXG5cdFx0XHRcdGlmICggbmV4dCApIHtcblxuXHRcdFx0XHRcdG5leHQuYXBwbHkoIHNpZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRvYmoubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0b2JqLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICggc3RhcnRUaW1lICkge1xuXG5cdHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG5cblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cblx0XHQvLyByZXNldCBrZXkgY2FjaGVcblxuXHRcdHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcblx0XHRcdG9iamVjdCxcblx0XHRcdG5vZGU7XG5cblx0XHRmb3IgKCBoID0gMDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXHRcdFx0bm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuXHRcdFx0aWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZSA9IHt9O1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBudWxsO1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4ID0gb2JqZWN0Lm1hdHJpeDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cztcblxuXHRcdFx0aWYgKGtleXMubGVuZ3RoKSB7XG5cblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0ga2V5c1sgMCBdO1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBrZXlzWyAxIF07XG5cblx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1swXS50aW1lLCB0aGlzLnN0YXJ0VGltZSApO1xuXHRcdFx0XHR0aGlzLmVuZFRpbWUgPSBNYXRoLm1heCgga2V5c1trZXlzLmxlbmd0aCAtIDFdLnRpbWUsIHRoaXMuZW5kVGltZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZSggMCApO1xuXG5cdH1cblxuXHR0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wbGF5KCB0aGlzICk7XG5cbn07XG5cblxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHR0aGlzLmlzUGF1c2VkICA9IGZhbHNlO1xuXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG5cdC8vIHJlc2V0IEpJVCBtYXRyaXggYW5kIHJlbW92ZSBjYWNoZVxuXG5cdGZvciAoIHZhciBoID0gMDsgaCA8IHRoaXMuZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoICsrICkge1xuXHRcdFxuXHRcdHZhciBvYmogPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXHRcdHZhciBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG5cdFx0aWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBvcmlnaW5hbCA9IG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XG5cblx0XHRcdG9yaWdpbmFsLmNvcHkoIG9iai5tYXRyaXggKTtcblx0XHRcdG9iai5tYXRyaXggPSBvcmlnaW5hbDtcblxuXHRcdFx0ZGVsZXRlIG5vZGUuYW5pbWF0aW9uQ2FjaGU7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5cbi8vIFVwZGF0ZVxuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuXHR0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cblx0Ly9cblxuXHR2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG5cdGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiApIHtcblxuXHRcdHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cblx0fVxuXG5cdHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1pbiggdGhpcy5jdXJyZW50VGltZSwgZHVyYXRpb24gKTtcblxuXHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuXHRcdHZhciBrZXlzID0gbm9kZS5rZXlzLFxuXHRcdFx0YW5pbWF0aW9uQ2FjaGUgPSBub2RlLmFuaW1hdGlvbkNhY2hlO1xuXG5cblx0XHRpZiAoIGtleXMubGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgcHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXk7XG5cdFx0XHR2YXIgbmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXk7XG5cblx0XHRcdGlmICggbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB7XG5cblx0XHRcdFx0d2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG5cdFx0XHRcdFx0cHJldktleSA9IG5leHRLZXk7XG5cdFx0XHRcdFx0bmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBwcmV2S2V5O1xuXHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbmV4dEtleTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5leHRLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkge1xuXG5cdFx0XHRcdHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIHRoaXMuY3VycmVudFRpbWUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCBuZXh0S2V5LnRpbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcblx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbi8vIEdldCBuZXh0IGtleSB3aXRoXG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcblxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXHRrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkgKysgKSB7XG5cblx0XHRpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XG5cblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGtleXNbIDAgXTtcblxufTtcblxuLy8gR2V0IHByZXZpb3VzIGtleSB3aXRoXG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRQcmV2S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcblxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG5cdGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuXHRcdGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4ga2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vTW9ycGhBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltYXRpb24gPSBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0dGhpcy5tZXNoID0gbWVzaDtcblx0dGhpcy5mcmFtZXMgPSBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7XG5cdHRoaXMuY3VycmVudFRpbWUgPSAwO1xuXHR0aGlzLmR1cmF0aW9uID0gMTAwMDtcblx0dGhpcy5sb29wID0gdHJ1ZTtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cblx0cGxheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0fSxcblxuXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxhc3RGcmFtZSA9IDA7XG5cdFx0dmFyIGN1cnJlbnRGcmFtZSA9IDA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGE7XG5cblx0XHRcdGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudFRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdFx0dmFyIGludGVycG9sYXRpb24gPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5mcmFtZXM7XG5cdFx0XHR2YXIgZnJhbWUgPSBNYXRoLmZsb29yKCB0aGlzLmN1cnJlbnRUaW1lIC8gaW50ZXJwb2xhdGlvbiApO1xuXG5cdFx0XHRpZiAoIGZyYW1lICE9IGN1cnJlbnRGcmFtZSApIHtcblxuXHRcdFx0XHR0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBsYXN0RnJhbWUgXSA9IDA7XG5cdFx0XHRcdHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGN1cnJlbnRGcmFtZSBdID0gMTtcblx0XHRcdFx0dGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgZnJhbWUgXSA9IDA7XG5cblx0XHRcdFx0bGFzdEZyYW1lID0gY3VycmVudEZyYW1lO1xuXHRcdFx0XHRjdXJyZW50RnJhbWUgPSBmcmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBmcmFtZSBdID0gKCB0aGlzLmN1cnJlbnRUaW1lICUgaW50ZXJwb2xhdGlvbiApIC8gaW50ZXJwb2xhdGlvbjtcblx0XHRcdHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGxhc3RGcmFtZSBdID0gMSAtIHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGZyYW1lIF07XG5cblx0XHR9XG5cblx0fSApKClcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL0N1YmUuYXNcbiAqL1xuXG5USFJFRS5Cb3hHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0ZGVwdGg6IGRlcHRoLFxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcblx0fTtcblxuXHR0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XG5cdHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuXHR0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcblx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblx0dmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XG5cblx0YnVpbGRQbGFuZSggJ3onLCAneScsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aF9oYWxmLCAwICk7IC8vIHB4XG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aF9oYWxmLCAxICk7IC8vIG54XG5cdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsICAgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHRfaGFsZiwgMiApOyAvLyBweVxuXHRidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHRfaGFsZiwgMyApOyAvLyBueVxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgICAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcblx0YnVpbGRQbGFuZSggJ3gnLCAneScsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoX2hhbGYsIDUgKTsgLy8gbnpcblxuXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHZhciB3LCBpeCwgaXksXG5cdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxuXHRcdGdyaWRZID0gc2NvcGUuaGVpZ2h0U2VnbWVudHMsXG5cdFx0d2lkdGhfaGFsZiA9IHdpZHRoIC8gMixcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXG5cdFx0b2Zmc2V0ID0gc2NvcGUudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcblxuXHRcdFx0dyA9ICd6JztcblxuXHRcdH0gZWxzZSBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd6JyApIHx8ICggdSA9PT0gJ3onICYmIHYgPT09ICd4JyApICkge1xuXG5cdFx0XHR3ID0gJ3knO1xuXHRcdFx0Z3JpZFkgPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XG5cblx0XHRcdHcgPSAneCc7XG5cdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cblx0XHR9XG5cblx0XHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxLFxuXHRcdGdyaWRZMSA9IGdyaWRZICsgMSxcblx0XHRzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcblx0XHRzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZLFxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRub3JtYWxbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XG5cblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdHZlY3RvclsgdSBdID0gKCBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmICkgKiB1ZGlyO1xuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xuXHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoO1xuXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcblx0XHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG5cdFx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG5cdFx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xuXG5cdFx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufTtcblxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBodWdoZXNcbiAqL1xuXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblx0c2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xuXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuXHR2YXIgaSwgdXZzID0gW10sXG5cdGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGNlbnRlclVWID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAuNSwgMC41ICk7XG5cblx0dGhpcy52ZXJ0aWNlcy5wdXNoKGNlbnRlcik7XG5cdHV2cy5wdXNoKCBjZW50ZXJVViApO1xuXG5cdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyByYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gcmFkaXVzICsgMSApIC8gMiApICk7XG5cblx0fVxuXG5cdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBpLCBpICsgMSwgMCwgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuXHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBpIF0uY2xvbmUoKSwgdXZzWyBpICsgMSBdLmNsb25lKCksIGNlbnRlclVWLmNsb25lKCkgXSApO1xuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N1YmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdWJlR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Cb3hHZW9tZXRyeS4nICk7XG5cdHJldHVybiBuZXcgVEhSRUUuQm94R2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApO1xuXG4gfTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZFxuXHR9O1xuXG5cdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XG5cdHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMjA7XG5cdGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xuXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0aGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuXG5cdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XG5cblx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcblxuXHRmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXHRcdHZhciB1dnNSb3cgPSBbXTtcblxuXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXHRcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogTWF0aC5QSSAqIDIgKTtcblx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGVpZ2h0SGFsZjtcblx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKiBNYXRoLlBJICogMiApO1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblx0XHRcdHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XG5cblx0fVxuXG5cdHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cdHZhciBuYSwgbmI7XG5cblx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdGlmICggcmFkaXVzVG9wICE9PSAwICkge1xuXG5cdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xuXHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcblx0XHRuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG5cblx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHR2YXIgbjEgPSBuYS5jbG9uZSgpO1xuXHRcdFx0dmFyIG4yID0gbmEuY2xvbmUoKTtcblx0XHRcdHZhciBuMyA9IG5iLmNsb25lKCk7XG5cdFx0XHR2YXIgbjQgPSBuYi5jbG9uZSgpO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIHRvcCBjYXBcblxuXHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzVG9wID4gMCApIHtcblxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIDAgXVsgeCBdO1xuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cdFx0XHR2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBib3R0b20gY2FwXG5cblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59XG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnZW1lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZVBhdGg+IC8vIDNkIHNwbGluZSBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmcuIChjcmVhdGVzIEZyYW1lcyBpZiAuZnJhbWVzIGFyZW4ndCBkZWZpbmVkKVxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcbiAqXG4gKiAgbWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xuICogIGV4dHJ1ZGVNYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGV4dHJ1c2lvbiBhbmQgYmV2ZWxlZCBmYWNlc1xuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICoqL1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHRpZiAoIHR5cGVvZiggc2hhcGVzICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0c2hhcGVzID0gW107XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG5cdHNoYXBlcyA9IHNoYXBlcyBpbnN0YW5jZW9mIEFycmF5ID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHQvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xuXHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cblx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xuXG5cdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdC8vY29uc29sZS5sb2coIFwidG9va1wiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cdHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XG5cblx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcblx0fVxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XG5cblx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcblxuXHR2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcblx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxuXHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcblxuXHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cblx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuXHR2YXIgZXh0cnVkZU1hdGVyaWFsID0gb3B0aW9ucy5leHRydWRlTWF0ZXJpYWw7XG5cblx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcblxuXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG5cdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuXHRcdC8vIFJldXNlIFROQiBmcm9tIFR1YmVHZW9tdHJ5IGZvciBub3cuXG5cdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuXHRcdHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyhleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR9XG5cblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdGJldmVsU2VnbWVudHMgPSAwO1xuXHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRiZXZlbFNpemUgPSAwO1xuXG5cdH1cblxuXHQvLyBWYXJpYWJsZXMgaW5pdGFsaXphdGlvblxuXG5cdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcblx0dmFyIHNjb3BlID0gdGhpcztcblx0dmFyIGJldmVsUG9pbnRzID0gW107XG5cblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cblx0dmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApIDtcblxuXHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG5cdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldmVyc2UgPSBmYWxzZTsgLy8gSWYgdmVydGljZXMgYXJlIGluIG9yZGVyIG5vdywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlbSBhZ2FpbiAoaG9wZWZ1bGx5KSFcblxuXHR9XG5cblxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlICggdmVydGljZXMsIGhvbGVzICk7XG5cblx0LyogVmVydGljZXMgKi9cblxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgIGggPCBobDsgaCArKyApIHtcblxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcblxuXHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmxvZyggXCJkaWVcIiApO1xuXG5cdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xuXG5cdH1cblxuXHR2YXIgYiwgYnMsIHQsIHosXG5cdFx0dmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcblx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoLFxuXHRcdGNvbnQsIGNsZW4gPSBjb250b3VyLmxlbmd0aDtcblxuXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXHR2YXIgUkFEX1RPX0RFR1JFRVMgPSAxODAgLyBNYXRoLlBJO1xuXG5cblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG5cdFx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cdFx0XG5cdFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuXHRcdC8vICAgc2hpZnRldCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcblx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcblx0XHQvL1xuXHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG5cdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblx0XHRcblx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG5cdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cdFx0XG5cdFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblx0XHRcblx0XHQvLyBjaGVjayBmb3IgY29saW5lYXIgZWRnZXNcblx0XHR2YXIgY29saW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXHRcdFxuXHRcdGlmICggTWF0aC5hYnMoIGNvbGluZWFyMCApID4gRVBTSUxPTiApIHtcdFx0Ly8gbm90IGNvbGluZWFyXG5cdFx0XHRcblx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXHRcblx0XHRcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXHRcdFx0XG5cdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cdFxuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG5cdFx0XHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblx0XHRcdFxuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG5cdFx0XHR2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblx0XG5cdFx0XHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXHRcblx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xuXHRcdFx0XHRcdCAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXHRcblx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cdFxuXHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xuXHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xuXHRcblx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195IClcblx0XHRcdGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xuXHRcdFx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xpbmVhciBlZGdlc1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7XHRcdC8vIGFzc3VtZXM6IG9wcG9zaXRlXG5cdFx0XHRpZiAoIHZfcHJldl94ID4gRVBTSUxPTiApIHtcblx0XHRcdFx0aWYgKCB2X25leHRfeCA+IEVQU0lMT04gKSB7IGRpcmVjdGlvbl9lcSA9IHRydWU7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIEVQU0lMT04gKSB7XG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gRVBTSUxPTiApIHsgZGlyZWN0aW9uX2VxID0gdHJ1ZTsgfVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggTWF0aC5zaWduKHZfcHJldl95KSA9PSBNYXRoLnNpZ24odl9uZXh0X3kpICkgeyBkaXJlY3Rpb25fZXEgPSB0cnVlOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG5cdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG5cdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xuXHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG5cdH1cblxuXG5cdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHR2YXIgcHRfaSA9IGNvbnRvdXJbIGkgXTtcblx0XHR2YXIgcHRfaiA9IGNvbnRvdXJbIGogXTtcblx0XHR2YXIgcHRfayA9IGNvbnRvdXJbIGsgXTtcblxuXHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXT0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuXHR9XG5cblx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cblx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuXHRcdFx0b25lSG9sZU1vdmVtZW50c1sgaSBdPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0fVxuXG5cdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuXHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0fVxuXG5cblx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cblx0XHQvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XG5cdFx0YnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luICggdCAqIE1hdGguUEkvMiApICkgOyAvLyBjdXJ2ZWRcblx0XHQvL2JzID0gYmV2ZWxTaXplICogdCA7IC8vIGxpbmVhclxuXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cblx0XHR9XG5cblx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRicyA9IGJldmVsU2l6ZTtcblxuXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cblx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LngpO1xuXHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LnkpO1xuXG5cdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1swXSApLmFkZChub3JtYWwpLmFkZChiaW5vcm1hbCk7XG5cblx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cblx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG5cdHZhciBzO1xuXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbc10gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzW3NdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzW3NdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiAoIDEtTWF0aC5zaW4gKCAoIDEgLSB0ICkgKiBNYXRoLlBJLzIgKSApO1xuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSS8yICkgO1xuXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuXHRcdH1cblxuXHRcdC8vIGV4cGFuZCBob2xlc1xuXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qIEZhY2VzICovXG5cblx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuXHRidWlsZExpZEZhY2VzKCk7XG5cblx0Ly8gU2lkZXMgZmFjZXNcblxuXHRidWlsZFNpZGVGYWNlcygpO1xuXG5cblx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cblx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdFx0dmFyIGxheWVyID0gMCA7IC8vIHN0ZXBzICsgMVxuXHRcdFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSsgb2Zmc2V0LCBmYWNlWyAxIF0rIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHQvLyBUb3AgZmFjZXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cblx0XHR2YXIgbGF5ZXJvZmZzZXQgPSAwO1xuXHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgIGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuXHRcdFx0Ly8sIHRydWVcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcblxuXHRcdHZhciBqLCBrO1xuXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdHdoaWxlICggLS1pID49IDAgKSB7XG5cblx0XHRcdGogPSBpO1xuXHRcdFx0ayA9IGkgLSAxO1xuXHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG5cdFx0XHR2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cblx0XHRcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XG5cdFx0XHRcdHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cblx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG5cdFx0Ly8gbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcblxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xuXG4gXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xuXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XG5cbiBcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCBleHRydWRlTWF0ZXJpYWwgKSApO1xuIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIG51bGwsIG51bGwsIGV4dHJ1ZGVNYXRlcmlhbCApICk7XG5cbiBcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcblxuIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcbiBcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAxIF0sIHV2c1sgMiBdLCB1dnNbIDMgXSBdICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcblxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcblx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcblx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYS54LCBhLnkgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIGIueSApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcblx0XHRdO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuXHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuXHRcdHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuXHRcdHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggYS55IC0gYi55ICkgPCAwLjAxICkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXG5cdFx0XHRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYS55LCAxIC0gYS56ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggZC55LCAxIC0gZC56IClcblx0XHRcdF07XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG4gKlxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxuICpcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG5cdGlmICggc2hhcGVzIGluc3RhbmNlb2YgQXJyYXkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcblxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG4gKi9cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG5cdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuXHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcblx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG5cdC8vXG5cblx0dmFyIGksIGwsIGhvbGUsIHM7XG5cblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuXHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cblxuXHRcdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aG9sZSA9IGhvbGVzWyBpIF07XG5cblx0XHRcdGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcblxuXHRcdFx0XHRob2xlc1sgaSBdID0gaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldmVyc2UgPSBmYWxzZTtcblxuXHR9XG5cblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cblx0Ly8gVmVydGljZXNcblxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzO1xuXG5cdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGhvbGUgPSBob2xlc1sgaSBdO1xuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XG5cblx0fVxuXG5cdC8vXG5cblx0dmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cdHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXHR2YXIgY29udCwgY2xlbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xuXG5cdH1cblxuXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuXHRcdHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xuXHRcdHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xuXG5cdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cbi8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50cyBcbi8vICAgIGxpa2Ugc286IFsgYSwgYiwgYywgZCwgYSBdLCBzZWUgZmlyc3QgaXMgdGhlIHNhbWUgYXMgbGFzdC5cbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXG4vLyBwaGlMZW5ndGggLSB0aGUgcmFkaWFuICgwIHRvIDIqUEkpIHJhbmdlIG9mIHRoZSBsYXRoZWQgc2VjdGlvblxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXG5cblRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cG9pbnRzOiBwb2ludHMsXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxuXHR9O1xuXG5cdHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTI7XG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcblx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IDIgKiBNYXRoLlBJO1xuXG5cdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XG5cdHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XG5cblx0XHR2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggcGhpICksXG5cdFx0XHRzID0gTWF0aC5zaW4oIHBoaSApO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0dmFyIHB0ID0gcG9pbnRzWyBqIF07XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2ZXJ0ZXgueCA9IGMgKiBwdC54IC0gcyAqIHB0Lnk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHMgKiBwdC54ICsgYyAqIHB0Lnk7XG5cdFx0XHR2ZXJ0ZXgueiA9IHB0Lno7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciBucCA9IHBvaW50cy5sZW5ndGg7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0dmFyIGJhc2UgPSBqICsgbnAgKiBpO1xuXHRcdFx0dmFyIGEgPSBiYXNlO1xuXHRcdFx0dmFyIGIgPSBiYXNlICsgbnA7XG5cdFx0XHR2YXIgYyA9IGJhc2UgKyAxICsgbnA7XG5cdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xuXG5cdFx0XHR2YXIgdTAgPSBpICogaW52ZXJzZVNlZ21lbnRzO1xuXHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcblx0XHRcdHZhciB1MSA9IHUwICsgaW52ZXJzZVNlZ21lbnRzO1xuXHRcdFx0dmFyIHYxID0gdjAgKyBpbnZlcnNlUG9pbnRMZW5ndGg7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjAgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuXHRcdFx0XSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjEgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXG5cblx0XHRcdF0gKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdGNvbnNvbGUuaW5mbyggJ1RIUkVFLlBsYW5lR2VvbWV0cnk6IENvbnNpZGVyIHVzaW5nIFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgZm9yIGxvd2VyIG1lbW9yeSBmb290cHJpbnQuJyApO1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHR9O1xuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHR9O1xuXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHR2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdHZhciBncmlkWCA9IHdpZHRoU2VnbWVudHMgfHwgMTtcblx0dmFyIGdyaWRZID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcblxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcblx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDIgKTtcblxuXHR2YXIgb2Zmc2V0ID0gMDtcblx0dmFyIG9mZnNldDIgPSAwO1xuXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgICAgIF0gPSB4O1xuXHRcdFx0dmVydGljZXNbIG9mZnNldCArIDEgXSA9IC0geTtcblxuXHRcdFx0bm9ybWFsc1sgb2Zmc2V0ICsgMiBdID0gMTtcblxuXHRcdFx0dXZzWyBvZmZzZXQyICAgICBdID0gaXggLyBncmlkWDtcblx0XHRcdHV2c1sgb2Zmc2V0MiArIDEgXSA9IDEgLSAoIGl5IC8gZ3JpZFkgKTtcblxuXHRcdFx0b2Zmc2V0ICs9IDM7XG5cdFx0XHRvZmZzZXQyICs9IDI7XG5cblx0XHR9XG5cblx0fVxuXG5cdG9mZnNldCA9IDA7XG5cblx0dmFyIGluZGljZXMgPSBuZXcgKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xuXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cblx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgICAgIF0gPSBhO1xuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMSBdID0gYjtcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XG5cblx0XHRcdGluZGljZXNbIG9mZnNldCArIDMgXSA9IGI7XG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcblxuXHRcdFx0b2Zmc2V0ICs9IDY7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnaW5kZXgnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbn07XG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1JpbmdHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgS2FsZWIgTXVycGh5XG4gKi9cblxuVEhSRUUuUmluZ0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcblx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XG5cdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XG5cblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcblx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xuXG5cdHZhciBpLCBvLCB1dnMgPSBbXSwgcmFkaXVzID0gaW5uZXJSYWRpdXMsIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzICsgMTsgaSArKyApIHsgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHRmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgKyAxOyBvICsrICkgeyAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cdFx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDIgKSApO1xuXHRcdH1cblxuXHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG5cdH1cblxuXHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50czsgaSArKyApIHsgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHR2YXIgdGhldGFTZWdtZW50ID0gaSAqICh0aGV0YVNlZ21lbnRzICsgMSk7XG5cblx0XHRmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgOyBvICsrICkgeyAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG5cdFx0XHR2YXIgc2VnbWVudCA9IG8gKyB0aGV0YVNlZ21lbnQ7XG5cblx0XHRcdHZhciB2MSA9IHNlZ21lbnQ7XG5cdFx0XHR2YXIgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG5cdFx0XHR2YXIgdjMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSk7XG5cblx0XHRcdHYxID0gc2VnbWVudDtcblx0XHRcdHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXHRcdFx0djMgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdKTtcblxuXHRcdH1cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoIFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblxuXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XG5cdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xuXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcblx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcblxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcblxuXHR2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XG5cblx0Zm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHR2YXIgdmVydGljZXNSb3cgPSBbXTtcblx0XHR2YXIgdXZzUm93ID0gW107XG5cblx0XHRmb3IgKCB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuXHRcdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XG5cblx0XHR9XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXHRcdHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuXHR9XG5cblx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuXHRcdFx0dmFyIG4xID0gdGhpcy52ZXJ0aWNlc1sgdjEgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG4yID0gdGhpcy52ZXJ0aWNlc1sgdjIgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG4zID0gdGhpcy52ZXJ0aWNlc1sgdjMgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG40ID0gdGhpcy52ZXJ0aWNlc1sgdjQgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djQgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdGhpcy52ZXJ0aWNlc1sgdjEgXS55ICkgPT09IHJhZGl1cyApIHtcblxuXHRcdFx0XHR1djEueCA9ICggdXYxLnggKyB1djIueCApIC8gMjtcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MywgdjQsIFsgbjEsIG4zLCBuNCBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MywgdXY0IF0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYzIF0ueSApID09PSByYWRpdXMgKSB7XG5cblx0XHRcdFx0dXYzLnggPSAoIHV2My54ICsgdXY0LnggKSAvIDI7XG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXY0IF0gKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXG4gKlxuICogVGV4dCA9IDNEIFRleHRcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxuICogIGN1cnZlU2VnbWVudHM6IFx0PGludD4sXHRcdC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICpcbiAqICBmb250OiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBuYW1lXG4gKiAgd2VpZ2h0OiBcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgd2VpZ2h0IChub3JtYWwsIGJvbGQpXG4gKiAgc3R5bGU6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6XHQ8Ym9vbD4sXHRcdFx0Ly8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCBcdFx0Ly8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6XHRcdDxmbG9hdD4sIFx0XHQvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXG4gKiAgfVxuICpcbiAqL1xuXG4vKlx0VXNhZ2UgRXhhbXBsZXNcblxuXHQvLyBUZXh0R2VvbWV0cnkgd3JhcHBlclxuXG5cdHZhciB0ZXh0M2QgPSBuZXcgVGV4dEdlb21ldHJ5KCB0ZXh0LCBvcHRpb25zICk7XG5cblx0Ly8gQ29tcGxldGUgbWFubmVyXG5cblx0dmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIG9wdGlvbnMgKTtcblx0dmFyIHRleHQzZCA9IG5ldyBFeHRydWRlR2VvbWV0cnkoIHRleHRTaGFwZXMsIG9wdGlvbnMgKTtcblxuKi9cblxuXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHRleHQsIHBhcmFtZXRlcnMgKSB7XG5cblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMgKTtcblxuXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXG5cblx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcblxuXHQvLyBkZWZhdWx0c1xuXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XG5cdGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XG5cblx0VEhSRUUuRXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHRleHRTaGFwZXMsIHBhcmFtZXRlcnMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5JztcblxufTtcblxuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICovXG5cblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHR1YmU6IHR1YmUsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdGFyYzogYXJjXG5cdH07XG5cblx0cmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcblx0dHViZSA9IHR1YmUgfHwgNDA7XG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XG5cdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuXHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdXZzID0gW10sIG5vcm1hbHMgPSBbXTtcblxuXHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHRjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xuXHRcdFx0bm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZvciAoIHZhciBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG5cdFx0XHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG5cdFx0XHR2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblx0XHRcdHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIFsgbm9ybWFsc1sgYSBdLmNsb25lKCksIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIFsgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGMgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcbiAqL1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0dHViZTogdHViZSxcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0cDogcCxcblx0XHRxOiBxLFxuXHRcdGhlaWdodFNjYWxlOiBoZWlnaHRTY2FsZVxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG5cdHR1YmUgPSB0dWJlIHx8IDQwO1xuXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xuXHR0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcblx0cCA9IHAgfHwgMjtcblx0cSA9IHEgfHwgMztcblx0aGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xuXHRcblx0dmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XG5cdHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xuXG5cdFx0Z3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHR2YXIgdSA9IGkgLyByYWRpYWxTZWdtZW50cyAqIDIgKiBwICogTWF0aC5QSTtcblx0XHR2YXIgcDEgPSBnZXRQb3MoIHUsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcblx0XHR2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG5cdFx0dGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcblx0XHRuLmFkZFZlY3RvcnMoIHAyLCBwMSApO1xuXG5cdFx0Yml0YW4uY3Jvc3NWZWN0b3JzKCB0YW5nLCBuICk7XG5cdFx0bi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XG5cdFx0Yml0YW4ubm9ybWFsaXplKCk7XG5cdFx0bi5ub3JtYWxpemUoKTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0dmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cdFx0XHR2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxuXHRcdFx0dmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cG9zLnggPSBwMS54ICsgY3ggKiBuLnggKyBjeSAqIGJpdGFuLng7XG5cdFx0XHRwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcblx0XHRcdHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xuXG5cdFx0XHRncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0dmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG5cdFx0XHR2YXIganAgPSAoIGogKyAxICkgJSB0dWJ1bGFyU2VnbWVudHM7XG5cblx0XHRcdHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XG5cdFx0XHR2YXIgYiA9IGdyaWRbIGlwIF1bIGogXTtcblx0XHRcdHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcblx0XHRcdHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG5cdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0dmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG5cdFx0fVxuXHR9XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcblxuXHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcblx0XHR2YXIgcXVPdmVyUCA9IGluX3EgLyBpbl9wICogdTtcblx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0dmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuXHRcdHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcblx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXG4gKlxuICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxuICpcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXG4gKlxuICogVXNlcyBwYXJhbGxlbCB0cmFuc3BvcnQgZnJhbWVzIGFzIGRlc2NyaWJlZCBpblxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG4gKi9cblxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cGF0aDogcGF0aCxcblx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGNsb3NlZDogY2xvc2VkXG5cdH07XG5cblx0c2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcblx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0Y2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuXG5cdHZhciBncmlkID0gW107XG5cblx0dmFyIHNjb3BlID0gdGhpcyxcblxuXHRcdHRhbmdlbnQsXG5cdFx0bm9ybWFsLFxuXHRcdGJpbm9ybWFsLFxuXG5cdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXG5cdFx0eCwgeSwgeixcblx0XHR0eCwgdHksIHR6LFxuXHRcdHUsIHYsXG5cblx0XHRjeCwgY3ksXG5cdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRpLCBqLFxuXHRcdGlwLCBqcCxcblx0XHRhLCBiLCBjLCBkLFxuXHRcdHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuXHR2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcblx0XHR0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcblx0XHRub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXG5cdFx0Ymlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuXHQvLyBwcm94eSBpbnRlcm5hbHNcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuXHRmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xuXG5cdFx0cmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XG5cblx0fVxuXG5cdC8vIGNvbnNydWN0IHRoZSBncmlkXG5cblx0Zm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRncmlkWyBpIF0gPSBbXTtcblxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHRwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuXHRcdHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuXHRcdG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcblx0XHRiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG5cdFx0Zm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0diA9IGogLyByYWRpYWxTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xuXG5cdFx0XHRjeCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cblx0XHRcdGN5ID0gcmFkaXVzICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0cG9zMi5jb3B5KCBwb3MgKTtcblx0XHRcdHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xuXHRcdFx0cG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XG5cdFx0XHRwb3MyLnogKz0gY3ggKiBub3JtYWwueiArIGN5ICogYmlub3JtYWwuejtcblxuXHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB2ZXJ0KCBwb3MyLngsIHBvczIueSwgcG9zMi56ICk7XG5cblx0XHR9XG5cdH1cblxuXG5cdC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxuXG5cdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRpcCA9ICggY2xvc2VkICkgPyAoaSArIDEpICUgc2VnbWVudHMgOiBpICsgMTtcblx0XHRcdGpwID0gKGogKyAxKSAlIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRhID0gZ3JpZFsgaSBdWyBqIF07XHRcdC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG5cdFx0XHRiID0gZ3JpZFsgaXAgXVsgaiBdO1xuXHRcdFx0YyA9IGdyaWRbIGlwIF1bIGpwIF07XG5cdFx0XHRkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdH1cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5cbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHR2YXJcdHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdFx0dGFuZ2VudHMgPSBbXSxcblx0XHRub3JtYWxzID0gW10sXG5cdFx0Ymlub3JtYWxzID0gW10sXG5cblx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG5cdFx0dGhldGEsXG5cdFx0ZXBzaWxvbiA9IDAuMDAwMSxcblx0XHRzbWFsbGVzdCxcblxuXHRcdHR4LCB0eSwgdHosXG5cdFx0aSwgdSwgdjtcblxuXG5cdC8vIGV4cG9zZSBpbnRlcm5hbHNcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG5cdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuXHRcdHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xuXHRcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGluaXRpYWxOb3JtYWwzKCk7XG5cblx0Lypcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XG5cdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xuXG5cdFx0Ly8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXG5cdFx0dmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcblxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyggdDIsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cdCovXG5cblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XG5cdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5pY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcblxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHR0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcblx0XHR0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHR0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gc21hbGxlc3QgKSB7XG5cdFx0XHRzbWFsbGVzdCA9IHR4O1xuXHRcdFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gc21hbGxlc3QgKSB7XG5cdFx0XHRzbWFsbGVzdCA9IHR5O1xuXHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xuXHRcdH1cblxuXHRcdGlmICggdHogPD0gc21hbGxlc3QgKSB7XG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cdFx0fVxuXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXHR9XG5cblxuXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG5cdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG5cdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaS0xIF0uY2xvbmUoKTtcblxuXHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpLTEgXS5jbG9uZSgpO1xuXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGktMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IGVwc2lsb24gKSB7XG5cblx0XHRcdHZlYy5ub3JtYWxpemUoKTtcblxuXHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpLTEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cblx0XHR9XG5cblx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdH1cblxuXG5cdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRpZiAoIGNsb3NlZCApIHtcblxuXHRcdHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMtMSBdICksIC0gMSwgMSApICk7XG5cdFx0dGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cy0xIF0gKSApID4gMCApIHtcblxuXHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cblx0XHR9XG5cblx0fVxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuXHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cblx0fVxuXG5cdHZhciBtaWRwb2ludHMgPSBbXSwgcCA9IHRoaXMudmVydGljZXM7XG5cblx0dmFyIGZhY2VzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xuXG5cdFx0dmFyIHYxID0gcFsgaW5kaWNlc1sgaSAgICAgXSBdO1xuXHRcdHZhciB2MiA9IHBbIGluZGljZXNbIGkgKyAxIF0gXTtcblx0XHR2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XG5cblx0XHRmYWNlc1sgaiBdID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xuXG5cdH1cblxuXHR2YXIgY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRzdWJkaXZpZGUoIGZhY2VzWyBpIF0sIGRldGFpbCApO1xuXG5cdH1cblxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cblx0XHR2YXIgeDAgPSB1dnNbIDAgXS54O1xuXHRcdHZhciB4MSA9IHV2c1sgMSBdLng7XG5cdFx0dmFyIHgyID0gdXZzWyAyIF0ueDtcblxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggeDAsIE1hdGgubWF4KCB4MSwgeDIgKSApO1xuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIE1hdGgubWluKCB4MSwgeDIgKSApO1xuXG5cdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkgeyAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XG5cdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xuXHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2c1sgMiBdLnggKz0gMTtcblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBcHBseSByYWRpdXNcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG5cdH1cblxuXG5cdC8vIE1lcmdlIHZlcnRpY2VzXG5cblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cblxuXHQvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcblxuXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XG5cblx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XG5cdFx0dmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XG5cblx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXG5cblx0XHR2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xuXHRcdHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xuXG5cdFx0cmV0dXJuIHZlcnRleDtcblxuXHR9XG5cblxuXHQvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxuXG5cdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMgKSB7XG5cblx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0gKTtcblx0XHR0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdGNlbnRyb2lkLmNvcHkoIHYxICkuYWRkKCB2MiApLmFkZCggdjMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcblxuXHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xuXG5cdFx0dGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXHRcdFx0Y29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxuXHRcdFx0Y29ycmVjdFVWKCB2Mi51diwgdjIsIGF6aSApLFxuXHRcdFx0Y29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXG5cdFx0XSApO1xuXG5cdH1cblxuXG5cdC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXG5cblx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBmYWNlLCBkZXRhaWwgKSB7XG5cblx0XHR2YXIgY29scyA9IE1hdGgucG93KDIsIGRldGFpbCk7XG5cdFx0dmFyIGNlbGxzID0gTWF0aC5wb3coNCwgZGV0YWlsKTtcblx0XHR2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XG5cdFx0dmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xuXHRcdHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblx0XHR2YXIgdiA9IFtdO1xuXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdHZbIGkgXSA9IFtdO1xuXG5cdFx0XHR2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuXHRcdFx0dmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcblx0XHRcdHZhciByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqICsrKSB7XG5cblx0XHRcdFx0aWYgKCBqID09IDAgJiYgaSA9PSBjb2xzICkge1xuXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbHMgOyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKGNvbHMgLSBpKSAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdGlmICggaiAlIDIgPT0gMCApIHtcblxuXHRcdFx0XHRcdG1ha2UoXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGsgKyAxXSxcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgXSxcblx0XHRcdFx0XHRcdHZbIGkgXVsgayBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWFrZShcblx0XHRcdFx0XHRcdHZbIGkgXVsgayArIDEgXSxcblx0XHRcdFx0XHRcdHZbIGkgKyAxXVsgayArIDFdLFxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cblx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0fVxuXG5cblx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG5cdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuXHR9XG5cblxuXHQvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXG5cdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcblxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcblx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcblx0XHRyZXR1cm4gdXYuY2xvbmUoKTtcblxuXHR9XG5cblxufTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXG4gKi9cblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cdHZhciByID0gMSAvIHQ7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXG5cdFx0Ly8gKMKxMSwgwrExLCDCsTEpXG5cdFx0LTEsIC0xLCAtMSwgICAgLTEsIC0xLCAgMSxcblx0XHQtMSwgIDEsIC0xLCAgICAtMSwgIDEsICAxLFxuXHRcdCAxLCAtMSwgLTEsICAgICAxLCAtMSwgIDEsXG5cdFx0IDEsICAxLCAtMSwgICAgIDEsICAxLCAgMSxcblxuXHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXG5cdFx0IDAsIC1yLCAtdCwgICAgIDAsIC1yLCAgdCxcblx0XHQgMCwgIHIsIC10LCAgICAgMCwgIHIsICB0LFxuXG5cdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHQtciwgLXQsICAwLCAgICAtciwgIHQsICAwLFxuXHRcdCByLCAtdCwgIDAsICAgICByLCAgdCwgIDAsXG5cblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdC10LCAgMCwgLXIsICAgICB0LCAgMCwgLXIsXG5cdFx0LXQsICAwLCAgciwgICAgIHQsICAwLCAgclxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdCAzLCAxMSwgIDcsICAgICAgMywgIDcsIDE1LCAgICAgIDMsIDE1LCAxMyxcblx0XHQgNywgMTksIDE3LCAgICAgIDcsIDE3LCAgNiwgICAgICA3LCAgNiwgMTUsXG5cdFx0MTcsICA0LCAgOCwgICAgIDE3LCAgOCwgMTAsICAgICAxNywgMTAsICA2LFxuXHRcdCA4LCAgMCwgMTYsICAgICAgOCwgMTYsICAyLCAgICAgIDgsICAyLCAxMCxcblx0XHQgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXG5cdFx0IDYsIDEwLCAgMiwgICAgICA2LCAgMiwgMTMsICAgICAgNiwgMTMsIDE1LFxuXHRcdCAyLCAxNiwgMTgsICAgICAgMiwgMTgsICAzLCAgICAgIDIsICAzLCAxMyxcblx0XHQxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXG5cdFx0IDQsIDE0LCAxMiwgICAgICA0LCAxMiwgIDAsICAgICAgNCwgIDAsICA4LFxuXHRcdDExLCAgOSwgIDUsICAgICAxMSwgIDUsIDE5LCAgICAgMTEsIDE5LCAgNyxcblx0XHQxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXG5cdFx0IDEsIDEyLCAxNCwgICAgICAxLCAxNCwgIDUsICAgICAgMSwgIDUsICA5XG5cdF07XG5cblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG59O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHQtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcblx0XHQgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcblx0XHQgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcblx0XHQgMSwgIDUsICA5LCAgICA1LCAxMSwgIDQsICAgMTEsIDEwLCAgMiwgICAxMCwgIDcsICA2LCAgICA3LCAgMSwgIDgsXG5cdFx0IDMsICA5LCAgNCwgICAgMywgIDQsICAyLCAgICAzLCAgMiwgIDYsICAgIDMsICA2LCAgOCwgICAgMywgIDgsICA5LFxuXHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxuXHRdO1xuXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdGRldGFpbDogZGV0YWlsXG5cdH07XG59O1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxuXHR2YXIgdmVydGljZXMgPSBbXG5cdFx0MSwgMCwgMCwgICAtIDEsIDAsIDAsICAgIDAsIDEsIDAsICAgIDAsLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLC0gMVxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdDAsIDIsIDQsICAgIDAsIDQsIDMsICAgIDAsIDMsIDUsICAgIDAsIDUsIDIsICAgIDEsIDIsIDUsICAgIDEsIDUsIDMsICAgIDEsIDMsIDQsICAgIDEsIDQsIDJcblx0XTtcblxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdGRldGFpbDogZGV0YWlsXG5cdH07XG59O1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXHRcdCAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcblx0XTtcblxuXHR2YXIgaW5kaWNlcyA9IFtcblx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG5cdF07XG5cblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxufTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGFyYW1ldHJpY0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XG4gKlxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcbiAqXG4gKi9cblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdGZ1bmM6IGZ1bmMsXG5cdFx0c2xpY2VzOiBzbGljZXMsXG5cdFx0c3RhY2tzOiBzdGFja3Ncblx0fTtcblxuXHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuXHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuXHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cblx0dmFyIGksIGlsLCBqLCBwO1xuXHR2YXIgdSwgdjtcblxuXHR2YXIgc3RhY2tDb3VudCA9IHN0YWNrcyArIDE7XG5cdHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcblxuXHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XG5cblx0XHR2ID0gaSAvIHN0YWNrcztcblxuXHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcblxuXHRcdFx0dSA9IGogLyBzbGljZXM7XG5cblx0XHRcdHAgPSBmdW5jKCB1LCB2ICk7XG5cdFx0XHR2ZXJ0cy5wdXNoKCBwICk7XG5cblx0XHR9XG5cdH1cblxuXHR2YXIgYSwgYiwgYywgZDtcblx0dmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcblxuXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG5cdFx0XHRhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuXHRcdFx0YiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG5cdFx0XHRjID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcblx0XHRcdGQgPSAoaSArIDEpICogc2xpY2VDb3VudCArIGo7XG5cblx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG5cdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXHRcdFx0dXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuXHQvLyBtYWdpYyBidWxsZXRcblx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcblx0Ly8gY29uc29sZS5sb2coJ3JlbW92ZWQgJywgZGlmZiwgJyB2ZXJ0aWNlcyBieSBtZXJnaW5nJyk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0c2l6ZSA9IHNpemUgfHwgMTtcblxuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0MCwgMCwgMCwgIHNpemUsIDAsIDAsXG5cdFx0MCwgMCwgMCwgIDAsIHNpemUsIDAsXG5cdFx0MCwgMCwgMCwgIDAsIDAsIHNpemVcblx0XSApO1xuXG5cdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcblx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxuXHRcdDAsIDAsIDEsICAwLCAwLjYsIDFcblx0XSApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIFRIUkVFLkxpbmVQaWVjZXMgKTtcblxufTtcblxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BcnJvd0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiAgZGlyIC0gVmVjdG9yM1xuICogIG9yaWdpbiAtIFZlY3RvcjNcbiAqICBsZW5ndGggLSBOdW1iZXJcbiAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcbiAqL1xuXG5USFJFRS5BcnJvd0hlbHBlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblxuXHR2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xuXHRjb25lR2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKCAwLCAtIDAuNSwgMCApICk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG5cdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XG5cdFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuXHRcdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcblxuXHRcdHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXHRcdHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG5cdFx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuXHRcdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXG5cdH1cblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgcmFkaWFucztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBkaXIgKSB7XG5cblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG5cdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG5cdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCwgMSApO1xuXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XG5cblx0dGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG5cdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxufTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDcyICksIDMgKSApO1xuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0fVxuXG5cdHZhciBtaW4gPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5taW47XG5cdHZhciBtYXggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5tYXg7XG5cblx0Lypcblx0ICA1X19fXzRcblx0MS9fX18wL3xcblx0fCA2X198Xzdcblx0Mi9fX18zL1xuXG5cdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0MTogbWluLngsIG1heC55LCBtYXguelxuXHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0NDogbWF4LngsIG1heC55LCBtaW4uelxuXHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0NzogbWF4LngsIG1pbi55LCBtaW4uelxuXHQqL1xuXG5cdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHR2ZXJ0aWNlc1sgIDAgXSA9IG1heC54OyB2ZXJ0aWNlc1sgIDEgXSA9IG1heC55OyB2ZXJ0aWNlc1sgIDIgXSA9IG1heC56O1xuXHR2ZXJ0aWNlc1sgIDMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgIDQgXSA9IG1heC55OyB2ZXJ0aWNlc1sgIDUgXSA9IG1heC56O1xuXG5cdHZlcnRpY2VzWyAgNiBdID0gbWluLng7IHZlcnRpY2VzWyAgNyBdID0gbWF4Lnk7IHZlcnRpY2VzWyAgOCBdID0gbWF4Lno7XG5cdHZlcnRpY2VzWyAgOSBdID0gbWluLng7IHZlcnRpY2VzWyAxMCBdID0gbWluLnk7IHZlcnRpY2VzWyAxMSBdID0gbWF4Lno7XG5cblx0dmVydGljZXNbIDEyIF0gPSBtaW4ueDsgdmVydGljZXNbIDEzIF0gPSBtaW4ueTsgdmVydGljZXNbIDE0IF0gPSBtYXguejtcblx0dmVydGljZXNbIDE1IF0gPSBtYXgueDsgdmVydGljZXNbIDE2IF0gPSBtaW4ueTsgdmVydGljZXNbIDE3IF0gPSBtYXguejtcblxuXHR2ZXJ0aWNlc1sgMTggXSA9IG1heC54OyB2ZXJ0aWNlc1sgMTkgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMjAgXSA9IG1heC56O1xuXHR2ZXJ0aWNlc1sgMjEgXSA9IG1heC54OyB2ZXJ0aWNlc1sgMjIgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMjMgXSA9IG1heC56O1xuXG5cdC8vXG5cblx0dmVydGljZXNbIDI0IF0gPSBtYXgueDsgdmVydGljZXNbIDI1IF0gPSBtYXgueTsgdmVydGljZXNbIDI2IF0gPSBtaW4uejtcblx0dmVydGljZXNbIDI3IF0gPSBtaW4ueDsgdmVydGljZXNbIDI4IF0gPSBtYXgueTsgdmVydGljZXNbIDI5IF0gPSBtaW4uejtcblxuXHR2ZXJ0aWNlc1sgMzAgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzEgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMzIgXSA9IG1pbi56O1xuXHR2ZXJ0aWNlc1sgMzMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMzUgXSA9IG1pbi56O1xuXG5cdHZlcnRpY2VzWyAzNiBdID0gbWluLng7IHZlcnRpY2VzWyAzNyBdID0gbWluLnk7IHZlcnRpY2VzWyAzOCBdID0gbWluLno7XG5cdHZlcnRpY2VzWyAzOSBdID0gbWF4Lng7IHZlcnRpY2VzWyA0MCBdID0gbWluLnk7IHZlcnRpY2VzWyA0MSBdID0gbWluLno7XG5cblx0dmVydGljZXNbIDQyIF0gPSBtYXgueDsgdmVydGljZXNbIDQzIF0gPSBtaW4ueTsgdmVydGljZXNbIDQ0IF0gPSBtaW4uejtcblx0dmVydGljZXNbIDQ1IF0gPSBtYXgueDsgdmVydGljZXNbIDQ2IF0gPSBtYXgueTsgdmVydGljZXNbIDQ3IF0gPSBtaW4uejtcblxuXHQvL1xuXG5cdHZlcnRpY2VzWyA0OCBdID0gbWF4Lng7IHZlcnRpY2VzWyA0OSBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MCBdID0gbWF4Lno7XG5cdHZlcnRpY2VzWyA1MSBdID0gbWF4Lng7IHZlcnRpY2VzWyA1MiBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MyBdID0gbWluLno7XG5cblx0dmVydGljZXNbIDU0IF0gPSBtaW4ueDsgdmVydGljZXNbIDU1IF0gPSBtYXgueTsgdmVydGljZXNbIDU2IF0gPSBtYXguejtcblx0dmVydGljZXNbIDU3IF0gPSBtaW4ueDsgdmVydGljZXNbIDU4IF0gPSBtYXgueTsgdmVydGljZXNbIDU5IF0gPSBtaW4uejtcblxuXHR2ZXJ0aWNlc1sgNjAgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNjEgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNjIgXSA9IG1heC56O1xuXHR2ZXJ0aWNlc1sgNjMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNjQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNjUgXSA9IG1pbi56O1xuXG5cdHZlcnRpY2VzWyA2NiBdID0gbWF4Lng7IHZlcnRpY2VzWyA2NyBdID0gbWluLnk7IHZlcnRpY2VzWyA2OCBdID0gbWF4Lno7XG5cdHZlcnRpY2VzWyA2OSBdID0gbWF4Lng7IHZlcnRpY2VzWyA3MCBdID0gbWluLnk7IHZlcnRpY2VzWyA3MSBdID0gbWluLno7XG5cblx0dGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XG5cbn07XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuXHR0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XG5cblx0dGhpcy5ib3guY2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuICogXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXG4gKi9cblxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XG5cblx0dmFyIHBvaW50TWFwID0ge307XG5cblx0Ly8gY29sb3JzXG5cblx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcblx0dmFyIGhleENvbmUgPSAweGZmMDAwMDtcblx0dmFyIGhleFVwID0gMHgwMGFhZmY7XG5cdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcblx0dmFyIGhleENyb3NzID0gMHgzMzMzMzM7XG5cblx0Ly8gbmVhclxuXG5cdGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjRcIiwgXCJuM1wiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XG5cblx0Ly8gZmFyXG5cblx0YWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcblxuXHQvLyBzaWRlc1xuXG5cdGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG5cblx0Ly8gY29uZVxuXG5cdGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcblx0YWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xuXHRhZGRMaW5lKCBcInBcIiwgXCJuM1wiLCBoZXhDb25lICk7XG5cdGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcblxuXHQvLyB1cFxuXG5cdGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xuXHRhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcblx0YWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGhleFVwICk7XG5cblx0Ly8gdGFyZ2V0XG5cblx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcblx0YWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xuXG5cdC8vIGNyb3NzXG5cblx0YWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcblx0YWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcblxuXHRhZGRMaW5lKCBcImNmMVwiLCBcImNmMlwiLCBoZXhDcm9zcyApO1xuXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xuXG5cdGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGhleCApIHtcblxuXHRcdGFkZFBvaW50KCBhLCBoZXggKTtcblx0XHRhZGRQb2ludCggYiwgaGV4ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG5cblx0XHRpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cblx0XHR9XG5cblx0XHRwb2ludE1hcFsgaWQgXS5wdXNoKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG5cblx0fVxuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cdFxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuXHR2YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCB4LCB5LCB6ICkge1xuXG5cdFx0dmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cblx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuXHRcdHZhciB3ID0gMSwgaCA9IDE7XG5cblx0XHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG5cdFx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuXHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdC8vIGNlbnRlciAvIHRhcmdldFxuXG5cdFx0c2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRzZXRQb2ludCggXCJuMVwiLCAtIHcsIC0gaCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwibjJcIiwgICB3LCAtIGgsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJuNFwiLCAgIHcsICAgaCwgLSAxICk7XG5cblx0XHQvLyBmYXJcblxuXHRcdHNldFBvaW50KCBcImYxXCIsIC0gdywgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiZjJcIiwgICB3LCAtIGgsIDEgKTtcblx0XHRzZXRQb2ludCggXCJmM1wiLCAtIHcsICAgaCwgMSApO1xuXHRcdHNldFBvaW50KCBcImY0XCIsICAgdywgICBoLCAxICk7XG5cblx0XHQvLyB1cFxuXG5cdFx0c2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJ1MlwiLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcInUzXCIsICAgICAgICAgMCwgaCAqIDIsICAgLSAxICk7XG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0c2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY2YyXCIsICAgdywgICAwLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY2YzXCIsICAgMCwgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XG5cblx0XHRzZXRQb2ludCggXCJjbjFcIiwgLSB3LCAgIDAsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY24zXCIsICAgMCwgLSBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJjbjRcIiwgICAwLCAgIGgsIC0gMSApO1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0RpcmVjdGlvbmFsTGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzaXplICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRzaXplID0gc2l6ZSB8fCAxO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsICAgc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsIC0gc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIC0gc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApXG5cdCk7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0dGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XG5cblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKClcblx0KTtcblxuXHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0dGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XG5cblx0XHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB2MyApO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IgKTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0VkZ2VzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xuXG5cdHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcblx0dmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uICggYSwgYiApIHsgcmV0dXJuIGEgLSBiIH07XG5cblx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0dmFyIGdlb21ldHJ5MiA9IG9iamVjdC5nZW9tZXRyeS5jbG9uZSgpO1xuXG5cdGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XG5cdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG5cdHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcblx0dmFyIG51bUVkZ2VzID0gMDtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG5cdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcblx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRoYXNoWyBrZXkgXSA9IHsgdmVydDE6IGVkZ2VbIDAgXSwgdmVydDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcblx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cblx0dmFyIGluZGV4ID0gMDtcblxuXHRmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XG5cblx0XHR2YXIgaCA9IGhhc2hbIGtleSBdO1xuXG5cdFx0aWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDwgMC45OTk5ICkgeyAvLyBoYXJkd2lyZWQgY29uc3QgT0tcblxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XG5cdFx0XHRjb29yZHNbIGluZGV4ICsrIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdGNvb3Jkc1sgaW5kZXggKysgXSA9IHZlcnRleC55O1xuXHRcdFx0Y29vcmRzWyBpbmRleCArKyBdID0gdmVydGV4Lno7XG5cblx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XG5cdFx0XHRjb29yZHNbIGluZGV4ICsrIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdGNvb3Jkc1sgaW5kZXggKysgXSA9IHZlcnRleC55O1xuXHRcdFx0Y29vcmRzWyBpbmRleCArKyBdID0gdmVydGV4Lno7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRmFjZU5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXG5cdH1cblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0dmFyIG9iamVjdCA9IHRoaXMub2JqZWN0O1xuXHR2YXIgb2JqZWN0VmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cdHZhciBvYmplY3RGYWNlcyA9IG9iamVjdC5nZW9tZXRyeS5mYWNlcztcblx0dmFyIG9iamVjdFdvcmxkTWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0V29ybGRNYXRyaXggKTtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGkyID0gMCwgbCA9IG9iamVjdEZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKyssIGkyICs9IDIgKSB7XG5cblx0XHR2YXIgZmFjZSA9IG9iamVjdEZhY2VzWyBpIF07XG5cblx0XHR2ZXJ0aWNlc1sgaTIgXS5jb3B5KCBvYmplY3RWZXJ0aWNlc1sgZmFjZS5hIF0gKVxuXHRcdFx0LmFkZCggb2JqZWN0VmVydGljZXNbIGZhY2UuYiBdIClcblx0XHRcdC5hZGQoIG9iamVjdFZlcnRpY2VzWyBmYWNlLmMgXSApXG5cdFx0XHQuZGl2aWRlU2NhbGFyKCAzIClcblx0XHRcdC5hcHBseU1hdHJpeDQoIG9iamVjdFdvcmxkTWF0cml4ICk7XG5cblx0XHR2ZXJ0aWNlc1sgaTIgKyAxIF0uY29weSggZmFjZS5ub3JtYWwgKVxuXHRcdFx0LmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKVxuXHRcdFx0Lm5vcm1hbGl6ZSgpXG5cdFx0XHQubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApXG5cdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgaTIgXSApO1xuXG5cdH1cblxuXHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvR3JpZEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSwgc3RlcCApIHtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcblxuXHR0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcblx0dGhpcy5jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ODg4ODg4ICk7XG5cblx0Zm9yICggdmFyIGkgPSAtIHNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwICkge1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCAtIHNpemUgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIHNpemUgKVxuXHRcdCk7XG5cblx0XHR2YXIgY29sb3IgPSBpID09PSAwID8gdGhpcy5jb2xvcjEgOiB0aGlzLmNvbG9yMjtcblxuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG5cdH1cblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG59O1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uKCBjb2xvckNlbnRlckxpbmUsIGNvbG9yR3JpZCApIHtcblxuXHR0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xuXHR0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xuXG5cdHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbn1cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSwgYXJyb3dMZW5ndGgsIGRvbWVTaXplICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLmNvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG5cdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoIC0gTWF0aC5QSSAvIDIgKSApO1xuXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuXHR9XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcblxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHR0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb2xvcnNbIDAgXS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cdFx0dGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLmxpZ2h0U3BoZXJlLmxvb2tBdCggdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XG5cdFx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHQvKlxuXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XG5cdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XG5cdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XG5cblx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHR9XG5cblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHQqL1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdC8qXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXHQqL1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Ta2VsZXRvbkhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLlNrZWxldG9uSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMCwgMSApICk7XG5cdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAxLCAwICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5yb290ID0gb2JqZWN0O1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cblx0dmFyIGJvbmVMaXN0ID0gW107XG5cblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cblx0fVxuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYm9uZUxpc3Q7XG5cbn07XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG5cdHZhciBib25lTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR2YXIgaiA9IDA7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cblx0XHRcdGogKz0gMjtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU3BvdExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlNwb3RMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XG5cblx0Z2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKCAwLCAtIDAuNSwgMCApICk7XG5cdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoIC0gTWF0aC5QSSAvIDIgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuXG5cdHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xuXHRcdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcblxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cblx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0dmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcblxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0fTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XG5cblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHR2YXIgdmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0dmFyIGZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5ub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgdmVydHMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdHZhciBmYWNlcyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0dmFyIHdvcmxkTWF0cml4ID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cblx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4SWQgPSBmYWNlWyBrZXlzWyBqIF0gXTtcblx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRzWyB2ZXJ0ZXhJZCBdO1xuXG5cdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgaWR4IF0uY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCB3b3JsZE1hdHJpeCApO1xuXG5cdFx0XHRcdHYxLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICk7XG5cblx0XHRcdFx0djEuYWRkKCB2ZXJ0aWNlc1sgaWR4IF0gKTtcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgaWR4IF0uY29weSggdjEgKTtcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59KCkpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhUYW5nZW50c0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweDAwMDBmZjtcblxuXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHR2YXIgZmFjZXMgPSBvYmplY3QuZ2VvbWV0cnkuZmFjZXM7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuXHRcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcblxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0dmFyIHZlcnRzID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuXHRcdHZhciB3b3JsZE1hdHJpeCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdFx0dmFyIGlkeCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhJZCA9IGZhY2VbIGtleXNbIGogXSBdO1xuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydHNbIHZlcnRleElkIF07XG5cblx0XHRcdFx0dmFyIHRhbmdlbnQgPSBmYWNlLnZlcnRleFRhbmdlbnRzWyBqIF07XG5cblx0XHRcdFx0dmVydGljZXNbIGlkeCBdLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggd29ybGRNYXRyaXggKTtcblxuXHRcdFx0XHR2MS5jb3B5KCB0YW5nZW50ICkudHJhbnNmb3JtRGlyZWN0aW9uKCB3b3JsZE1hdHJpeCApLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKTtcblxuXHRcdFx0XHR2MS5hZGQoIHZlcnRpY2VzWyBpZHggXSApO1xuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2MSApO1xuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0oKSk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1dpcmVmcmFtZUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcblxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG5cdHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiAoIGEsIGIgKSB7IHJldHVybiBhIC0gYiB9O1xuXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG5cdGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cdFx0dmFyIGZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXHRcdHZhciBudW1FZGdlcyA9IDA7XG5cblx0XHQvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcblx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcblx0XHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG5cdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG5cdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcblx0XHRcdFx0XHRoYXNoWyBrZXkgXSA9IHRydWU7XG5cdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXMgWyAyICogaSArIGpdIF07XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRleC54O1xuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdH0gZWxzZSBpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkgeyAvLyBJbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdFx0dmFyIGluZGljZXMgPSBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblx0XHRcdHZhciBkcmF3Y2FsbHMgPSBvYmplY3QuZ2VvbWV0cnkuZHJhd2NhbGxzO1xuXHRcdFx0dmFyIG51bUVkZ2VzID0gMDtcblxuXHRcdFx0aWYgKCBkcmF3Y2FsbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdGRyYXdjYWxscyA9IFsgeyBjb3VudCA6IGluZGljZXMubGVuZ3RoLCBpbmRleCA6IDAsIHN0YXJ0IDogMCB9IF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG5cdFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gZHJhd2NhbGxzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG5cdFx0XHRcdHZhciBzdGFydCA9IGRyYXdjYWxsc1sgbyBdLnN0YXJ0O1xuXHRcdFx0XHR2YXIgY291bnQgPSBkcmF3Y2FsbHNbIG8gXS5jb3VudDtcblx0XHRcdFx0dmFyIGluZGV4ID0gZHJhd2NhbGxzWyBvIF0uaW5kZXg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArIGogXTtcblx0XHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcblx0XHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG5cdFx0XHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuXHRcdFx0XHRcdHZhciBpbmRleDIgPSAzICogZWRnZXNbIDIgKiBpICsgal07XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdFx0fSBlbHNlIHsgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0XHR2YXIgbnVtRWRnZXMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXHRcdFx0dmFyIG51bVRyaXMgPSBudW1FZGdlcyAvIDM7XG5cblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bVRyaXM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSAxOCAqIGkgKyA2ICogajtcblxuXHRcdFx0XHRcdHZhciBpbmRleDEgPSA5ICogaSArIDMgKiBqO1xuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAxIF07XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAyIF07XG5cblx0XHRcdFx0XHR2YXIgaW5kZXgyID0gOSAqIGkgKyAzICogKCAoIGogKyAxICkgJSAzICk7XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDMgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNSBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcblxufTtcblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy5hbmltYXRpb25zTWFwID0ge307XG5cdHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcblxuXHQvLyBwcmVwYXJlIGRlZmF1bHQgYW5pbWF0aW9uXG5cdC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcblxuXHR2YXIgbnVtRnJhbWVzID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xuXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcblxuXHR2YXIgc3RhcnRGcmFtZSA9IDA7XG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XG5cblx0dmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XG5cblx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcblx0dGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB7XG5cblx0XHRzdGFydEZyYW1lOiBzdGFydCxcblx0XHRlbmRGcmFtZTogZW5kLFxuXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXG5cblx0XHRmcHM6IGZwcyxcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxuXG5cdFx0bGFzdEZyYW1lOiAwLFxuXHRcdGN1cnJlbnRGcmFtZTogMCxcblxuXHRcdGFjdGl2ZTogZmFsc2UsXG5cblx0XHR0aW1lOiAwLFxuXHRcdGRpcmVjdGlvbjogMSxcblx0XHR3ZWlnaHQ6IDEsXG5cblx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcblxuXHR9O1xuXG5cdHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xuXHR0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcblxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XG5cblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0dmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHR2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xuXHRcdFx0dmFyIG51bSA9IGNodW5rc1sgMiBdO1xuXG5cdFx0XHRpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cblx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cblx0XHRcdGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xuXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcblxuXHRcdFx0aWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCB2YXIgbmFtZSBpbiBmcmFtZVJhbmdlcyApIHtcblxuXHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cdFx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xuXG5cdH1cblxuXHR0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcblxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHRhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XG5cblx0fVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XG5cblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdGlmICggYW5pbWF0aW9uICkge1xuXG5cdFx0YW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi50aW1lID0gdGltZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciB0aW1lID0gMDtcblxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHR0aW1lID0gYW5pbWF0aW9uLnRpbWU7XG5cblx0fVxuXG5cdHJldHVybiB0aW1lO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0dmFyIGR1cmF0aW9uID0gLSAxO1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG5cdH1cblxuXHRyZXR1cm4gZHVyYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi50aW1lID0gMDtcblx0XHRhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc29sZS53YXJuKCBcImFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkXCIgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcblxuXHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XG5cblx0XHR2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcblxuXHRcdGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcblxuXHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcblxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XG5cblx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtIDE7XG5cblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuXHRcdH1cblxuXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydEZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcblxuXHRcdGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IDEgKiB3ZWlnaHQ7XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcblxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XG5cdFx0XHRhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XG5cblx0XHR9XG5cblx0XHR2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG5cdFx0aWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9ICggMSAtIG1peCApICogd2VpZ2h0O1xuXG5cdH1cblxufTtcblxuXG4vLyBFeHBvcnQgdGhlIFRIUkVFIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbi8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbi8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcbiAgfVxuICBleHBvcnRzLlRIUkVFID0gVEhSRUU7XG59IGVsc2Uge1xuICB0aGlzWydUSFJFRSddID0gVEhSRUU7XG59XG4iXX0=
